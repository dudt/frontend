{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/definitions/Basic Configuration Modules",
  "definitions": {
    "OutboundObject": {
      "title": "OutboundObject",
      "description": "\nThe `OutboundObject` corresponds to a sub-element of the `outbounds` item in the configuration file.\n\n::: tip\nThe first element in the list serves as the main outbound. When there is no match or no successful match for the routing, the traffic is sent out by the main outbound.\n:::\n\n```json\n{\n  \"outbounds\": [\n    {\n      \"sendThrough\": \"0.0.0.0\",\n      \"protocol\": \"protocol name\",\n      \"settings\": {},\n      \"tag\": \"identifier\",\n      \"streamSettings\": {},\n      \"proxySettings\": {\n        \"tag\": \"another-outbound-tag\"\n      },\n      \"mux\": {}\n    }\n  ]\n}\n```\n\n",
      "markdownDescription": "\nThe `OutboundObject` corresponds to a sub-element of the `outbounds` item in the configuration file.\n\n::: tip\nThe first element in the list serves as the main outbound. When there is no match or no successful match for the routing, the traffic is sent out by the main outbound.\n:::\n\n```json\n{\n  \"outbounds\": [\n    {\n      \"sendThrough\": \"0.0.0.0\",\n      \"protocol\": \"protocol name\",\n      \"settings\": {},\n      \"tag\": \"identifier\",\n      \"streamSettings\": {},\n      \"proxySettings\": {\n        \"tag\": \"another-outbound-tag\"\n      },\n      \"mux\": {}\n    }\n  ]\n}\n```\n\n",
      "properties": {
        "sendThrough": {
          "name": "sendThrough",
          "description": "\nThe IP address used to send data. It is effective when the host has multiple IP addresses, and the default value is `\"0.0.0.0\"`.\n\nIt is allowed to fill in the IPv6 CIDR block (such as `114:514:1919:810::/64`),\nand Xray will use the random IP address in the address block to initiate\nexternal connections. Network access, routing tables, and kernel parameters\nneed to be configured correctly to allow Xray to bind to any IP within the\naddress block.\n\nFor networks that use ndp to access, it is not recommended to set a subnet\nsmaller than `/120`, otherwise it may cause NDP flood and a series of problems\nsuch as the router neighbor cache being filled up.\n\n",
          "markdownDescription": "\nThe IP address used to send data. It is effective when the host has multiple IP addresses, and the default value is `\"0.0.0.0\"`.\n\nIt is allowed to fill in the IPv6 CIDR block (such as `114:514:1919:810::/64`),\nand Xray will use the random IP address in the address block to initiate\nexternal connections. Network access, routing tables, and kernel parameters\nneed to be configured correctly to allow Xray to bind to any IP within the\naddress block.\n\nFor networks that use ndp to access, it is not recommended to set a subnet\nsmaller than `/120`, otherwise it may cause NDP flood and a series of problems\nsuch as the router neighbor cache being filled up.\n\n",
          "type": "string"
        },
        "protocol": {
          "name": "protocol",
          "description": "\nThe name of the connection protocol. For a list of optional protocols, see\nOutbound Proxy in the left sidebar.\n\n",
          "markdownDescription": "\nThe name of the connection protocol. For a list of optional protocols, see\nOutbound Proxy in the left sidebar.\n\n",
          "type": "string"
        },
        "settings": {
          "name": "settings",
          "description": "\nThe specific configuration content varies depending on the protocol. See `OutboundConfigurationObject` in each protocol for details.\n\n",
          "markdownDescription": "\nThe specific configuration content varies depending on the protocol. See `OutboundConfigurationObject` in each protocol for details.\n\n",
          "$ref": "#/definitions/OutboundConfigurationObject"
        },
        "tag": {
          "name": "tag",
          "description": "\nThe identifier of this outbound connection, used to locate this connection in other configurations.\n\n::: danger\nWhen it is not empty, its value must be **unique** among all `tag`s.\n:::\n\n",
          "markdownDescription": "\nThe identifier of this outbound connection, used to locate this connection in other configurations.\n\n::: danger\nWhen it is not empty, its value must be **unique** among all `tag`s.\n:::\n\n",
          "type": "string"
        },
        "streamSettings": {
          "name": "streamSettings",
          "description": "\nThe underlying transport method is the way the current Xray connects with other nodes.\n\n",
          "markdownDescription": "\nThe underlying transport method is the way the current Xray connects with other nodes.\n\n",
          "$ref": "#/definitions/StreamSettingsObject"
        },
        "proxySettings": {
          "name": "proxySettings",
          "description": "\nThe outbound proxy configuration. When the outbound proxy takes effect, the\n`streamSettings` of this outbound will not work.\n\n",
          "markdownDescription": "\nThe outbound proxy configuration. When the outbound proxy takes effect, the\n`streamSettings` of this outbound will not work.\n\n",
          "$ref": "#/definitions/ProxySettingsObject"
        },
        "mux": {
          "name": "mux",
          "description": "\nSpecific configuration related to Mux.\n\n",
          "markdownDescription": "\nSpecific configuration related to Mux.\n\n",
          "$ref": "#/definitions/MuxObject"
        }
      },
      "additionalProperties": false
    },
    "ProxySettingsObject": {
      "title": "ProxySettingsObject",
      "description": "\n```json\n{\n  \"tag\": \"another-outbound-tag\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"tag\": \"another-outbound-tag\"\n}\n```\n\n",
      "properties": {
        "tag": {
          "name": "tag",
          "description": "\nWhen specifying the identifier of another outbound, data emitted by this outbound will be forwarded to the specified outbound.\n\n::: danger\nThis forwarding method does **not go through** the underlying transport. If you need to use forwarding that supports the underlying transport, please use [SockOpt.dialerProxy](./transport.md#sockoptobject).\n:::\n\n::: danger\nThis option is incompatible with SockOpt.dialerProxy.\n:::\n\n::: tip\nCompatible with v2fly/v2ray-core's configuration [transportLayer](https://www.v2fly.org/config/outbounds.html#proxysettingsobject).\n:::\n\n",
          "markdownDescription": "\nWhen specifying the identifier of another outbound, data emitted by this outbound will be forwarded to the specified outbound.\n\n::: danger\nThis forwarding method does **not go through** the underlying transport. If you need to use forwarding that supports the underlying transport, please use [SockOpt.dialerProxy](./transport.md#sockoptobject).\n:::\n\n::: danger\nThis option is incompatible with SockOpt.dialerProxy.\n:::\n\n::: tip\nCompatible with v2fly/v2ray-core's configuration [transportLayer](https://www.v2fly.org/config/outbounds.html#proxysettingsobject).\n:::\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "MuxObject": {
      "title": "MuxObject",
      "description": "\nThe Mux feature distributes the data of multiple TCP connections on a single TCP connection. For implementation details, see [Mux.Cool](../../development/protocols/muxcool). Mux is designed to reduce the latency of TCP handshake, not to increase the throughput of connections. Using Mux for watching videos, downloading, or speed testing usually has negative effects. Mux only needs to be enabled on the client side, and the server side automatically adapts. Mux has an additional function: to run multiple UDP connections, i.e. XUDP.\n\n`MuxObject` corresponds to the `mux` item in `OutboundObject`.\n\n```json\n{\n  \"enabled\": false,\n  \"concurrency\": 8\n}\n```\n\n",
      "markdownDescription": "\nThe Mux feature distributes the data of multiple TCP connections on a single TCP connection. For implementation details, see [Mux.Cool](../../development/protocols/muxcool). Mux is designed to reduce the latency of TCP handshake, not to increase the throughput of connections. Using Mux for watching videos, downloading, or speed testing usually has negative effects. Mux only needs to be enabled on the client side, and the server side automatically adapts. Mux has an additional function: to run multiple UDP connections, i.e. XUDP.\n\n`MuxObject` corresponds to the `mux` item in `OutboundObject`.\n\n```json\n{\n  \"enabled\": false,\n  \"concurrency\": 8\n}\n```\n\n",
      "properties": {
        "enabled": {
          "name": "enabled",
          "description": "\nWhether to enable Mux forwarding requests, default is `false`.\n\n",
          "markdownDescription": "\nWhether to enable Mux forwarding requests, default is `false`.\n\n",
          "type": "boolean"
        },
        "concurrency": {
          "name": "concurrency",
          "description": "\nMaximum concurrent connections. Minimum value is `1`, maximum value is `1024`.\nIf this parameter is omitted or equal to `0`, the value will be `8`.\n\nThis value represents the maximum number of Mux connections that can be carried on a TCP connection. For example, when `concurrency=8` is set, if the client sends 8 TCP requests, Xray will only send one actual TCP connection, and all 8 requests from the client will be transmitted through this TCP connection.\n\n::: tip\nWhen filling in a negative number, such as `-1`, the mux module is not loaded.\n:::\n\n",
          "markdownDescription": "\nMaximum concurrent connections. Minimum value is `1`, maximum value is `1024`.\nIf this parameter is omitted or equal to `0`, the value will be `8`.\n\nThis value represents the maximum number of Mux connections that can be carried on a TCP connection. For example, when `concurrency=8` is set, if the client sends 8 TCP requests, Xray will only send one actual TCP connection, and all 8 requests from the client will be transmitted through this TCP connection.\n\n::: tip\nWhen filling in a negative number, such as `-1`, the mux module is not loaded.\n:::\n\n",
          "type": "number"
        },
        "xudpConcurrency": {
          "name": "xudpConcurrency",
          "description": "\nUse a new XUDP aggregate tunnel (that is, another Mux connection) to proxy UDP\ntraffic and fill in the maximum number of concurrent sub-UoTs. minimum value\n`1`, the maximum value `1024`. If this parameter is omitted or equal to `0`,\nUDP traffic will use the same path as TCP traffic.\n\n::: tip\nWhen filling in negative numbers, such as `-1`, UDP will not be transmitted via\nMux. The original UDP transmission method of the proxy protocol will be used.\nFor example, Shadowsocks will use native UDP, VLESS will use UoT.\n:::\n\n",
          "markdownDescription": "\nUse a new XUDP aggregate tunnel (that is, another Mux connection) to proxy UDP\ntraffic and fill in the maximum number of concurrent sub-UoTs. minimum value\n`1`, the maximum value `1024`. If this parameter is omitted or equal to `0`,\nUDP traffic will use the same path as TCP traffic.\n\n::: tip\nWhen filling in negative numbers, such as `-1`, UDP will not be transmitted via\nMux. The original UDP transmission method of the proxy protocol will be used.\nFor example, Shadowsocks will use native UDP, VLESS will use UoT.\n:::\n\n",
          "type": "number"
        },
        "xudpProxyUDP443": {
          "name": "xudpProxyUDP443",
          "description": "\nControl how Mux handles proxied UDP/443 (QUIC) traffic:\n\n- Default `reject`: Deny traffic (generaly, browsers will fall back to to TCP HTTP/2)\n- `allow`: Allow connections.\n- `skip`: The Mux module is not used to carry UDP 443 traffic. The original UDP\n  transmission method of the proxy protocol will be used. For example,\n  Shadowsocks will use native UDP, VLESS will use UoT.\n# Fallback\n\n> **Fallback is one of the most powerful features of Xray, which can effectively prevent active probing and allows you to use one port for multiple services**\n\nFallback provides Xray with high-strength anti-active probing capabilities and has a unique first-packet fallback mechanism.\n\nFallback can also divide traffic of different types based on path for multi-service sharing on a single port.\n\nCurrently, you can use the fallback feature by configuring fallbacks when using VLESS or Trojan protocols, thus creating an unimaginable combo of services becomes REALITY.\n\n",
          "markdownDescription": "\nControl how Mux handles proxied UDP/443 (QUIC) traffic:\n\n- Default `reject`: Deny traffic (generaly, browsers will fall back to to TCP HTTP/2)\n- `allow`: Allow connections.\n- `skip`: The Mux module is not used to carry UDP 443 traffic. The original UDP\n  transmission method of the proxy protocol will be used. For example,\n  Shadowsocks will use native UDP, VLESS will use UoT.\n# Fallback\n\n> **Fallback is one of the most powerful features of Xray, which can effectively prevent active probing and allows you to use one port for multiple services**\n\nFallback provides Xray with high-strength anti-active probing capabilities and has a unique first-packet fallback mechanism.\n\nFallback can also divide traffic of different types based on path for multi-service sharing on a single port.\n\nCurrently, you can use the fallback feature by configuring fallbacks when using VLESS or Trojan protocols, thus creating an unimaginable combo of services becomes REALITY.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "fallbacks configuration": {
      "title": "fallbacks configuration",
      "description": "\n```json\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n```\n\n",
      "markdownDescription": "\n```json\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n```\n\n",
      "properties": {
        "fallbacks": {
          "name": "fallbacks",
          "description": "\n**`fallbacks` is an array, and here is an example configuration of one of its child elements.**\n\n",
          "markdownDescription": "\n**`fallbacks` is an array, and here is an example configuration of one of its child elements.**\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FallbackObject"
          }
        }
      },
      "additionalProperties": false
    },
    "FallbackObject": {
      "title": "FallbackObject",
      "description": "\n```json\n{\n  \"name\": \"\",\n  \"alpn\": \"\",\n  \"path\": \"\",\n  \"dest\": 80,\n  \"xver\": 0\n}\n```\n\nThe `fallbacks` object is optional and can only be used for the `TCP+TLS` transport combination.\n\n- When `fallbacks` configure with any child elements\uff0c`\"alpn\":[\"http/1.1\"]` needs to be configured in [Inbound TLS](../transport.md#tlsobject).\n\nUsually, you need to set up a default fallback with both `alpn` and `path` omitted or empty, and then configure other routing rules as needed.\n\nVLESS will forward traffic with TLS decrypted first packet length <18, invalid protocol version, or failed authentication to the address specified by `dest`.\n\nFor other transport combinations, you must remove the `fallbacks` object or all its child elements. At this point, no `fallbacks` will be enabled, and VLESS will wait until it reads enough data. If the protocol version is invalid or authentication fails, the connection will be terminated directly.\n\n",
      "markdownDescription": "\n```json\n{\n  \"name\": \"\",\n  \"alpn\": \"\",\n  \"path\": \"\",\n  \"dest\": 80,\n  \"xver\": 0\n}\n```\n\nThe `fallbacks` object is optional and can only be used for the `TCP+TLS` transport combination.\n\n- When `fallbacks` configure with any child elements\uff0c`\"alpn\":[\"http/1.1\"]` needs to be configured in [Inbound TLS](../transport.md#tlsobject).\n\nUsually, you need to set up a default fallback with both `alpn` and `path` omitted or empty, and then configure other routing rules as needed.\n\nVLESS will forward traffic with TLS decrypted first packet length <18, invalid protocol version, or failed authentication to the address specified by `dest`.\n\nFor other transport combinations, you must remove the `fallbacks` object or all its child elements. At this point, no `fallbacks` will be enabled, and VLESS will wait until it reads enough data. If the protocol version is invalid or authentication fails, the connection will be terminated directly.\n\n",
      "properties": {
        "name": {
          "name": "name",
          "description": "\nAttempt to match the TLS SNI (Server Name Indication), where an empty value matches any SNI. The default value is `\"\"`, which means empty value.\n\n",
          "markdownDescription": "\nAttempt to match the TLS SNI (Server Name Indication), where an empty value matches any SNI. The default value is `\"\"`, which means empty value.\n\n",
          "type": "string"
        },
        "alpn": {
          "name": "alpn",
          "description": "\nAttempt to match the result of TLS ALPN negotiation, where an empty value matches any ALPN result. The default value is `\"\"` , which means empty value.\n\nVLESS will read the TLS ALPN negotiation result only when necessary. If successful, it will output `realAlpn =` info to the log.\nPurpose: To solve the problem of Nginx's inability to simultaneously support http/1.1 and h2c services. Nginx needs to write two lines of listen, one for 1.1 and one for h2c.\nNote: When `\"h2\"` is included in fallbacks alpn, the Inbound TLS needs to be set as `\"alpn\":[\"h2\",\"http/1.1\"]` to support `h2` access.\n\n::: tip\nThe `alpn` set in the Fallback is used to match the actual negotiated ALPN, while the `alpn` set in the Inbound TLS represents the list of optional ALPNs during the handshake. These two have different meanings.\n:::\n\n",
          "markdownDescription": "\nAttempt to match the result of TLS ALPN negotiation, where an empty value matches any ALPN result. The default value is `\"\"` , which means empty value.\n\nVLESS will read the TLS ALPN negotiation result only when necessary. If successful, it will output `realAlpn =` info to the log.\nPurpose: To solve the problem of Nginx's inability to simultaneously support http/1.1 and h2c services. Nginx needs to write two lines of listen, one for 1.1 and one for h2c.\nNote: When `\"h2\"` is included in fallbacks alpn, the Inbound TLS needs to be set as `\"alpn\":[\"h2\",\"http/1.1\"]` to support `h2` access.\n\n::: tip\nThe `alpn` set in the Fallback is used to match the actual negotiated ALPN, while the `alpn` set in the Inbound TLS represents the list of optional ALPNs during the handshake. These two have different meanings.\n:::\n\n",
          "type": "string"
        },
        "path": {
          "name": "path",
          "description": "\nAttempt to match the first packet HTTP PATH, where an empty value matches any PATH and a default value is empty. If non-empty, it must start with `/`, and h2c is not supported.\n\nSmart: VLESS will only attempt to check the PATH (no more than 55 bytes; the fastest algorithm that does not fully parse HTTP) when necessary. If successful, it will output `realPath =` in the INFO log.\nPurpose: To route other inbound WebSocket traffic or HTTP disguised traffic, without additional processing, purely forwarding traffic, and theoretically better performance than Nginx.\n\nNote: **The inbound where fallbacks is located must be TCP+TLS**. This is for routing to other WebSocket inbound, while the inbound being routed doesn't need to configure TLS.\n\n",
          "markdownDescription": "\nAttempt to match the first packet HTTP PATH, where an empty value matches any PATH and a default value is empty. If non-empty, it must start with `/`, and h2c is not supported.\n\nSmart: VLESS will only attempt to check the PATH (no more than 55 bytes; the fastest algorithm that does not fully parse HTTP) when necessary. If successful, it will output `realPath =` in the INFO log.\nPurpose: To route other inbound WebSocket traffic or HTTP disguised traffic, without additional processing, purely forwarding traffic, and theoretically better performance than Nginx.\n\nNote: **The inbound where fallbacks is located must be TCP+TLS**. This is for routing to other WebSocket inbound, while the inbound being routed doesn't need to configure TLS.\n\n",
          "type": "string"
        },
        "dest": {
          "name": "dest",
          "description": "\nDetermines the destination of decrypted TLS TCP traffic, which currently supports two types of addresses: (this field is required, otherwise it cannot be started)\n\n1. TCP, in the format of `\"addr:port\"`, where addr supports IPv4, domain names, and IPv6. If a domain name is entered, a direct TCP connection will be made (rather than using the built-in DNS resolver).\n2. Unix domain socket, in the format of an absolute path, such as `\"/dev/shm/domain.socket\"`, which can be prefixed with `@` to represent [abstract](https://www.man7.org/linux/man-pages/man7/unix.7.html), and `@@` to represent padded abstract.\n\nIf only the port is specified, both numbers and strings are accepted, such as `80` or `\"80\"`. This usually points to a plaintext HTTP service (and the addr will be filled in as `\"127.0.0.1\"`).\n\n",
          "markdownDescription": "\nDetermines the destination of decrypted TLS TCP traffic, which currently supports two types of addresses: (this field is required, otherwise it cannot be started)\n\n1. TCP, in the format of `\"addr:port\"`, where addr supports IPv4, domain names, and IPv6. If a domain name is entered, a direct TCP connection will be made (rather than using the built-in DNS resolver).\n2. Unix domain socket, in the format of an absolute path, such as `\"/dev/shm/domain.socket\"`, which can be prefixed with `@` to represent [abstract](https://www.man7.org/linux/man-pages/man7/unix.7.html), and `@@` to represent padded abstract.\n\nIf only the port is specified, both numbers and strings are accepted, such as `80` or `\"80\"`. This usually points to a plaintext HTTP service (and the addr will be filled in as `\"127.0.0.1\"`).\n\n",
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            }
          ]
        },
        "xver": {
          "name": "xver",
          "description": "\nSends the [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) protocol, which is used to transmit the real source IP and port of the request. The version can be set to `1` or `2`, with a default value of `0`, which means no PROXY protocol is sent. Version `1` is recommended if needed.\n\nCurrently, versions `1` and `2` have the same functionality but different structures, where version `1` is printable while version 2 is `binary`. Xray's `TCP` and `WebSocket` inbound already support receiving the PROXY protocol.\n\n::: warning\nIf you are [configuring Nginx to receive the PROXY protocol](https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol/#configuring-nginx-to-accept-the-proxy-protocol), you need to not only set `proxy_protocol`, but also `set_real_ip_from` to avoid potential issues.\n:::\n\n",
          "markdownDescription": "\nSends the [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) protocol, which is used to transmit the real source IP and port of the request. The version can be set to `1` or `2`, with a default value of `0`, which means no PROXY protocol is sent. Version `1` is recommended if needed.\n\nCurrently, versions `1` and `2` have the same functionality but different structures, where version `1` is printable while version 2 is `binary`. Xray's `TCP` and `WebSocket` inbound already support receiving the PROXY protocol.\n\n::: warning\nIf you are [configuring Nginx to receive the PROXY protocol](https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol/#configuring-nginx-to-accept-the-proxy-protocol), you need to not only set `proxy_protocol`, but also `set_real_ip_from` to avoid potential issues.\n:::\n\n",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "Additional Information": {
      "title": "Additional Information",
      "description": "\n- Matches the most precise sub-element, regardless of the order of arrangement of the sub-elements. If several sub-elements have the same `alpn` and `path` configurations, the last one specified will be used.\n- Fallback routing is performed at the decrypted TCP layer rather than the HTTP layer, and the first packet PATH is only checked when necessary.\n- You can learn more about tips and experiences in using Fallbacks by visiting\n  - [An Analysis of Fallback Functionality.](../../document/level-1/fallbacks-lv1)\n\n",
      "markdownDescription": "\n- Matches the most precise sub-element, regardless of the order of arrangement of the sub-elements. If several sub-elements have the same `alpn` and `path` configurations, the last one specified will be used.\n- Fallback routing is performed at the decrypted TCP layer rather than the HTTP layer, and the first packet PATH is only checked when necessary.\n- You can learn more about tips and experiences in using Fallbacks by visiting\n  - [An Analysis of Fallback Functionality.](../../document/level-1/fallbacks-lv1)\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Fallbacks design theory <Badge text=\"WIP\" type=\"warning\"/>": {
      "title": "Fallbacks design theory <Badge text=\"WIP\" type=\"warning\"/>",
      "description": "# Deep analysis of XTLS\n\n> **\"XTLS is the original black technology of Xray, and also the core driving force that makes Xray's performance far superior.\"**\n\n<Badge text=\"WIP\" type=\"warning\"/>\n# Environment Variables\n\nXray provides the following environment variables for modifying some of its underlying configurations.\n\n",
      "markdownDescription": "# Deep analysis of XTLS\n\n> **\"XTLS is the original black technology of Xray, and also the core driving force that makes Xray's performance far superior.\"**\n\n<Badge text=\"WIP\" type=\"warning\"/>\n# Environment Variables\n\nXray provides the following environment variables for modifying some of its underlying configurations.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Xray Asset Location": {
      "title": "Xray Asset Location",
      "description": "\n- Name\uff1a`xray.location.asset` or `XRAY_LOCATION_ASSET`\u3002\n- Default value\uff1aspecified [FHS](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) directory or the same path as the Xray file.\n\nThis environment variable specifies a folder location that should contain the `geoip.dat` and `geosite.dat` files. If no variable value is specified, the program will search for resource files in the following order:\n\n```\n./\n/usr/local/share/xray\n/usr/share/xray\n```\n\n",
      "markdownDescription": "\n- Name\uff1a`xray.location.asset` or `XRAY_LOCATION_ASSET`\u3002\n- Default value\uff1aspecified [FHS](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) directory or the same path as the Xray file.\n\nThis environment variable specifies a folder location that should contain the `geoip.dat` and `geosite.dat` files. If no variable value is specified, the program will search for resource files in the following order:\n\n```\n./\n/usr/local/share/xray\n/usr/share/xray\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Configuration File Location": {
      "title": "Configuration File Location",
      "description": "\n- Name\uff1a`xray.location.config` or `XRAY_LOCATION_CONFIG`\u3002\n- Default value: Same path as the Xray file.\n\nThis environment variable specifies a folder location that should contain the `config.json` file.\n\n",
      "markdownDescription": "\n- Name\uff1a`xray.location.config` or `XRAY_LOCATION_CONFIG`\u3002\n- Default value: Same path as the Xray file.\n\nThis environment variable specifies a folder location that should contain the `config.json` file.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Multiple Configuration Directories": {
      "title": "Multiple Configuration Directories",
      "description": "\n- Name\uff1a`xray.location.confdir` or `XRAY_LOCATION_CONFDIR`\u3002\n- Default value\uff1a`\"\"`\u3002\n\nThe `.json` files in this directory will be read in alphabetical order by filename and used as options for multiple configurations.\n# Browser Dialer\n\n<Badge text=\"BETA\" type=\"warning\"/> <Badge text=\"v1.4.1+\" type=\"warning\"/>\n\n",
      "markdownDescription": "\n- Name\uff1a`xray.location.confdir` or `XRAY_LOCATION_CONFDIR`\u3002\n- Default value\uff1a`\"\"`\u3002\n\nThe `.json` files in this directory will be read in alphabetical order by filename and used as options for multiple configurations.\n# Browser Dialer\n\n<Badge text=\"BETA\" type=\"warning\"/> <Badge text=\"v1.4.1+\" type=\"warning\"/>\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Background": {
      "title": "Background",
      "description": "\nXray generally uses uTLS to mimic the behavior of popular browsers, and it can be controlled through the `fingerprint` setting. However, the fingerprints produced by uTLS are an imperfect replica of the real thing, and because uTLS is a popular library, they may be targeted themselves.\n\nSo [the idea of browser dialer](https://github.com/v2ray/discussion/issues/754#issuecomment-647934994) is that Xray uses a real browser to establish TLS connections. The way this works is that Xray hosts a small website on `localhost:8080`, the user opens this website in a browser of their choice, and JavaScript on that page will act as Xray's networking stack (HTTP client, TLS client).\n\nThe TLS fingerprinting behavior is perfect this way, and so it may be possible to revive servers that open fine as websites in the browser, but do not connect using any proxying software.\n\nHowever, there are many drawbacks:\n\n* The user has to launch a browser next to the Xray client just for opening the proxy connection.\n* The browser dialer must not be tunneled through the proxy itself, otherwise there is a loop. TUN users should be cautious.\n* The browser can only speak standard HTTP, which means that only [WebSocket](../../transports/websocket.md) and [XHTTP](../../transports/splithttp.md) are supported\n* [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) needs to be considered when making requests from one website (`localhost:8080`) to another (`proxy.example.com:443`)\n* The browser tunnels your traffic using JavaScript, so there is a significant performance penalty (or, battery drain)\n* The configuration to be used with browser dialer cannot use custom SNI or host headers. `SNI == host == address`. Custom HTTP headers and `tlsSettings` are ignored entirely.\n\n",
      "markdownDescription": "\nXray generally uses uTLS to mimic the behavior of popular browsers, and it can be controlled through the `fingerprint` setting. However, the fingerprints produced by uTLS are an imperfect replica of the real thing, and because uTLS is a popular library, they may be targeted themselves.\n\nSo [the idea of browser dialer](https://github.com/v2ray/discussion/issues/754#issuecomment-647934994) is that Xray uses a real browser to establish TLS connections. The way this works is that Xray hosts a small website on `localhost:8080`, the user opens this website in a browser of their choice, and JavaScript on that page will act as Xray's networking stack (HTTP client, TLS client).\n\nThe TLS fingerprinting behavior is perfect this way, and so it may be possible to revive servers that open fine as websites in the browser, but do not connect using any proxying software.\n\nHowever, there are many drawbacks:\n\n* The user has to launch a browser next to the Xray client just for opening the proxy connection.\n* The browser dialer must not be tunneled through the proxy itself, otherwise there is a loop. TUN users should be cautious.\n* The browser can only speak standard HTTP, which means that only [WebSocket](../../transports/websocket.md) and [XHTTP](../../transports/splithttp.md) are supported\n* [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) needs to be considered when making requests from one website (`localhost:8080`) to another (`proxy.example.com:443`)\n* The browser tunnels your traffic using JavaScript, so there is a significant performance penalty (or, battery drain)\n* The configuration to be used with browser dialer cannot use custom SNI or host headers. `SNI == host == address`. Custom HTTP headers and `tlsSettings` are ignored entirely.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Configuration": {
      "title": "Configuration",
      "description": "\n1. Prepare a usable WebSocket or XHTTP configuration. Be aware of the above restrictions.\n2. Launch Xray with `XRAY_BROWSER_DIALER=127.0.0.1:8080`. On Windows, this can be done as `set XRAY_BROWSER_DIALER=...` and then launching the core from the console, on Linux the core can be launched as `XRAY_BROWSER_DIALER=127.0.0.1:8080 ./xray -c config.json`.\n3. Open a browser that is not tunneled through the proxy, or modify the config's routing such that the Xray server's domain goes to `freedom` directly from the client. Browse to `localhost:8080`, and open the developer console with `F12` to monitor for errors.\n4. For better performance and to bypass arbitrary connection limits enforced by the browser, it is recommended to enable `Mux.Cool`.\n\n",
      "markdownDescription": "\n1. Prepare a usable WebSocket or XHTTP configuration. Be aware of the above restrictions.\n2. Launch Xray with `XRAY_BROWSER_DIALER=127.0.0.1:8080`. On Windows, this can be done as `set XRAY_BROWSER_DIALER=...` and then launching the core from the console, on Linux the core can be launched as `XRAY_BROWSER_DIALER=127.0.0.1:8080 ./xray -c config.json`.\n3. Open a browser that is not tunneled through the proxy, or modify the config's routing such that the Xray server's domain goes to `freedom` directly from the client. Browse to `localhost:8080`, and open the developer console with `F12` to monitor for errors.\n4. For better performance and to bypass arbitrary connection limits enforced by the browser, it is recommended to enable `Mux.Cool`.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Inner workings": {
      "title": "Inner workings",
      "description": "\n- Xray listens on `http://127.0.0.1:8080`, and the browser accesses `http://127.0.0.1:8080` to load the `JS` in the webpage.\n- The `JS` actively establishes a WebSocket connection to `http://127.0.0.1:8080`. Xray will use this connection to send instructions, but for now it goes into a connection pool (implemented as Go channel).\n- When a connection needs to be established, Xray receives an available connection from the pool and sends the protocol name, target URL and optional early data.\n- Once the `JS` successfully connects to the target, it informs Xray and continues to use this conn to bi-directionally forward data.\n- After the connection to the server is closed, the connection to localhost is also closed, but the JS ensures that there is always at least one idle connection available.\n\n",
      "markdownDescription": "\n- Xray listens on `http://127.0.0.1:8080`, and the browser accesses `http://127.0.0.1:8080` to load the `JS` in the webpage.\n- The `JS` actively establishes a WebSocket connection to `http://127.0.0.1:8080`. Xray will use this connection to send instructions, but for now it goes into a connection pool (implemented as Go channel).\n- When a connection needs to be established, Xray receives an available connection from the pool and sends the protocol name, target URL and optional early data.\n- Once the `JS` successfully connects to the target, it informs Xray and continues to use this conn to bi-directionally forward data.\n- After the connection to the server is closed, the connection to localhost is also closed, but the JS ensures that there is always at least one idle connection available.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "WebSocket": {
      "title": "WebSocket",
      "description": "\n<Badge text=\"v1.4.1+\" type=\"warning\"/>\n\nAccording to the browser's needs, the early data mechanism has been adjusted as follows:\n\n- The server response header will contain the requested `Sec-WebSocket-Protocol`, which also initially obfuscates the length characteristic of the WSS handshake response.\n- The encoding used for early data for browsers is `base64.RawURLEncoding` instead of `StdEncoding`, and the server has made it compatible.\n- In addition, due to [Xray-core#375](https://github.com/XTLS/Xray-core/pull/375) recommendations for `?ed=2048`, this PR also increased server `MaxHeaderBytes` by 4096. ~~(Although it seems like it would work without modification.)~~\n\n",
      "markdownDescription": "\n<Badge text=\"v1.4.1+\" type=\"warning\"/>\n\nAccording to the browser's needs, the early data mechanism has been adjusted as follows:\n\n- The server response header will contain the requested `Sec-WebSocket-Protocol`, which also initially obfuscates the length characteristic of the WSS handshake response.\n- The encoding used for early data for browsers is `base64.RawURLEncoding` instead of `StdEncoding`, and the server has made it compatible.\n- In addition, due to [Xray-core#375](https://github.com/XTLS/Xray-core/pull/375) recommendations for `?ed=2048`, this PR also increased server `MaxHeaderBytes` by 4096. ~~(Although it seems like it would work without modification.)~~\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "XHTTP": {
      "title": "XHTTP",
      "description": "\n<Badge text=\"v1.8.19+\" type=\"warning\"/>\n\nXHTTP supports QUIC, but the browser's own QUIC stack may be used as well. In Chrome this can be done through `chrome://flags`, in other browsers it may already be enabled or need a different flag.\n\nIn general, `tlsSettings` are completely ignored when Browser Dialer is used. Xray does not have any control over which HTTP version the browser selects.\n# Multi-file configuration\n\nThe Xray program supports the use of multiple configuration files.\n\nThe main purpose of using multiple configuration files is to distribute different module configurations, making it easier to manage and maintain.\n\nThis feature is mainly designed to enrich the Xray ecosystem. For example, for GUI-based clients, only fixed functions such as node selection are usually implemented, and complex configurations are difficult to implement graphically. By leaving a custom `confdir` configuration directory for complex functions, server deployment scripts can simply add files to `confdir` to implement multiple protocol configurations.\n\n",
      "markdownDescription": "\n<Badge text=\"v1.8.19+\" type=\"warning\"/>\n\nXHTTP supports QUIC, but the browser's own QUIC stack may be used as well. In Chrome this can be done through `chrome://flags`, in other browsers it may already be enabled or need a different flag.\n\nIn general, `tlsSettings` are completely ignored when Browser Dialer is used. Xray does not have any control over which HTTP version the browser selects.\n# Multi-file configuration\n\nThe Xray program supports the use of multiple configuration files.\n\nThe main purpose of using multiple configuration files is to distribute different module configurations, making it easier to manage and maintain.\n\nThis feature is mainly designed to enrich the Xray ecosystem. For example, for GUI-based clients, only fixed functions such as node selection are usually implemented, and complex configurations are difficult to implement graphically. By leaving a custom `confdir` configuration directory for complex functions, server deployment scripts can simply add files to `confdir` to implement multiple protocol configurations.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Multi-file startup": {
      "title": "Multi-file startup",
      "description": "\n::: tip\nThe startup information will indicate each configuration file being read in sequence. Please pay attention to whether the startup information matches the order you have set.\n:::\n\n```shell\n$ xray run -confdir /etc/xray/confs\n```\n\nYou can also use `Xray.location.confdir` or `Xray_LOCATION_CONFDIR` to specify the `confdir`.\n\nThe `-confdir` parameter takes precedence over the environment variable. If a valid directory is specified by the parameter, the path in the environment variable will not be read.\n\n",
      "markdownDescription": "\n::: tip\nThe startup information will indicate each configuration file being read in sequence. Please pay attention to whether the startup information matches the order you have set.\n:::\n\n```shell\n$ xray run -confdir /etc/xray/confs\n```\n\nYou can also use `Xray.location.confdir` or `Xray_LOCATION_CONFDIR` to specify the `confdir`.\n\nThe `-confdir` parameter takes precedence over the environment variable. If a valid directory is specified by the parameter, the path in the environment variable will not be read.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Rule Explanation": {
      "title": "Rule Explanation",
      "description": "\n",
      "markdownDescription": "\n",
      "properties": {},
      "additionalProperties": true
    },
    "Normal Objects\uff08`{}`\uff09": {
      "title": "Normal Objects\uff08`{}`\uff09",
      "description": "\n**In the top-level object of `JSON`, the latter overrides or supplements the former.**\n\nFor example\uff1a\n\n- base.json\n\n```json\n{\n  \"log\": {},\n  \"api\": {},\n  \"dns\": {},\n  \"stats\": {},\n  \"policy\": {},\n  \"transport\": {},\n  \"routing\": {},\n  \"inbounds\": []\n}\n```\n\n- outbounds.json\n\n```json\n{\n  \"outbounds\": []\n}\n```\n\nWhen starting Xray with multiple configurations, use the following command:\n\n```bash\n$ xray run -confdir /etc/xray/confs\n```\n\nThese two configuration files are equivalent to a single combined configuration. If you need to modify the outbound nodes, simply modify the content of `outbounds.json`.\n\nIf you need to change the log level for debugging purposes, there is no need to modify `base.json`. You can add an additional configuration file:\n\n- debuglog.json\n\n```json\n{\n  \"log\": {\n    \"loglevel\": \"debug\"\n  }\n}\n```\n\nStart the program in sequence after `base.json` to output logs at the debug level.\n\n",
      "markdownDescription": "\n**In the top-level object of `JSON`, the latter overrides or supplements the former.**\n\nFor example\uff1a\n\n- base.json\n\n```json\n{\n  \"log\": {},\n  \"api\": {},\n  \"dns\": {},\n  \"stats\": {},\n  \"policy\": {},\n  \"transport\": {},\n  \"routing\": {},\n  \"inbounds\": []\n}\n```\n\n- outbounds.json\n\n```json\n{\n  \"outbounds\": []\n}\n```\n\nWhen starting Xray with multiple configurations, use the following command:\n\n```bash\n$ xray run -confdir /etc/xray/confs\n```\n\nThese two configuration files are equivalent to a single combined configuration. If you need to modify the outbound nodes, simply modify the content of `outbounds.json`.\n\nIf you need to change the log level for debugging purposes, there is no need to modify `base.json`. You can add an additional configuration file:\n\n- debuglog.json\n\n```json\n{\n  \"log\": {\n    \"loglevel\": \"debug\"\n  }\n}\n```\n\nStart the program in sequence after `base.json` to output logs at the debug level.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Arrays\uff08`[]`\uff09": {
      "title": "Arrays\uff08`[]`\uff09",
      "description": "\nIn the JSON configuration, `inbounds` and `outbounds` are array structures with special rules:\n\n- When there are two or more elements in the array, the latter overrides the former for `inbounds`/`outbounds`.\n- When there is only one element in the array, it searches for an existing element with the same `tag` to override. If it cannot be found:\n  - For `inbounds`, add it to the end (the order of elements in `inbounds` is irrelevant).\n  - For `outbounds`, add it to the beginning (the default first-choice outbound). However, if the filename contains \"tail\" (case-insensitive), add it to the end.\n\nWith multiple configurations, it is easy to add inbound for different protocols to the original configuration without modifying the original configuration.\n\nThe following example is not a valid configuration but is provided to demonstrate the above rules.\n\n- 000.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 1234\n    }\n  ]\n}\n```\n\n- 001.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"http\",\n      \"tag\": \"http\"\n    }\n  ]\n}\n```\n\n- 002.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 4321\n    }\n  ]\n}\n```\n\nThe three configurations will be combined into:\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 4321 // < 002\u987a\u5e8f\u5728000\u540e\uff0c\u56e0\u6b64\u8986\u76d6tag\u4e3asocks\u7684inbound\u7aef\u53e3\u4e3a4321\n    },\n    {\n      \"protocol\": \"http\",\n      \"tag\": \"http\"\n    }\n  ]\n}\n```\n\n",
      "markdownDescription": "\nIn the JSON configuration, `inbounds` and `outbounds` are array structures with special rules:\n\n- When there are two or more elements in the array, the latter overrides the former for `inbounds`/`outbounds`.\n- When there is only one element in the array, it searches for an existing element with the same `tag` to override. If it cannot be found:\n  - For `inbounds`, add it to the end (the order of elements in `inbounds` is irrelevant).\n  - For `outbounds`, add it to the beginning (the default first-choice outbound). However, if the filename contains \"tail\" (case-insensitive), add it to the end.\n\nWith multiple configurations, it is easy to add inbound for different protocols to the original configuration without modifying the original configuration.\n\nThe following example is not a valid configuration but is provided to demonstrate the above rules.\n\n- 000.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 1234\n    }\n  ]\n}\n```\n\n- 001.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"http\",\n      \"tag\": \"http\"\n    }\n  ]\n}\n```\n\n- 002.json\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 4321\n    }\n  ]\n}\n```\n\nThe three configurations will be combined into:\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"protocol\": \"socks\",\n      \"tag\": \"socks\",\n      \"port\": 4321 // < 002\u987a\u5e8f\u5728000\u540e\uff0c\u56e0\u6b64\u8986\u76d6tag\u4e3asocks\u7684inbound\u7aef\u53e3\u4e3a4321\n    },\n    {\n      \"protocol\": \"http\",\n      \"tag\": \"http\"\n    }\n  ]\n}\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Recommended Multi-file List": {
      "title": "Recommended Multi-file List",
      "description": "\nExecute\uff1a\n\n```bash\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo '{}' > \"/etc/Xray/$BASE.json\"; done\n```\n\nor\n\n```bash\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo '{}' > \"/usr/local/etc/Xray/$BASE.json\"; done\n```\n\n```bash\n.\n\u251c\u2500\u2500 00_log.json\n\u251c\u2500\u2500 01_api.json\n\u251c\u2500\u2500 02_dns.json\n\u251c\u2500\u2500 03_routing.json\n\u251c\u2500\u2500 04_policy.json\n\u251c\u2500\u2500 05_inbounds.json\n\u251c\u2500\u2500 06_outbounds.json\n\u251c\u2500\u2500 07_transport.json\n\u251c\u2500\u2500 08_stats.json\n\u2514\u2500\u2500 09_reverse.json\n\n0 directories, 10 files\n```\n# Reverse Proxy\n\nA reverse proxy forwards traffic from a server to a client, which is known as reverse traffic forwarding.\n\nHere's how a reverse proxy generally works:\n\n- Suppose there is a web server in host A, which does not have a public IP address and cannot be accessed directly on the Internet. There is another host B that can be accessed via the public network. Now we need to use B as the entry point to forward traffic from B to A.\n- Configure Xray in host A as a `bridge`, and also configure Xray in B as a `portal`.\n- `Bridge` will actively establish a connection to `portal`, and the destination address of this connection can be set by itself. `Portal` will receive two types of connections: one is the connection sent by `bridge`, and the other is the connection sent by public network users. `Portal` will automatically merge the two types of connections. So `bridge` can receive public network traffic.\n- After receiving the public network traffic, `bridge` will forward it unchanged to the web server in host A. Of course, this step requires the cooperation of routing.\n- `Bridge` will dynamically load balance according to the size of the traffic.\n\n::: tip\nReverse proxy has Mux enabled by default, so please do not enable Mux again on the outbound it uses.\n:::\n\n::: warning\nThe reverse proxy function is still in the testing phase and may have some issues.\n:::\n\n",
      "markdownDescription": "\nExecute\uff1a\n\n```bash\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo '{}' > \"/etc/Xray/$BASE.json\"; done\n```\n\nor\n\n```bash\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo '{}' > \"/usr/local/etc/Xray/$BASE.json\"; done\n```\n\n```bash\n.\n\u251c\u2500\u2500 00_log.json\n\u251c\u2500\u2500 01_api.json\n\u251c\u2500\u2500 02_dns.json\n\u251c\u2500\u2500 03_routing.json\n\u251c\u2500\u2500 04_policy.json\n\u251c\u2500\u2500 05_inbounds.json\n\u251c\u2500\u2500 06_outbounds.json\n\u251c\u2500\u2500 07_transport.json\n\u251c\u2500\u2500 08_stats.json\n\u2514\u2500\u2500 09_reverse.json\n\n0 directories, 10 files\n```\n# Reverse Proxy\n\nA reverse proxy forwards traffic from a server to a client, which is known as reverse traffic forwarding.\n\nHere's how a reverse proxy generally works:\n\n- Suppose there is a web server in host A, which does not have a public IP address and cannot be accessed directly on the Internet. There is another host B that can be accessed via the public network. Now we need to use B as the entry point to forward traffic from B to A.\n- Configure Xray in host A as a `bridge`, and also configure Xray in B as a `portal`.\n- `Bridge` will actively establish a connection to `portal`, and the destination address of this connection can be set by itself. `Portal` will receive two types of connections: one is the connection sent by `bridge`, and the other is the connection sent by public network users. `Portal` will automatically merge the two types of connections. So `bridge` can receive public network traffic.\n- After receiving the public network traffic, `bridge` will forward it unchanged to the web server in host A. Of course, this step requires the cooperation of routing.\n- `Bridge` will dynamically load balance according to the size of the traffic.\n\n::: tip\nReverse proxy has Mux enabled by default, so please do not enable Mux again on the outbound it uses.\n:::\n\n::: warning\nThe reverse proxy function is still in the testing phase and may have some issues.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "ReverseObject": {
      "title": "ReverseObject",
      "description": "\n`ReverseObject` corresponds to the `reverse` field in the configuration file.\n\n```json\n{\n  \"reverse\": {\n    \"bridges\": [\n      {\n        \"tag\": \"bridge\",\n        \"domain\": \"test.xray.com\"\n      }\n    ],\n    \"portals\": [\n      {\n        \"tag\": \"portal\",\n        \"domain\": \"test.xray.com\"\n      }\n    ]\n  }\n}\n```\n\n",
      "markdownDescription": "\n`ReverseObject` corresponds to the `reverse` field in the configuration file.\n\n```json\n{\n  \"reverse\": {\n    \"bridges\": [\n      {\n        \"tag\": \"bridge\",\n        \"domain\": \"test.xray.com\"\n      }\n    ],\n    \"portals\": [\n      {\n        \"tag\": \"portal\",\n        \"domain\": \"test.xray.com\"\n      }\n    ]\n  }\n}\n```\n\n",
      "properties": {
        "bridges": {
          "name": "bridges",
          "description": "\nAn array in which each item represents a `bridge`. The configuration of each `bridge` is a [BridgeObject](#bridgeobject).\n\n",
          "markdownDescription": "\nAn array in which each item represents a `bridge`. The configuration of each `bridge` is a [BridgeObject](#bridgeobject).\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/BridgeObject"
          }
        },
        "portals": {
          "name": "portals",
          "description": "\nAn array in which each item represents a `portal`. The configuration of each `portal` is a [PortalObject](#bridgeobject).\n\n",
          "markdownDescription": "\nAn array in which each item represents a `portal`. The configuration of each `portal` is a [PortalObject](#bridgeobject).\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PortalObject"
          }
        }
      },
      "additionalProperties": false
    },
    "BridgeObject": {
      "title": "BridgeObject",
      "description": "\n```json\n{\n  \"tag\": \"bridge\",\n  \"domain\": \"test.xray.com\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"tag\": \"bridge\",\n  \"domain\": \"test.xray.com\"\n}\n```\n\n",
      "properties": {
        "tag": {
          "name": "tag",
          "description": "\nAll connections initiated by `bridge` will have this tag. It can be used to identify the connections in [routing configuration](./routing.md).\n\n",
          "markdownDescription": "\nAll connections initiated by `bridge` will have this tag. It can be used to identify the connections in [routing configuration](./routing.md).\n\n",
          "type": "string"
        },
        "domain": {
          "name": "domain",
          "description": "\nSpecifies a domain name that will be used by `bridge` to send connections to `portal`. This domain name is only used for communication between `bridge` and `portal`, and does not need to actually exist.\n\n",
          "markdownDescription": "\nSpecifies a domain name that will be used by `bridge` to send connections to `portal`. This domain name is only used for communication between `bridge` and `portal`, and does not need to actually exist.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PortalObject": {
      "title": "PortalObject",
      "description": "\n```json\n{\n  \"tag\": \"portal\",\n  \"domain\": \"test.xray.com\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"tag\": \"portal\",\n  \"domain\": \"test.xray.com\"\n}\n```\n\n",
      "properties": {
        "tag": {
          "name": "tag",
          "description": "\nThe identifier for the `portal`. Use `outboundTag` in [routing configuration](./routing.md) to forward traffic to this `portal`.\n\n",
          "markdownDescription": "\nThe identifier for the `portal`. Use `outboundTag` in [routing configuration](./routing.md) to forward traffic to this `portal`.\n\n",
          "type": "string"
        },
        "domain": {
          "name": "domain",
          "description": "\nA domain name. When the `portal` receives traffic, if the destination domain of the traffic is this domain, the `portal` assumes that the current connection is a communication connection sent by the `bridge`. Other traffic will be considered as traffic that needs to be forwarded. The work of the `portal` is to identify and splice these two types of connections.\n\n::: tip\nAn Xray can act as a `bridge`, a `portal`, or both at the same time, depending on the needs of different scenarios.\n:::\n\n",
          "markdownDescription": "\nA domain name. When the `portal` receives traffic, if the destination domain of the traffic is this domain, the `portal` assumes that the current connection is a communication connection sent by the `bridge`. Other traffic will be considered as traffic that needs to be forwarded. The work of the `portal` is to identify and splice these two types of connections.\n\n::: tip\nAn Xray can act as a `bridge`, a `portal`, or both at the same time, depending on the needs of different scenarios.\n:::\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Complete Configuration Example": {
      "title": "Complete Configuration Example",
      "description": "\n:::\ntip During operation, it is recommended to enable `bridge` first, then enable `portal`.\n:::\n\n",
      "markdownDescription": "\n:::\ntip During operation, it is recommended to enable `bridge` first, then enable `portal`.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Bridge Configuration": {
      "title": "Bridge Configuration",
      "description": "\nA `bridge` usually requires two outbounds, one for connecting to the `portal`, and the other for sending actual traffic. That is, you need to use routing to distinguish between the two types of traffic.\n\nReverse proxy configuration:\n\n```json\n{\n  \"bridges\": [\n    {\n      \"tag\": \"bridge\",\n      \"domain\": \"test.xray.com\"\n    }\n  ]\n}\n```\n\noutbound:\n\n```json\n{\n  \"tag\": \"out\",\n  \"protocol\": \"freedom\",\n  \"settings\": {\n    \"redirect\": \"127.0.0.1:80\" // Forward all traffic to web server\n  }\n}\n```\n\n```json\n{\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"vnext\": [\n      {\n        \"address\": \"portal's IP address\",\n        \"port\": 1024,\n        \"users\": [\n          {\n            \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n          }\n        ]\n      }\n    ]\n  },\n  \"tag\": \"interconn\"\n}\n```\n\nRouting Configuration:\n\n```json\n{\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"domain\": [\"full:test.xray.com\"],\n      \"outboundTag\": \"interconn\"\n    },\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"outboundTag\": \"out\"\n    }\n  ]\n}\n```\n\n",
      "markdownDescription": "\nA `bridge` usually requires two outbounds, one for connecting to the `portal`, and the other for sending actual traffic. That is, you need to use routing to distinguish between the two types of traffic.\n\nReverse proxy configuration:\n\n```json\n{\n  \"bridges\": [\n    {\n      \"tag\": \"bridge\",\n      \"domain\": \"test.xray.com\"\n    }\n  ]\n}\n```\n\noutbound:\n\n```json\n{\n  \"tag\": \"out\",\n  \"protocol\": \"freedom\",\n  \"settings\": {\n    \"redirect\": \"127.0.0.1:80\" // Forward all traffic to web server\n  }\n}\n```\n\n```json\n{\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"vnext\": [\n      {\n        \"address\": \"portal's IP address\",\n        \"port\": 1024,\n        \"users\": [\n          {\n            \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n          }\n        ]\n      }\n    ]\n  },\n  \"tag\": \"interconn\"\n}\n```\n\nRouting Configuration:\n\n```json\n{\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"domain\": [\"full:test.xray.com\"],\n      \"outboundTag\": \"interconn\"\n    },\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"outboundTag\": \"out\"\n    }\n  ]\n}\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Portal Configuration": {
      "title": "Portal Configuration",
      "description": "\n`portal` usually requires two inbounds, one for receiving connections from `bridge`, and the other for receiving actual traffic. You also need to distinguish between these two types of traffic using routing.\n\nReverse proxy configuration:\n\n```json\n{\n  \"portals\": [\n    {\n      \"tag\": \"portal\",\n      \"domain\": \"test.xray.com\" // Must be the same as the bridge's configuration\n    }\n  ]\n}\n```\n\ninbound:\n\n```json\n{\n  \"tag\": \"external\",\n  \"port\": 80,\n  \"protocol\": \"dokodemo-door\",\n  \"settings\": {\n    \"address\": \"127.0.0.1\",\n    \"port\": 80,\n    \"network\": \"tcp\"\n  }\n}\n```\n\n```json\n{\n  \"port\": 1024,\n  \"tag\": \"interconn\",\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"clients\": [\n      {\n        \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n      }\n    ]\n  }\n}\n```\n\nRouting Configuration:\n\n```json\n{\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"external\"],\n      \"outboundTag\": \"portal\"\n    },\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"interconn\"],\n      \"outboundTag\": \"portal\"\n    }\n  ]\n}\n```\n# Routing\n\nThe routing module can send inbound data through different outbound connections according to different rules to achieve on-demand proxying.\n\nA common use case is to split domestic and foreign traffic. Xray can use its internal mechanisms to determine the traffic from different regions and then send them to different outbound proxies.\n\nFor a more detailed analysis of the routing function, please refer to [Routing Function Analysis](../document/level-1/routing-lv1-part1.md).\n\n",
      "markdownDescription": "\n`portal` usually requires two inbounds, one for receiving connections from `bridge`, and the other for receiving actual traffic. You also need to distinguish between these two types of traffic using routing.\n\nReverse proxy configuration:\n\n```json\n{\n  \"portals\": [\n    {\n      \"tag\": \"portal\",\n      \"domain\": \"test.xray.com\" // Must be the same as the bridge's configuration\n    }\n  ]\n}\n```\n\ninbound:\n\n```json\n{\n  \"tag\": \"external\",\n  \"port\": 80,\n  \"protocol\": \"dokodemo-door\",\n  \"settings\": {\n    \"address\": \"127.0.0.1\",\n    \"port\": 80,\n    \"network\": \"tcp\"\n  }\n}\n```\n\n```json\n{\n  \"port\": 1024,\n  \"tag\": \"interconn\",\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"clients\": [\n      {\n        \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n      }\n    ]\n  }\n}\n```\n\nRouting Configuration:\n\n```json\n{\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"external\"],\n      \"outboundTag\": \"portal\"\n    },\n    {\n      \"type\": \"field\",\n      \"inboundTag\": [\"interconn\"],\n      \"outboundTag\": \"portal\"\n    }\n  ]\n}\n```\n# Routing\n\nThe routing module can send inbound data through different outbound connections according to different rules to achieve on-demand proxying.\n\nA common use case is to split domestic and foreign traffic. Xray can use its internal mechanisms to determine the traffic from different regions and then send them to different outbound proxies.\n\nFor a more detailed analysis of the routing function, please refer to [Routing Function Analysis](../document/level-1/routing-lv1-part1.md).\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "RoutingObject": {
      "title": "RoutingObject",
      "description": "\n`RoutingObject` corresponds to the `routing` item in the configuration file.\n\n```json\n{\n  \"routing\": {\n    \"domainStrategy\": \"AsIs\",\n    \"domainMatcher\": \"hybrid\",\n    \"rules\": [],\n    \"balancers\": []\n  }\n}\n```\n\n",
      "markdownDescription": "\n`RoutingObject` corresponds to the `routing` item in the configuration file.\n\n```json\n{\n  \"routing\": {\n    \"domainStrategy\": \"AsIs\",\n    \"domainMatcher\": \"hybrid\",\n    \"rules\": [],\n    \"balancers\": []\n  }\n}\n```\n\n",
      "properties": {
        "domainStrategy": {
          "name": "domainStrategy",
          "description": "\nThe domain name resolution strategy, which uses different strategies based on different settings.\n\n- `\"AsIs\"`: Use only the domain name for routing selection. Default value.\n\n- `\"IPIfNonMatch\"`: If the domain name does not match any rule, resolve the domain name into an IP address (A record or AAAA record) and match it again;\n\n  - When a domain name has multiple A records, it will try to match all A records until one of them matches a rule;\n  - The resolved IP only works for routing selection, and the original domain name is still used in the forwarded packets;\n\n- `\"IPOnDemand\"`: If any IP-based rules are encountered during matching, immediately resolve the domain name into an IP address for matching;\n\n",
          "markdownDescription": "\nThe domain name resolution strategy, which uses different strategies based on different settings.\n\n- `\"AsIs\"`: Use only the domain name for routing selection. Default value.\n\n- `\"IPIfNonMatch\"`: If the domain name does not match any rule, resolve the domain name into an IP address (A record or AAAA record) and match it again;\n\n  - When a domain name has multiple A records, it will try to match all A records until one of them matches a rule;\n  - The resolved IP only works for routing selection, and the original domain name is still used in the forwarded packets;\n\n- `\"IPOnDemand\"`: If any IP-based rules are encountered during matching, immediately resolve the domain name into an IP address for matching;\n\n",
          "anyOf": [
            {
              "const": "AsIs"
            },
            {
              "const": "IPIfNonMatch"
            },
            {
              "const": "IPOnDemand"
            }
          ]
        },
        "domainMatcher": {
          "name": "domainMatcher",
          "description": "\nThe domain name matching algorithm, which uses different algorithms based on different settings. This option affects all `RuleObject` that do not have a separately specified matching algorithm.\n\n- `\"hybrid\"`: Use the new domain name matching algorithm, which is faster and takes up less space. Default value.\n- `\"linear\"`: Use the original domain name matching algorithm.\n\n",
          "markdownDescription": "\nThe domain name matching algorithm, which uses different algorithms based on different settings. This option affects all `RuleObject` that do not have a separately specified matching algorithm.\n\n- `\"hybrid\"`: Use the new domain name matching algorithm, which is faster and takes up less space. Default value.\n- `\"linear\"`: Use the original domain name matching algorithm.\n\n",
          "anyOf": [
            {
              "const": "hybrid"
            },
            {
              "const": "linear"
            }
          ]
        },
        "rules": {
          "name": "rules",
          "description": "\nAn array corresponding to a list of rules.\n\nFor each connection, the routing will judge these rules from top to bottom in order. When it encounters the first effective rule, it will forward the connection to the `outboundTag` or `balancerTag` specified by the rule.\n\n::: tip\nWhen no rules match, the traffic is sent out by the first outbound by default.\n:::\n\n",
          "markdownDescription": "\nAn array corresponding to a list of rules.\n\nFor each connection, the routing will judge these rules from top to bottom in order. When it encounters the first effective rule, it will forward the connection to the `outboundTag` or `balancerTag` specified by the rule.\n\n::: tip\nWhen no rules match, the traffic is sent out by the first outbound by default.\n:::\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleObject"
          }
        },
        "balancers": {
          "name": "balancers",
          "description": "\nAn array corresponding to a list of load balancers.\n\nWhen a rule points to a load balancer, Xray selects an outbound through this load balancer, and then it forwards the traffic through it.\n\n",
          "markdownDescription": "\nAn array corresponding to a list of load balancers.\n\nWhen a rule points to a load balancer, Xray selects an outbound through this load balancer, and then it forwards the traffic through it.\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/BalancerObject"
          }
        }
      },
      "additionalProperties": false
    },
    "RuleObject": {
      "title": "RuleObject",
      "description": "\n```json\n{\n  \"domainMatcher\": \"hybrid\",\n  \"type\": \"field\",\n  \"domain\": [\"baidu.com\", \"qq.com\", \"geosite:cn\"],\n  \"ip\": [\"0.0.0.0/8\", \"10.0.0.0/8\", \"fc00::/7\", \"fe80::/10\", \"geoip:cn\"],\n  \"port\": \"53,443,1000-2000\",\n  \"sourcePort\": \"53,443,1000-2000\",\n  \"network\": \"tcp\",\n  \"source\": [\"10.0.0.1\"],\n  \"user\": [\"love@xray.com\"],\n  \"inboundTag\": [\"tag-vmess\"],\n  \"protocol\": [\"http\", \"tls\", \"bittorrent\"],\n  \"attrs\": { \":method\": \"GET\" },\n  \"outboundTag\": \"direct\",\n  \"balancerTag\": \"balancer\"\n}\n```\n\n::: danger\nWhen multiple attributes are specified at the same time, these attributes need to be satisfied **simultaneously** in order for the current rule to take effect.\n:::\n\n",
      "markdownDescription": "\n```json\n{\n  \"domainMatcher\": \"hybrid\",\n  \"type\": \"field\",\n  \"domain\": [\"baidu.com\", \"qq.com\", \"geosite:cn\"],\n  \"ip\": [\"0.0.0.0/8\", \"10.0.0.0/8\", \"fc00::/7\", \"fe80::/10\", \"geoip:cn\"],\n  \"port\": \"53,443,1000-2000\",\n  \"sourcePort\": \"53,443,1000-2000\",\n  \"network\": \"tcp\",\n  \"source\": [\"10.0.0.1\"],\n  \"user\": [\"love@xray.com\"],\n  \"inboundTag\": [\"tag-vmess\"],\n  \"protocol\": [\"http\", \"tls\", \"bittorrent\"],\n  \"attrs\": { \":method\": \"GET\" },\n  \"outboundTag\": \"direct\",\n  \"balancerTag\": \"balancer\"\n}\n```\n\n::: danger\nWhen multiple attributes are specified at the same time, these attributes need to be satisfied **simultaneously** in order for the current rule to take effect.\n:::\n\n",
      "properties": {
        "domainMatcher": {
          "name": "domainMatcher",
          "description": "\nThe domain matching algorithm used varies depending on the settings. The option here takes priority over the `domainMatcher` configured in `RoutingObject`.\n\n- `\"hybrid\"`: uses a new domain matching algorithm that is faster and takes up less space. This is the default value.\n- `\"linear\"`: uses the original domain matching algorithm.\n\n",
          "markdownDescription": "\nThe domain matching algorithm used varies depending on the settings. The option here takes priority over the `domainMatcher` configured in `RoutingObject`.\n\n- `\"hybrid\"`: uses a new domain matching algorithm that is faster and takes up less space. This is the default value.\n- `\"linear\"`: uses the original domain matching algorithm.\n\n",
          "anyOf": [
            {
              "const": "hybrid"
            },
            {
              "const": "linear"
            }
          ]
        },
        "type": {
          "name": "type",
          "description": "\nCurrently, only the option `\"field\"` is supported.\n\n",
          "markdownDescription": "\nCurrently, only the option `\"field\"` is supported.\n\n",
          "const": "field"
        },
        "domain": {
          "name": "domain",
          "description": "\nAn array where each item is a domain match. There are several forms:\n\n- Plain string: If this string matches any part of the target domain, the rule takes effect. For example, \"sina.com\" can match \"sina.com\", \"sina.com.cn\", and \"www.sina.com\", but not \"sina.cn\".\n- Regular expression: Starts with `\"regexp:\"` followed by a regular expression. When this regular expression matches the target domain, the rule takes effect. For example, \"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com$\" matches \"www.google.com\" or \"fonts.googleapis.com\", but not \"google.com\".\n- Subdomain (recommended): Starts with `\"domain:\"` followed by a domain. When this domain is the target domain or a subdomain of the target domain, the rule takes effect. For example, \"domain:xray.com\" matches \"www.xray.com\" and \"xray.com\", but not \"wxray.com\".\n- Exact match: Starts with `\"full:\"` followed by a domain. When this domain is an exact match for the target domain, the rule takes effect. For example, \"full:xray.com\" matches \"xray.com\" but not \"www.xray.com\".\n- Predefined domain list: Starts with `\"geosite:\"` followed by a name such as `geosite:google` or `geosite:cn`. The names and domain lists are listed in [Predefined Domain List](#predefined-domain-list).\n- Load domains from a file: Formatted as `\"ext:file:tag\"`, where the file is stored in the [resource directory](./features/env.md#resource-file-path) and has the same format as `geosite.dat`. The tag must exist in the file.\n\n::: tip\n`\"ext:geoip.dat:cn\"` is equivalent to `\"geoip:cn\"`\n:::\n\n`ip`: [string]\n\nAn array where each item represents an IP range. This rule will take effect when the target IP matches any of the IP ranges in the array. There are several types of IP ranges:\n\n- IP: In the format of `\"127.0.0.1\"`.\n\n- [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing): In the format of `\"10.0.0.0/8\"`.\n\n- Predefined IP lists: These lists are included in every Xray installation package under the file name `geoip.dat`. They can be used in the format of `\"geoip:cn\"`, where `cn` is a two-letter country code. The prefix `geoip:`(all lowercase) must be used, and nearly all countries that have internet access are supported.\n\n  - Special value: `\"geoip:private\"`, which includes all private addresses, such as `127.0.0.1`.\n\n- Loading IP from a file: In the format of `\"ext:file:tag\"`, where `file` is the file name and `tag` is a label that must exist in the file. The prefix `ext:` (all lowercase) must be used, and the file should be located in the [resource directory](./features/env.md#resource-file-path) with the same format as `geoip.dat`.\n\n",
          "markdownDescription": "\nAn array where each item is a domain match. There are several forms:\n\n- Plain string: If this string matches any part of the target domain, the rule takes effect. For example, \"sina.com\" can match \"sina.com\", \"sina.com.cn\", and \"www.sina.com\", but not \"sina.cn\".\n- Regular expression: Starts with `\"regexp:\"` followed by a regular expression. When this regular expression matches the target domain, the rule takes effect. For example, \"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com$\" matches \"www.google.com\" or \"fonts.googleapis.com\", but not \"google.com\".\n- Subdomain (recommended): Starts with `\"domain:\"` followed by a domain. When this domain is the target domain or a subdomain of the target domain, the rule takes effect. For example, \"domain:xray.com\" matches \"www.xray.com\" and \"xray.com\", but not \"wxray.com\".\n- Exact match: Starts with `\"full:\"` followed by a domain. When this domain is an exact match for the target domain, the rule takes effect. For example, \"full:xray.com\" matches \"xray.com\" but not \"www.xray.com\".\n- Predefined domain list: Starts with `\"geosite:\"` followed by a name such as `geosite:google` or `geosite:cn`. The names and domain lists are listed in [Predefined Domain List](#predefined-domain-list).\n- Load domains from a file: Formatted as `\"ext:file:tag\"`, where the file is stored in the [resource directory](./features/env.md#resource-file-path) and has the same format as `geosite.dat`. The tag must exist in the file.\n\n::: tip\n`\"ext:geoip.dat:cn\"` is equivalent to `\"geoip:cn\"`\n:::\n\n`ip`: [string]\n\nAn array where each item represents an IP range. This rule will take effect when the target IP matches any of the IP ranges in the array. There are several types of IP ranges:\n\n- IP: In the format of `\"127.0.0.1\"`.\n\n- [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing): In the format of `\"10.0.0.0/8\"`.\n\n- Predefined IP lists: These lists are included in every Xray installation package under the file name `geoip.dat`. They can be used in the format of `\"geoip:cn\"`, where `cn` is a two-letter country code. The prefix `geoip:`(all lowercase) must be used, and nearly all countries that have internet access are supported.\n\n  - Special value: `\"geoip:private\"`, which includes all private addresses, such as `127.0.0.1`.\n\n- Loading IP from a file: In the format of `\"ext:file:tag\"`, where `file` is the file name and `tag` is a label that must exist in the file. The prefix `ext:` (all lowercase) must be used, and the file should be located in the [resource directory](./features/env.md#resource-file-path) with the same format as `geoip.dat`.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "port": {
          "name": "port",
          "description": "\nThe target port range, which can take on three forms:\n\n- `\"a-b\"`: `a` and `b` are both positive integers less than 65536. This range is a closed interval, and this rule will take effect when the target port falls within this range.\n- `a`: `a` is a positive integer less than 65536. This rule will take effect when the target port is `a`.\n- A mixture of the above two forms, separated by commas \",\". For example: `\"53,443,1000-2000\"`.\n\n",
          "markdownDescription": "\nThe target port range, which can take on three forms:\n\n- `\"a-b\"`: `a` and `b` are both positive integers less than 65536. This range is a closed interval, and this rule will take effect when the target port falls within this range.\n- `a`: `a` is a positive integer less than 65536. This rule will take effect when the target port is `a`.\n- A mixture of the above two forms, separated by commas \",\". For example: `\"53,443,1000-2000\"`.\n\n",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        },
        "sourcePort": {
          "name": "sourcePort",
          "description": "\nThe source port, which can take on three forms:\n\n- `\"a-b\"`: `a` and `b` are both positive integers less than 65536. This range is a closed interval, and this rule will take effect when the source port falls within this range.\n- `a`: `a` is a positive integer less than 65536. This rule will take effect when the source port is `a`.\n- A mixture of the above two forms, separated by commas \",\". For example: `\"53,443,1000-2000\"`.\n\n",
          "markdownDescription": "\nThe source port, which can take on three forms:\n\n- `\"a-b\"`: `a` and `b` are both positive integers less than 65536. This range is a closed interval, and this rule will take effect when the source port falls within this range.\n- `a`: `a` is a positive integer less than 65536. This rule will take effect when the source port is `a`.\n- A mixture of the above two forms, separated by commas \",\". For example: `\"53,443,1000-2000\"`.\n\n",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        },
        "network": {
          "name": "network",
          "description": "\nThis can be \"tcp\", \"udp\", or \"tcp,udp\". This rule will take effect when the connection method is the specified one.\n\n",
          "markdownDescription": "\nThis can be \"tcp\", \"udp\", or \"tcp,udp\". This rule will take effect when the connection method is the specified one.\n\n",
          "anyOf": [
            {
              "const": "tcp"
            },
            {
              "const": "udp"
            },
            {
              "const": "tcp,udp"
            }
          ]
        },
        "source": {
          "name": "source",
          "description": "\nAn array where each item represents an IP range in the format of IP, CIDR, GeoIP, or loading IP from a file. This rule will take effect when the source IP matches any of the IP ranges in the array.\n\n",
          "markdownDescription": "\nAn array where each item represents an IP range in the format of IP, CIDR, GeoIP, or loading IP from a file. This rule will take effect when the source IP matches any of the IP ranges in the array.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "user": {
          "name": "user",
          "description": "\nAn array where each item represents an email address. This rule will take effect when the source user matches any of the email addresses in the array.\n\n",
          "markdownDescription": "\nAn array where each item represents an email address. This rule will take effect when the source user matches any of the email addresses in the array.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "inboundTag": {
          "name": "inboundTag",
          "description": "\nAn array where each item represents an identifier. This rule will take effect when the inbound protocol matches any of the identifiers in the array.\n\n",
          "markdownDescription": "\nAn array where each item represents an identifier. This rule will take effect when the inbound protocol matches any of the identifiers in the array.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "protocol": {
          "name": "protocol",
          "description": "\nAn array where each item represents a protocol. This rule will take effect when the protocol of the current connection matches any of the protocols in the array.\n\n::: tip\nThe `sniffing` option in the inbound proxy must be enabled to detect the protocol type used by the connection.\n:::\n\n`attrs`: object\n\nA json object with string keys and values, used to detect the HTTP headers of the traffic. It matches when all specified keys exist in the header and corresponding values are a substring of the header value. The key is case in-sensitive. You can use regex to match with value.\n\nCurrently, only the inbound HTTP proxy sets this attribute.\n\nExamples:\n\n- Detect HTTP GET\uff1a`{\":method\": \"GET\"}`\n- Detect HTTP Path\uff1a`{\":path\": \"/test\"}\"`\n- Detect Content Type\uff1a`{\"accept\": \"text/html\"}\"`\n\n",
          "markdownDescription": "\nAn array where each item represents a protocol. This rule will take effect when the protocol of the current connection matches any of the protocols in the array.\n\n::: tip\nThe `sniffing` option in the inbound proxy must be enabled to detect the protocol type used by the connection.\n:::\n\n`attrs`: object\n\nA json object with string keys and values, used to detect the HTTP headers of the traffic. It matches when all specified keys exist in the header and corresponding values are a substring of the header value. The key is case in-sensitive. You can use regex to match with value.\n\nCurrently, only the inbound HTTP proxy sets this attribute.\n\nExamples:\n\n- Detect HTTP GET\uff1a`{\":method\": \"GET\"}`\n- Detect HTTP Path\uff1a`{\":path\": \"/test\"}\"`\n- Detect Content Type\uff1a`{\"accept\": \"text/html\"}\"`\n\n",
          "type": "array",
          "items": {
            "anyOf": [
              {
                "const": "http"
              },
              {
                "const": "tls"
              },
              {
                "const": "bittorrent"
              }
            ]
          }
        },
        "outboundTag": {
          "name": "outboundTag",
          "description": "\nCorresponds to the identifier of an outbound.\n\n",
          "markdownDescription": "\nCorresponds to the identifier of an outbound.\n\n",
          "type": "string"
        },
        "balancerTag": {
          "name": "balancerTag",
          "description": "\nCorresponds to the identifier of a balancer.\n\n::: tip\n`balancerTag` and `outboundTag` are mutually exclusive. When both are specified, `outboundTag` takes effect.\n:::\n\n",
          "markdownDescription": "\nCorresponds to the identifier of a balancer.\n\n::: tip\n`balancerTag` and `outboundTag` are mutually exclusive. When both are specified, `outboundTag` takes effect.\n:::\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "BalancerObject": {
      "title": "BalancerObject",
      "description": "\nLoad balancer configuration. When a load balancer is in effect, it selects the most appropriate outbound from the specified outbound according to the configuration and forwards traffic.\n\n```json\n{\n  \"tag\": \"balancer\",\n  \"selector\": []\n}\n```\n\n",
      "markdownDescription": "\nLoad balancer configuration. When a load balancer is in effect, it selects the most appropriate outbound from the specified outbound according to the configuration and forwards traffic.\n\n```json\n{\n  \"tag\": \"balancer\",\n  \"selector\": []\n}\n```\n\n",
      "properties": {
        "tag": {
          "name": "tag",
          "description": "\nThe identifier of this load balancer, used to match `balancerTag` in `RuleObject`.\n\n",
          "markdownDescription": "\nThe identifier of this load balancer, used to match `balancerTag` in `RuleObject`.\n\n",
          "type": "string"
        },
        "selector": {
          "name": "selector",
          "description": "\nAn array of strings, each of which will be used to match the prefix of the outbound identifier. For example, in the following outbound identifiers: `[ \"a\", \"ab\", \"c\", \"ba\" ]`, `\"selector\": [\"a\"]` will match `[ \"a\", \"ab\" ]`.\n\nIf multiple outbounds are matched, the load balancer currently selects one randomly as the final outbound.\n\n",
          "markdownDescription": "\nAn array of strings, each of which will be used to match the prefix of the outbound identifier. For example, in the following outbound identifiers: `[ \"a\", \"ab\", \"c\", \"ba\" ]`, `\"selector\": [\"a\"]` will match `[ \"a\", \"ab\" ]`.\n\nIf multiple outbounds are matched, the load balancer currently selects one randomly as the final outbound.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "Predefined Domain Lists": {
      "title": "Predefined Domain Lists",
      "description": "\nThis list is included in every Xray installation package, and the file name is `geosite.dat`. This file contains some common domain names, which can be used as `geosite:filename` to perform routing or DNS filtering for domain names that match those in the file.\n\nCommon domain lists include:\n\n- `category-ads`: Contains common advertising domain names.\n- `category-ads-all`: Contains common advertising domain names and advertising provider domain names.\n- `cn`: Equivalent to the combination of `geolocation-cn` and `tld-cn`.\n- `apple`: Contains most of the domain names under Apple.\n- `google`: Contains most of the domain names under Google.\n- `microsoft`: Contains most of the domain names under Microsoft.\n- `facebook`: Contains most of the domain names under Facebook.\n- `twitter`: Contains most of the domain names under Twitter.\n- `telegram`: Contains most of the domain names under Telegram.\n- `geolocation-cn`: Contains common domain names of mainland Chinese websites.\n- `geolocation-!cn`: Contains common domain names of non-mainland Chinese websites.\n- `tld-cn`: Contains top-level domain names managed by CNNIC for mainland China, such as domain names ending in `.cn` and `.\u4e2d\u56fd`.\n- `tld-!cn`: Contains top-level domain names used outside mainland China, such as domain names ending in `.tw` (Taiwan), `.jp` (Japan), `.sg` (Singapore), `.us` (United States), and `.ca` (Canada).\n\nYou can also find the complete list of domain names here: [Domain list community](https://github.com/v2fly/domain-list-community).\n# Inbound Proxy\n\nInbound connections are used to receive incoming data and the available protocols are listed in [inbound protocols](./inbounds/).\n\n",
      "markdownDescription": "\nThis list is included in every Xray installation package, and the file name is `geosite.dat`. This file contains some common domain names, which can be used as `geosite:filename` to perform routing or DNS filtering for domain names that match those in the file.\n\nCommon domain lists include:\n\n- `category-ads`: Contains common advertising domain names.\n- `category-ads-all`: Contains common advertising domain names and advertising provider domain names.\n- `cn`: Equivalent to the combination of `geolocation-cn` and `tld-cn`.\n- `apple`: Contains most of the domain names under Apple.\n- `google`: Contains most of the domain names under Google.\n- `microsoft`: Contains most of the domain names under Microsoft.\n- `facebook`: Contains most of the domain names under Facebook.\n- `twitter`: Contains most of the domain names under Twitter.\n- `telegram`: Contains most of the domain names under Telegram.\n- `geolocation-cn`: Contains common domain names of mainland Chinese websites.\n- `geolocation-!cn`: Contains common domain names of non-mainland Chinese websites.\n- `tld-cn`: Contains top-level domain names managed by CNNIC for mainland China, such as domain names ending in `.cn` and `.\u4e2d\u56fd`.\n- `tld-!cn`: Contains top-level domain names used outside mainland China, such as domain names ending in `.tw` (Taiwan), `.jp` (Japan), `.sg` (Singapore), `.us` (United States), and `.ca` (Canada).\n\nYou can also find the complete list of domain names here: [Domain list community](https://github.com/v2fly/domain-list-community).\n# Inbound Proxy\n\nInbound connections are used to receive incoming data and the available protocols are listed in [inbound protocols](./inbounds/).\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "InboundObject": {
      "title": "InboundObject",
      "description": "\nThe `InboundObject` corresponds to a subelement of the `inbounds` item in the configuration file.\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"listen\": \"127.0.0.1\",\n      \"port\": 1080,\n      \"protocol\": \"protocol_name\",\n      \"settings\": {},\n      \"streamSettings\": {},\n      \"tag\": \"identifier\",\n      \"sniffing\": {\n        \"enabled\": true,\n        \"destOverride\": [\"http\", \"tls\"]\n      },\n      \"allocate\": {\n        \"strategy\": \"always\",\n        \"refresh\": 5,\n        \"concurrency\": 3\n      }\n    }\n  ]\n}\n```\n\n",
      "markdownDescription": "\nThe `InboundObject` corresponds to a subelement of the `inbounds` item in the configuration file.\n\n```json\n{\n  \"inbounds\": [\n    {\n      \"listen\": \"127.0.0.1\",\n      \"port\": 1080,\n      \"protocol\": \"protocol_name\",\n      \"settings\": {},\n      \"streamSettings\": {},\n      \"tag\": \"identifier\",\n      \"sniffing\": {\n        \"enabled\": true,\n        \"destOverride\": [\"http\", \"tls\"]\n      },\n      \"allocate\": {\n        \"strategy\": \"always\",\n        \"refresh\": 5,\n        \"concurrency\": 3\n      }\n    }\n  ]\n}\n```\n\n",
      "properties": {
        "listen": {
          "name": "listen",
          "description": "\nThe listening address, either an IP address or a Unix domain socket. The default value is `\"0.0.0.0\"`, which means accepting connections on all network interfaces.\n\nAn available system IP address can be specified.\n\nUnix domain socket can also be specified by providing the absolute path in the form of `\"/dev/shm/domain.socket\"`. The `@` symbol can be added at the beginning to represent [abstract](https://www.man7.org/linux/man-pages/man7/unix.7.html), and `@@` represents padded abstract.\n\nWhen Unix domain socket is specified, `port` and `allocate` will be ignored. The protocol currently supports VLESS, VMess, and Trojan. The transport methods available are TCP, WebSocket, HTTP/2, and gRPC.\n\nWhen specifying a Unix domain socket, you can add a comma and an access permission indicator after the socket, such as `\"/dev/shm/domain.socket,0666\"`, to specify the access permission of the socket. This can be used to solve the socket access permission issue that occurs by default.\n\n",
          "markdownDescription": "\nThe listening address, either an IP address or a Unix domain socket. The default value is `\"0.0.0.0\"`, which means accepting connections on all network interfaces.\n\nAn available system IP address can be specified.\n\nUnix domain socket can also be specified by providing the absolute path in the form of `\"/dev/shm/domain.socket\"`. The `@` symbol can be added at the beginning to represent [abstract](https://www.man7.org/linux/man-pages/man7/unix.7.html), and `@@` represents padded abstract.\n\nWhen Unix domain socket is specified, `port` and `allocate` will be ignored. The protocol currently supports VLESS, VMess, and Trojan. The transport methods available are TCP, WebSocket, HTTP/2, and gRPC.\n\nWhen specifying a Unix domain socket, you can add a comma and an access permission indicator after the socket, such as `\"/dev/shm/domain.socket,0666\"`, to specify the access permission of the socket. This can be used to solve the socket access permission issue that occurs by default.\n\n",
          "type": "string"
        },
        "port": {
          "name": "port",
          "description": "\nPort. The accepted formats are:\n\n- Integer: the actual port number.\n- Environment variable: starts with `\"env:\"`, followed by the name of an environment variable, such as `\"env:PORT\"`. Xray will parse this environment variable as a string.\n- String: can be a numeric string, such as `\"1234\"`, or a range of port numbers, such as `\"5-10\"` which represents ports 5 through 10, a total of 6 ports. You can use commas to separate multiple ranges, such as `11,13,15-17`, which represents ports 11, 13, and 15 through 17, a total of 5 ports.\n\nWhen only one port is specified, Xray listens for inbound connections on that port. When a range of ports is specified, it depends on the `allocate` setting.\n\n",
          "markdownDescription": "\nPort. The accepted formats are:\n\n- Integer: the actual port number.\n- Environment variable: starts with `\"env:\"`, followed by the name of an environment variable, such as `\"env:PORT\"`. Xray will parse this environment variable as a string.\n- String: can be a numeric string, such as `\"1234\"`, or a range of port numbers, such as `\"5-10\"` which represents ports 5 through 10, a total of 6 ports. You can use commas to separate multiple ranges, such as `11,13,15-17`, which represents ports 11, 13, and 15 through 17, a total of 5 ports.\n\nWhen only one port is specified, Xray listens for inbound connections on that port. When a range of ports is specified, it depends on the `allocate` setting.\n\n",
          "anyOf": [
            {
              "type": "number"
            },
            {
              "const": "env:variable"
            },
            {
              "type": "string"
            }
          ]
        },
        "protocol": {
          "name": "protocol",
          "description": "\nThe connection protocol name. The optional protocol types are listed in [inbound protocols](./inbounds/).\n\n",
          "markdownDescription": "\nThe connection protocol name. The optional protocol types are listed in [inbound protocols](./inbounds/).\n\n",
          "anyOf": [
            {
              "const": "dokodemo-door"
            },
            {
              "const": "http"
            },
            {
              "const": "shadowsocks"
            },
            {
              "const": "socks"
            },
            {
              "const": "vless"
            },
            {
              "const": "vmess"
            },
            {
              "const": "trojan"
            },
            {
              "const": "wireguard"
            }
          ]
        },
        "settings": {
          "name": "settings",
          "description": "\nThe specific configuration content depends on the protocol. See `InboundConfigurationObject` in each protocol for details.\n\n",
          "markdownDescription": "\nThe specific configuration content depends on the protocol. See `InboundConfigurationObject` in each protocol for details.\n\n",
          "$ref": "#/definitions/InboundConfigurationObject"
        },
        "streamSettings": {
          "name": "streamSettings",
          "description": "\nThe underlying transport method is how the current Xray node interfaces with other nodes.\n\n",
          "markdownDescription": "\nThe underlying transport method is how the current Xray node interfaces with other nodes.\n\n",
          "$ref": "#/definitions/StreamSettingsObject"
        },
        "tag": {
          "name": "tag",
          "description": ">\n> The identifier of this inbound connection, used to locate this connection in other configurations.\n\n::: danger\nWhen it is not empty, its value must be **unique** among all `tag`s.\n:::\n\n",
          "markdownDescription": ">\n> The identifier of this inbound connection, used to locate this connection in other configurations.\n\n::: danger\nWhen it is not empty, its value must be **unique** among all `tag`s.\n:::\n\n",
          "type": "string"
        },
        "sniffing": {
          "name": "sniffing",
          "description": "\nTraffic sniffing is mainly used in transparent proxies, for example:\n\n1. If a device wants to access `abc.com` while connected to the internet, it will first query the IP address of `abc.com` via DNS and get `1.2.3.4`. Then the device will initiate a connection to `1.2.3.4`.\n2. If sniffing is not set up, Xray will receive a connection request for `1.2.3.4`, which cannot be used for routing based on domain rules.\n3. When `enable` in `sniffing` is set to `true`, Xray will sniff the domain name, `abc.com`, from the traffic data when processing the traffic of this connection.\n4. Xray will reset `1.2.3.4` to `abc.com`. Routing can then be based on domain rules.\n\nSince the connection is now to `abc.com`, more can be done, such as routing based on domain rules, and even re-resolving the DNS.\n\nWhen `enable` in `sniffing` is set to `true`, it can also sniff out bittorrent traffic and then configure the \"protocol\" item in routing rules to handle bittorrent traffic, such as intercepting bittorrent traffic on the server or forwarding bittorrent traffic to a VPS on the client side.\n\n",
          "markdownDescription": "\nTraffic sniffing is mainly used in transparent proxies, for example:\n\n1. If a device wants to access `abc.com` while connected to the internet, it will first query the IP address of `abc.com` via DNS and get `1.2.3.4`. Then the device will initiate a connection to `1.2.3.4`.\n2. If sniffing is not set up, Xray will receive a connection request for `1.2.3.4`, which cannot be used for routing based on domain rules.\n3. When `enable` in `sniffing` is set to `true`, Xray will sniff the domain name, `abc.com`, from the traffic data when processing the traffic of this connection.\n4. Xray will reset `1.2.3.4` to `abc.com`. Routing can then be based on domain rules.\n\nSince the connection is now to `abc.com`, more can be done, such as routing based on domain rules, and even re-resolving the DNS.\n\nWhen `enable` in `sniffing` is set to `true`, it can also sniff out bittorrent traffic and then configure the \"protocol\" item in routing rules to handle bittorrent traffic, such as intercepting bittorrent traffic on the server or forwarding bittorrent traffic to a VPS on the client side.\n\n",
          "$ref": "#/definitions/SniffingObject"
        },
        "allocate": {
          "name": "allocate",
          "description": "\nSpecifies the specific settings for port allocation when multiple ports are set up.\n\n",
          "markdownDescription": "\nSpecifies the specific settings for port allocation when multiple ports are set up.\n\n",
          "$ref": "#/definitions/AllocateObject"
        }
      },
      "additionalProperties": false
    },
    "SniffingObject": {
      "title": "SniffingObject",
      "description": "\n```json\n{\n  \"enabled\": true,\n  \"destOverride\": [\"http\", \"tls\", \"quic\", \"fakedns\", \"fakedns+others\"],\n  \"metadataOnly\": false,\n  \"domainsExcluded\": [],\n  \"routeOnly\": false\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"enabled\": true,\n  \"destOverride\": [\"http\", \"tls\", \"quic\", \"fakedns\", \"fakedns+others\"],\n  \"metadataOnly\": false,\n  \"domainsExcluded\": [],\n  \"routeOnly\": false\n}\n```\n\n",
      "properties": {
        "enabled": {
          "name": "enabled",
          "description": "\nWhether to enable traffic sniffing.\n\n",
          "markdownDescription": "\nWhether to enable traffic sniffing.\n\n",
          "type": "boolean"
        },
        "destOverride": {
          "name": "destOverride",
          "description": "\nWhen the traffic is of a specified type, reset the destination of the current connection to the target address included in the list.\n\n`[\"fakedns+others\"]` is equivalent to `[\"http\", \"tls\", \"quic\", \"fakedns\"]`, and when the IP address is in the FakeIP range but no domain records are hit, `http`, `tls`, and `quic` will be used for matching. This option is only effective when `metadataOnly` is set to `false`.\n\n",
          "markdownDescription": "\nWhen the traffic is of a specified type, reset the destination of the current connection to the target address included in the list.\n\n`[\"fakedns+others\"]` is equivalent to `[\"http\", \"tls\", \"quic\", \"fakedns\"]`, and when the IP address is in the FakeIP range but no domain records are hit, `http`, `tls`, and `quic` will be used for matching. This option is only effective when `metadataOnly` is set to `false`.\n\n",
          "type": "array",
          "items": {
            "anyOf": [
              {
                "const": "http"
              },
              {
                "const": "tls"
              },
              {
                "const": "quic"
              },
              {
                "const": "fakedns"
              },
              {
                "const": "fakedns+others"
              }
            ]
          }
        },
        "metadataOnly": {
          "name": "metadataOnly",
          "description": "\nWhen enabled, only use the connection's metadata to sniff the target address. In this case, sniffer other than `fakedns` (including `fakedns+others`) cannot be activated.\n\nIf metadata-only is disabled, the client must send data before the proxy server actually establishes the connection. This behavior is incompatible with protocols that require the server to initiate the first message, such as the SMTP protocol.\n\n",
          "markdownDescription": "\nWhen enabled, only use the connection's metadata to sniff the target address. In this case, sniffer other than `fakedns` (including `fakedns+others`) cannot be activated.\n\nIf metadata-only is disabled, the client must send data before the proxy server actually establishes the connection. This behavior is incompatible with protocols that require the server to initiate the first message, such as the SMTP protocol.\n\n",
          "type": "boolean"
        },
        "domainsExcluded": {
          "name": "domainsExcluded",
          "description": "\nA list of domain names. If the traffic sniffing result matches a domain name in this list, the target address will **not** be reset.\n\n::: warning\nCurrently, `domainsExcluded` does not support domain name matching in the routing sense. This option may change in the future and cross-version compatibility is not guaranteed.\n:::\n\n",
          "markdownDescription": "\nA list of domain names. If the traffic sniffing result matches a domain name in this list, the target address will **not** be reset.\n\n::: warning\nCurrently, `domainsExcluded` does not support domain name matching in the routing sense. This option may change in the future and cross-version compatibility is not guaranteed.\n:::\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "routeOnly": {
          "name": "routeOnly",
          "description": "\nUse the sniffed domain name for routing only, and keep the target address as the IP address. The default value is `false`.\n\nThis option requires `destOverride` to be enabled.\n\n::: tip\nWhen it is possible to ensure that **the proxied connection can obtain correct DNS resolution**, by using `routeOnly` and enabling `destOverride`, and setting the routing matching strategy `domainStrategy` to `AsIs`, it is possible to achieve domain and IP separation without DNS resolution throughout the process. The IP used when encountering an IP rule match is the original IP of the domain.\n:::\n\n",
          "markdownDescription": "\nUse the sniffed domain name for routing only, and keep the target address as the IP address. The default value is `false`.\n\nThis option requires `destOverride` to be enabled.\n\n::: tip\nWhen it is possible to ensure that **the proxied connection can obtain correct DNS resolution**, by using `routeOnly` and enabling `destOverride`, and setting the routing matching strategy `domainStrategy` to `AsIs`, it is possible to achieve domain and IP separation without DNS resolution throughout the process. The IP used when encountering an IP rule match is the original IP of the domain.\n:::\n\n",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "AllocateObject": {
      "title": "AllocateObject",
      "description": "\n```json\n{\n  \"strategy\": \"always\",\n  \"refresh\": 5,\n  \"concurrency\": 3\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"strategy\": \"always\",\n  \"refresh\": 5,\n  \"concurrency\": 3\n}\n```\n\n",
      "properties": {
        "strategy": {
          "name": "strategy",
          "description": "\nThe port allocation strategy.\n\n- `\"always\"` means all specified ports in `port` will be allocated, and Xray will listen on these ports.\n- `\"random\"` means ports will be randomly selected from the `port` range every `refresh` minutes, and `concurrency` ports will be listened on.\n\n",
          "markdownDescription": "\nThe port allocation strategy.\n\n- `\"always\"` means all specified ports in `port` will be allocated, and Xray will listen on these ports.\n- `\"random\"` means ports will be randomly selected from the `port` range every `refresh` minutes, and `concurrency` ports will be listened on.\n\n",
          "anyOf": [
            {
              "const": "always"
            },
            {
              "const": "random"
            }
          ]
        },
        "refresh": {
          "name": "refresh",
          "description": "\nThe interval for refreshing randomly allocated ports in minutes. The minimum value is `2`, and it is recommended to set to `5`. This property is only effective when `strategy` is set to `\"random\"`.\n\n",
          "markdownDescription": "\nThe interval for refreshing randomly allocated ports in minutes. The minimum value is `2`, and it is recommended to set to `5`. This property is only effective when `strategy` is set to `\"random\"`.\n\n",
          "type": "number"
        },
        "concurrency": {
          "name": "concurrency",
          "description": "\nThe number of randomly allocated ports. The minimum value is `1`, and the maximum value is one-third of the `port` range. It is recommended to set to `3`.\n# Connection Monitoring\n\nThe connection monitoring component uses HTTPing to detect the connection\nstatus of outbound proxies. The monitoring results can be used by other\ncomponents, such as load balancers. There are currently two options:\n[observatory](#observatoryobject) (background connection monitoring) and\n[burstObservatory](#burstobservatoryobject) (concurrent connection monitoring).\nYou can choose one of them as needed.\n\n",
          "markdownDescription": "\nThe number of randomly allocated ports. The minimum value is `1`, and the maximum value is one-third of the `port` range. It is recommended to set to `3`.\n# Connection Monitoring\n\nThe connection monitoring component uses HTTPing to detect the connection\nstatus of outbound proxies. The monitoring results can be used by other\ncomponents, such as load balancers. There are currently two options:\n[observatory](#observatoryobject) (background connection monitoring) and\n[burstObservatory](#burstobservatoryobject) (concurrent connection monitoring).\nYou can choose one of them as needed.\n\n",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "ObservatoryObject": {
      "title": "ObservatoryObject",
      "description": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"probeUrl\": \"https://www.google.com/generate_204\",\n  \"probeInterval\": \"10s\",\n  \"enableConcurrency\": false\n}\n```\n\n",
      "markdownDescription": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"probeUrl\": \"https://www.google.com/generate_204\",\n  \"probeInterval\": \"10s\",\n  \"enableConcurrency\": false\n}\n```\n\n",
      "properties": {
        "subjectSelector": {
          "name": "subjectSelector",
          "description": "\nAn array of strings, where each string is used to match the prefix of outbound proxy identifiers. Among the following outbound proxy identifiers: `[\"a\", \"ab\", \"c\", \"ba\"]`, `\"subjectSelector\": [\"a\"]` will match `[\"a\", \"ab\"]`.\n\n",
          "markdownDescription": "\nAn array of strings, where each string is used to match the prefix of outbound proxy identifiers. Among the following outbound proxy identifiers: `[\"a\", \"ab\", \"c\", \"ba\"]`, `\"subjectSelector\": [\"a\"]` will match `[\"a\", \"ab\"]`.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "probeUrl": {
          "name": "probeUrl",
          "description": "\nThe URL used to detect the connection status of the outbound proxy.\n\n",
          "markdownDescription": "\nThe URL used to detect the connection status of the outbound proxy.\n\n",
          "type": "string"
        },
        "probeInterval": {
          "name": "probeInterval",
          "description": "\nThe interval at which probes are initiated. The time format is a number followed by a unit, such as `\"10s\"`, `\"2h45m\"`. Supported time units include `ns`, `us`, `ms`, `s`, `m`, `h`, corresponding to nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, respectively.\n\n",
          "markdownDescription": "\nThe interval at which probes are initiated. The time format is a number followed by a unit, such as `\"10s\"`, `\"2h45m\"`. Supported time units include `ns`, `us`, `ms`, `s`, `m`, `h`, corresponding to nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, respectively.\n\n",
          "type": "string"
        },
        "enableConcurrency": {
          "name": "enableConcurrency",
          "description": "\n- `true`: Concurrently probe all matching outbound proxies, then pause for the time set by `probeInterval`.\n- `false`: Probe each matching outbound proxy one by one, pausing for the time set by `probeInterval` after probing each one.\n\n",
          "markdownDescription": "\n- `true`: Concurrently probe all matching outbound proxies, then pause for the time set by `probeInterval`.\n- `false`: Probe each matching outbound proxy one by one, pausing for the time set by `probeInterval` after probing each one.\n\n",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "BurstObservatoryObject": {
      "title": "BurstObservatoryObject",
      "description": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"pingConfig\": {}\n}\n```\n\n",
      "markdownDescription": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"pingConfig\": {}\n}\n```\n\n",
      "properties": {
        "subjectSelector": {
          "name": "subjectSelector",
          "description": "\nAn array of strings, where each string is used to match the prefix of outbound proxy identifiers. Among the following outbound proxy identifiers: `[\"a\", \"ab\", \"c\", \"ba\"]`, `\"subjectSelector\": [\"a\"]` will match `[\"a\", \"ab\"]`.\n\n",
          "markdownDescription": "\nAn array of strings, where each string is used to match the prefix of outbound proxy identifiers. Among the following outbound proxy identifiers: `[\"a\", \"ab\", \"c\", \"ba\"]`, `\"subjectSelector\": [\"a\"]` will match `[\"a\", \"ab\"]`.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "pingConfig": {
          "name": "pingConfig",
          "description": "\n\n",
          "markdownDescription": "\n\n",
          "$ref": "#/definitions/PingConfigObject"
        }
      },
      "additionalProperties": false
    },
    "PingConfigObject": {
      "title": "PingConfigObject",
      "description": "```json\n{\n  \"destination\": \"https://connectivitycheck.gstatic.com/generate_204\",\n  \"connectivity\": \"\",\n  \"interval\": \"1h\",\n  \"sampling\": 3,\n  \"timeout\": \"30s\"\n}\n```\n\n",
      "markdownDescription": "```json\n{\n  \"destination\": \"https://connectivitycheck.gstatic.com/generate_204\",\n  \"connectivity\": \"\",\n  \"interval\": \"1h\",\n  \"sampling\": 3,\n  \"timeout\": \"30s\"\n}\n```\n\n",
      "properties": {
        "destination": {
          "name": "destination",
          "description": "\nThe URL used to detect the connection status of the outbound proxy. This URL should return an HTTP 204 success status code.\n\n",
          "markdownDescription": "\nThe URL used to detect the connection status of the outbound proxy. This URL should return an HTTP 204 success status code.\n\n",
          "type": "string"
        },
        "connectivity": {
          "name": "connectivity",
          "description": "\nThe URL used to check local network connectivity. An empty string means that local network connectivity is not checked.\n\n",
          "markdownDescription": "\nThe URL used to check local network connectivity. An empty string means that local network connectivity is not checked.\n\n",
          "type": "string"
        },
        "interval": {
          "name": "interval",
          "description": "\nWithin the specified time, probe all matching outbound proxies, probing each proxy `sampling + 1` times. The time format is a number followed by a unit, such as `\"10s\"`, `\"2h45m\"`. Supported time units include `ns`, `us`, `ms`, `s`, `m`, `h`, corresponding to nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, respectively.\n\n",
          "markdownDescription": "\nWithin the specified time, probe all matching outbound proxies, probing each proxy `sampling + 1` times. The time format is a number followed by a unit, such as `\"10s\"`, `\"2h45m\"`. Supported time units include `ns`, `us`, `ms`, `s`, `m`, `h`, corresponding to nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, respectively.\n\n",
          "type": "string"
        },
        "sampling": {
          "name": "sampling",
          "description": "\nThe number of recent probe results to retain.\n\n",
          "markdownDescription": "\nThe number of recent probe results to retain.\n\n",
          "type": "number"
        },
        "timeout": {
          "name": "timeout",
          "description": "\nThe probe timeout period. The format is the same as the `interval` above.\n# Metrics\n\nA more straightforward (and hopefully better) way to export metrics.\n\n",
          "markdownDescription": "\nThe probe timeout period. The format is the same as the `interval` above.\n# Metrics\n\nA more straightforward (and hopefully better) way to export metrics.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Related configurations": {
      "title": "Related configurations",
      "description": "\nIt's possible to add a metrics inbound among inbounds.\n\n```json\n    \"inbounds\": [\n        {\n            \"listen\": \"127.0.0.1\",\n            \"port\": 11111,\n            \"protocol\": \"dokodemo-door\",\n            \"settings\": {\n                \"address\": \"127.0.0.1\"\n            },\n            \"tag\": \"metrics_in\"\n        }\n    ]\n```\n\nAnd add routing rules regarding the metrics inbound in the routing configuration.\n\n```json\n    \"routing\": {\n        \"rules\": [\n            {\n                \"type\": \"field\",\n                \"inboundTag\": [\n                    \"metrics_in\"\n                ],\n                \"outboundTag\": \"metrics_out\"\n            }\n        ]\n    }\n```\n\nThen finally, enable metrics under the root object.\n\n```json\n    \"metrics\": {\n        \"tag\": \"metrics_out\"\n    }\n```\n\n",
      "markdownDescription": "\nIt's possible to add a metrics inbound among inbounds.\n\n```json\n    \"inbounds\": [\n        {\n            \"listen\": \"127.0.0.1\",\n            \"port\": 11111,\n            \"protocol\": \"dokodemo-door\",\n            \"settings\": {\n                \"address\": \"127.0.0.1\"\n            },\n            \"tag\": \"metrics_in\"\n        }\n    ]\n```\n\nAnd add routing rules regarding the metrics inbound in the routing configuration.\n\n```json\n    \"routing\": {\n        \"rules\": [\n            {\n                \"type\": \"field\",\n                \"inboundTag\": [\n                    \"metrics_in\"\n                ],\n                \"outboundTag\": \"metrics_out\"\n            }\n        ]\n    }\n```\n\nThen finally, enable metrics under the root object.\n\n```json\n    \"metrics\": {\n        \"tag\": \"metrics_out\"\n    }\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Usage": {
      "anyOf": [
        {
          "title": "Usage",
          "description": "\n",
          "markdownDescription": "\n",
          "properties": {},
          "additionalProperties": true
        },
        {
          "title": "Usage",
          "description": "\nDokodemo-door can be used as Transparent proxy (in the next section) and can be used to mapping a port.\n\nSome services does not support proxy likes SOCKS5, but using Tun or Tproxy could be too complicated. If these services only communicate with only one port (like iperf, Minecraft server, Wireguard endpoint, etc.), dokodemo-door can be used.\n\nBelow is an example config (if the default outbound is an effective proxy):\n\n```json\n{\n  \"listen\": \"127.0.0.1\",\n  \"port\": 25565,\n  \"protocol\": \"dokodemo-door\",\n  \"settings\": {\n    \"address\": \"mc.hypixel.net\",\n    \"port\": 25565,\n    \"network\": \"tcp\",\n    \"followRedirect\": false,\n    \"userLevel\": 0\n  },\n  \"tag\": \"mc\"\n}\n```\n\nThe core will listen at `127.0.0.1:25565`, and the traffic coming in through this inbound will be send to `mc.hypixel.net:25565` (a Minecraft server) through the default outbound. Then you can connect the Minecraft client to the Hypixel server through the proxy by set the game server to `127.0.0.1:25565` in the Minecraft client.\n\n",
          "markdownDescription": "\nDokodemo-door can be used as Transparent proxy (in the next section) and can be used to mapping a port.\n\nSome services does not support proxy likes SOCKS5, but using Tun or Tproxy could be too complicated. If these services only communicate with only one port (like iperf, Minecraft server, Wireguard endpoint, etc.), dokodemo-door can be used.\n\nBelow is an example config (if the default outbound is an effective proxy):\n\n```json\n{\n  \"listen\": \"127.0.0.1\",\n  \"port\": 25565,\n  \"protocol\": \"dokodemo-door\",\n  \"settings\": {\n    \"address\": \"mc.hypixel.net\",\n    \"port\": 25565,\n    \"network\": \"tcp\",\n    \"followRedirect\": false,\n    \"userLevel\": 0\n  },\n  \"tag\": \"mc\"\n}\n```\n\nThe core will listen at `127.0.0.1:25565`, and the traffic coming in through this inbound will be send to `mc.hypixel.net:25565` (a Minecraft server) through the default outbound. Then you can connect the Minecraft client to the Hypixel server through the proxy by set the game server to `127.0.0.1:25565` in the Minecraft client.\n\n",
          "properties": {},
          "additionalProperties": true
        }
      ]
    },
    "pprof": {
      "title": "pprof",
      "description": "\nAccess `http://127.0.0.1:11111/debug/pprof/` or use go tool pprof to start profiling or inspect running goroutines.\n\n",
      "markdownDescription": "\nAccess `http://127.0.0.1:11111/debug/pprof/` or use go tool pprof to start profiling or inspect running goroutines.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "expvars": {
      "title": "expvars",
      "description": "\nAccess `http://127.0.0.1:11111/debug/vars`\n\nVariables exported include:\n* `stats` includes statistics about inbounds, outbounds and users\n* `observatory` includes observatory results\n\nfor example with [luci-app-xray](https://github.com/yichya/luci-app-xray) you are likely to get a result like this (standard expvar things like `cmdline` and `memstats` are omitted)\n\n<details><summary>Click to expand</summary><br>\n\n```json\n{\n    \"observatory\": {\n        \"tcp_outbound\": {\n            \"alive\": true,\n            \"delay\": 782,\n            \"outbound_tag\": \"tcp_outbound\",\n            \"last_seen_time\": 1648477189,\n            \"last_try_time\": 1648477189\n        },\n        \"udp_outbound\": {\n            \"alive\": true,\n            \"delay\": 779,\n            \"outbound_tag\": \"udp_outbound\",\n            \"last_seen_time\": 1648477191,\n            \"last_try_time\": 1648477191\n        }\n    },\n    \"stats\": {\n        \"inbound\": {\n            \"api\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"dns_server_inbound_5300\": {\n                \"downlink\": 14286,\n                \"uplink\": 5857\n            },\n            \"http_inbound\": {\n                \"downlink\": 74460,\n                \"uplink\": 10231\n            },\n            \"https_inbound\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"metrics\": {\n                \"downlink\": 6327,\n                \"uplink\": 1347\n            },\n            \"socks_inbound\": {\n                \"downlink\": 19925615,\n                \"uplink\": 5512\n            },\n            \"tproxy_tcp_inbound\": {\n                \"downlink\": 4739161,\n                \"uplink\": 1568869\n            },\n            \"tproxy_udp_inbound\": {\n                \"downlink\": 0,\n                \"uplink\": 2608142\n            }\n        },\n        \"outbound\": {\n            \"blackhole_outbound\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"direct\": {\n                \"downlink\": 97714548,\n                \"uplink\": 3234617\n            },\n            \"dns_server_outbound\": {\n                \"downlink\": 7116,\n                \"uplink\": 2229\n            },\n            \"manual_tproxy_outbound_tcp_1\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"manual_tproxy_outbound_udp_1\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"tcp_outbound\": {\n                \"downlink\": 23873238,\n                \"uplink\": 1049595\n            },\n            \"udp_outbound\": {\n                \"downlink\": 639282,\n                \"uplink\": 74634\n            }\n        },\n        \"user\": {}\n    }\n}\n```\n</details>\n\nTo get a better view of these numbers, [Netdata](https://github.com/netdata/netdata) (with python.d plugin) is a great option:\n\n1. Edit related configuration file (`sudo /etc/netdata/edit-config python.d/go_expvar.conf`)\n2. Take the following configuration file as an example:\n\n<details><summary>Click to expand</summary><br>\n\n```\nxray:\n  name: 'xray'\n  update_every: 2\n  url: 'http://127.0.0.1:11111/debug/vars'\n  collect_memstats: false\n  extra_charts:\n     - id: 'inbounds'\n       options:\n         name: 'inbounds'\n         title: 'Xray System Inbounds'\n         units: bytes\n         family: xray\n         context: xray.inbounds\n         chart_type: line\n       lines:\n         - expvar_key: stats.inbound.tproxy_tcp_inbound.downlink\n           id: 'tcp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_udp_inbound.downlink\n           id: 'udp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.http_inbound.downlink\n           id: 'http.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.https_inbound.downlink\n           id: 'https.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.socks_inbound.downlink\n           id: 'socks.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_tcp_inbound.uplink\n           id: 'tcp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_udp_inbound.uplink\n           id: 'udp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.http_inbound.uplink\n           id: 'http.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.https_inbound.uplink\n           id: 'https.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.socks_inbound.uplink\n           id: 'socks.uplink'\n           algorithm: incremental\n           expvar_type: int\n     - id: 'outbounds'\n       options:\n         name: 'outbounds'\n         title: 'Xray System Outbounds'\n         units: bytes\n         family: xray\n         context: xray.outbounds\n         chart_type: line\n       lines:\n         - expvar_key: stats.outbound.tcp_outbound.downlink\n           id: 'tcp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.udp_outbound.downlink\n           id: 'udp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.direct.downlink\n           id: 'direct.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.tcp_outbound.uplink\n           id: 'tcp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.udp_outbound.uplink\n           id: 'udp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.direct.uplink\n           id: 'direct.uplink'\n           algorithm: incremental\n           expvar_type: int\n     - id: 'observatory'\n       options:\n         name: 'observatory'\n         title: 'Xray Observatory Metrics'\n         units: milliseconds\n         family: xray\n         context: xray.observatory\n         chart_type: line\n       lines:\n         - expvar_key: observatory.tcp_outbound.delay\n           id: tcp\n           expvar_type: int\n         - expvar_key: observatory.udp_outbound.delay\n           id: udp\n           expvar_type: int\n```\n</details>\n\nAnd you will get a nice plot like this:\n\n![160428235-2988bf69-5d6c-41ec-8267-1bd512508aa8](https://github.com/chika0801/Xray-docs-next/assets/88967758/455e88ce-ced2-4593-a9fa-425bb293215b)\n\n",
      "markdownDescription": "\nAccess `http://127.0.0.1:11111/debug/vars`\n\nVariables exported include:\n* `stats` includes statistics about inbounds, outbounds and users\n* `observatory` includes observatory results\n\nfor example with [luci-app-xray](https://github.com/yichya/luci-app-xray) you are likely to get a result like this (standard expvar things like `cmdline` and `memstats` are omitted)\n\n<details><summary>Click to expand</summary><br>\n\n```json\n{\n    \"observatory\": {\n        \"tcp_outbound\": {\n            \"alive\": true,\n            \"delay\": 782,\n            \"outbound_tag\": \"tcp_outbound\",\n            \"last_seen_time\": 1648477189,\n            \"last_try_time\": 1648477189\n        },\n        \"udp_outbound\": {\n            \"alive\": true,\n            \"delay\": 779,\n            \"outbound_tag\": \"udp_outbound\",\n            \"last_seen_time\": 1648477191,\n            \"last_try_time\": 1648477191\n        }\n    },\n    \"stats\": {\n        \"inbound\": {\n            \"api\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"dns_server_inbound_5300\": {\n                \"downlink\": 14286,\n                \"uplink\": 5857\n            },\n            \"http_inbound\": {\n                \"downlink\": 74460,\n                \"uplink\": 10231\n            },\n            \"https_inbound\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"metrics\": {\n                \"downlink\": 6327,\n                \"uplink\": 1347\n            },\n            \"socks_inbound\": {\n                \"downlink\": 19925615,\n                \"uplink\": 5512\n            },\n            \"tproxy_tcp_inbound\": {\n                \"downlink\": 4739161,\n                \"uplink\": 1568869\n            },\n            \"tproxy_udp_inbound\": {\n                \"downlink\": 0,\n                \"uplink\": 2608142\n            }\n        },\n        \"outbound\": {\n            \"blackhole_outbound\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"direct\": {\n                \"downlink\": 97714548,\n                \"uplink\": 3234617\n            },\n            \"dns_server_outbound\": {\n                \"downlink\": 7116,\n                \"uplink\": 2229\n            },\n            \"manual_tproxy_outbound_tcp_1\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"manual_tproxy_outbound_udp_1\": {\n                \"downlink\": 0,\n                \"uplink\": 0\n            },\n            \"tcp_outbound\": {\n                \"downlink\": 23873238,\n                \"uplink\": 1049595\n            },\n            \"udp_outbound\": {\n                \"downlink\": 639282,\n                \"uplink\": 74634\n            }\n        },\n        \"user\": {}\n    }\n}\n```\n</details>\n\nTo get a better view of these numbers, [Netdata](https://github.com/netdata/netdata) (with python.d plugin) is a great option:\n\n1. Edit related configuration file (`sudo /etc/netdata/edit-config python.d/go_expvar.conf`)\n2. Take the following configuration file as an example:\n\n<details><summary>Click to expand</summary><br>\n\n```\nxray:\n  name: 'xray'\n  update_every: 2\n  url: 'http://127.0.0.1:11111/debug/vars'\n  collect_memstats: false\n  extra_charts:\n     - id: 'inbounds'\n       options:\n         name: 'inbounds'\n         title: 'Xray System Inbounds'\n         units: bytes\n         family: xray\n         context: xray.inbounds\n         chart_type: line\n       lines:\n         - expvar_key: stats.inbound.tproxy_tcp_inbound.downlink\n           id: 'tcp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_udp_inbound.downlink\n           id: 'udp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.http_inbound.downlink\n           id: 'http.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.https_inbound.downlink\n           id: 'https.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.socks_inbound.downlink\n           id: 'socks.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_tcp_inbound.uplink\n           id: 'tcp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.tproxy_udp_inbound.uplink\n           id: 'udp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.http_inbound.uplink\n           id: 'http.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.https_inbound.uplink\n           id: 'https.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.inbound.socks_inbound.uplink\n           id: 'socks.uplink'\n           algorithm: incremental\n           expvar_type: int\n     - id: 'outbounds'\n       options:\n         name: 'outbounds'\n         title: 'Xray System Outbounds'\n         units: bytes\n         family: xray\n         context: xray.outbounds\n         chart_type: line\n       lines:\n         - expvar_key: stats.outbound.tcp_outbound.downlink\n           id: 'tcp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.udp_outbound.downlink\n           id: 'udp.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.direct.downlink\n           id: 'direct.downlink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.tcp_outbound.uplink\n           id: 'tcp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.udp_outbound.uplink\n           id: 'udp.uplink'\n           algorithm: incremental\n           expvar_type: int\n         - expvar_key: stats.outbound.direct.uplink\n           id: 'direct.uplink'\n           algorithm: incremental\n           expvar_type: int\n     - id: 'observatory'\n       options:\n         name: 'observatory'\n         title: 'Xray Observatory Metrics'\n         units: milliseconds\n         family: xray\n         context: xray.observatory\n         chart_type: line\n       lines:\n         - expvar_key: observatory.tcp_outbound.delay\n           id: tcp\n           expvar_type: int\n         - expvar_key: observatory.udp_outbound.delay\n           id: udp\n           expvar_type: int\n```\n</details>\n\nAnd you will get a nice plot like this:\n\n![160428235-2988bf69-5d6c-41ec-8267-1bd512508aa8](https://github.com/chika0801/Xray-docs-next/assets/88967758/455e88ce-ced2-4593-a9fa-425bb293215b)\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Additional": {
      "title": "Additional",
      "description": "Maybe reusing the empty object `stats` in config file is better than adding `metrics` here?\n\n**Edit:** removed prometheus related things and added usage about expvars\n# Local Policy\n\nLocal policy can be used to set different policy settings for different user levels, such as connection timeout settings. Each connection handled by Xray corresponds to a user, and different policies are applied based on the user's level.\n\n",
      "markdownDescription": "Maybe reusing the empty object `stats` in config file is better than adding `metrics` here?\n\n**Edit:** removed prometheus related things and added usage about expvars\n# Local Policy\n\nLocal policy can be used to set different policy settings for different user levels, such as connection timeout settings. Each connection handled by Xray corresponds to a user, and different policies are applied based on the user's level.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "PolicyObject": {
      "title": "PolicyObject",
      "description": "\n`PolicyObject` corresponds to the `policy` field in the configuration file.\n\n```json\n{\n  \"policy\": {\n    \"levels\": {\n      \"0\": {\n        \"handshake\": 4,\n        \"connIdle\": 300,\n        \"uplinkOnly\": 2,\n        \"downlinkOnly\": 5,\n        \"statsUserUplink\": false,\n        \"statsUserDownlink\": false,\n        \"statsUserOnline\": false,\n        \"bufferSize\": 4\n      }\n    },\n    \"system\": {\n      \"statsInboundUplink\": false,\n      \"statsInboundDownlink\": false,\n      \"statsOutboundUplink\": false,\n      \"statsOutboundDownlink\": false\n    }\n  }\n}\n```\n\n",
      "markdownDescription": "\n`PolicyObject` corresponds to the `policy` field in the configuration file.\n\n```json\n{\n  \"policy\": {\n    \"levels\": {\n      \"0\": {\n        \"handshake\": 4,\n        \"connIdle\": 300,\n        \"uplinkOnly\": 2,\n        \"downlinkOnly\": 5,\n        \"statsUserUplink\": false,\n        \"statsUserDownlink\": false,\n        \"statsUserOnline\": false,\n        \"bufferSize\": 4\n      }\n    },\n    \"system\": {\n      \"statsInboundUplink\": false,\n      \"statsInboundDownlink\": false,\n      \"statsOutboundUplink\": false,\n      \"statsOutboundDownlink\": false\n    }\n  }\n}\n```\n\n",
      "properties": {
        "level": {
          "name": "level",
          "description": "\nA set of key-value pairs, where each key is a string representation of a number (as required by JSON), such as `\"0\"`, `\"1\"`, etc., with the number corresponding to the user level. Each value is a [LevelPolicyObject](#levelpolicyobject).\n\n::: tip\nEach inbound and outbound proxy can now set the user level, and Xray will apply different local policies based on the actual user level.\n:::\n\n",
          "markdownDescription": "\nA set of key-value pairs, where each key is a string representation of a number (as required by JSON), such as `\"0\"`, `\"1\"`, etc., with the number corresponding to the user level. Each value is a [LevelPolicyObject](#levelpolicyobject).\n\n::: tip\nEach inbound and outbound proxy can now set the user level, and Xray will apply different local policies based on the actual user level.\n:::\n\n",
          "type": "object"
        },
        "system": {
          "name": "system",
          "description": "\nXray system-level policy.\n\n",
          "markdownDescription": "\nXray system-level policy.\n\n",
          "$ref": "#/definitions/SystemPolicyObject"
        }
      },
      "additionalProperties": false
    },
    "LevelPolicyObject": {
      "title": "LevelPolicyObject",
      "description": "\n```json\n{\n  \"handshake\": 4,\n  \"connIdle\": 300,\n  \"uplinkOnly\": 2,\n  \"downlinkOnly\": 5,\n  \"statsUserUplink\": false,\n  \"statsUserDownlink\": false,\n  \"bufferSize\": 10240\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"handshake\": 4,\n  \"connIdle\": 300,\n  \"uplinkOnly\": 2,\n  \"downlinkOnly\": 5,\n  \"statsUserUplink\": false,\n  \"statsUserDownlink\": false,\n  \"bufferSize\": 10240\n}\n```\n\n",
      "properties": {
        "handshake": {
          "name": "handshake",
          "description": "\nThe time limit for handshake during connection establishment. Unit: seconds. Default: `4`. When processing a new inbound connection, if the time used in the handshake phase exceeds this limit, the connection will be aborted.\n\n",
          "markdownDescription": "\nThe time limit for handshake during connection establishment. Unit: seconds. Default: `4`. When processing a new inbound connection, if the time used in the handshake phase exceeds this limit, the connection will be aborted.\n\n",
          "type": "number"
        },
        "connIdle": {
          "name": "connIdle",
          "description": "\nThe time limit for connection idle time. Unit: seconds. Default: `300`. When processing an inbound/outbound connection, if no data is transferred (including upstream and downstream data) within `connIdle` time, the connection will be aborted.\n\n",
          "markdownDescription": "\nThe time limit for connection idle time. Unit: seconds. Default: `300`. When processing an inbound/outbound connection, if no data is transferred (including upstream and downstream data) within `connIdle` time, the connection will be aborted.\n\n",
          "type": "number"
        },
        "uplinkOnly": {
          "name": "uplinkOnly",
          "description": "\nThe time limit after the downstream connection is closed. Unit: seconds. Default: `2`. When the server (such as a remote website) closes the downstream connection, the outbound proxy will abort the connection after waiting for `uplinkOnly` time.\n\n",
          "markdownDescription": "\nThe time limit after the downstream connection is closed. Unit: seconds. Default: `2`. When the server (such as a remote website) closes the downstream connection, the outbound proxy will abort the connection after waiting for `uplinkOnly` time.\n\n",
          "type": "number"
        },
        "downlinkOnly": {
          "name": "downlinkOnly",
          "description": "\nThe time limit after the upstream connection is closed. Unit: seconds. Default: `5`. When the client (such as a browser) closes the upstream connection, the inbound proxy will abort the connection after waiting for `downlinkOnly` time.\n\n::: tip\nIn the scenario of HTTP browsing, you can set `uplinkOnly` and `downlinkOnly` to `0` to improve the efficiency of connection closing.\n:::\n\n",
          "markdownDescription": "\nThe time limit after the upstream connection is closed. Unit: seconds. Default: `5`. When the client (such as a browser) closes the upstream connection, the inbound proxy will abort the connection after waiting for `downlinkOnly` time.\n\n::: tip\nIn the scenario of HTTP browsing, you can set `uplinkOnly` and `downlinkOnly` to `0` to improve the efficiency of connection closing.\n:::\n\n",
          "type": "number"
        },
        "statsUserUplink": {
          "name": "statsUserUplink",
          "description": "\nWhen set to `true`, enables upstream traffic statistics for all users at the current level.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables upstream traffic statistics for all users at the current level.\n\n",
          "type": "boolean"
        },
        "statsUserDownlink": {
          "name": "statsUserDownlink",
          "description": "\nWhen set to `true`, enables downstream traffic statistics for all users at the current level.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables downstream traffic statistics for all users at the current level.\n\n",
          "type": "boolean"
        },
        "statsUserOnline": {
          "name": "statsUserOnline",
          "description": "\nWhen set to `true`, enables counting online users for all users at the current level by email.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables counting online users for all users at the current level by email.\n\n",
          "type": "boolean"
        },
        "bufferSize": {
          "name": "bufferSize",
          "description": "\nThe internal buffer size of each connection. Unit: kB. When set to `0`, the internal buffer is disabled.\n\nDefault values:\n\n- On ARM, MIPS, and MIPSLE platforms, the default value is `0`.\n- On ARM64, MIPS64, and MIPS64LE platforms, the default value is `4`.\n- On other platforms, the default value is `512`.\n\n",
          "markdownDescription": "\nThe internal buffer size of each connection. Unit: kB. When set to `0`, the internal buffer is disabled.\n\nDefault values:\n\n- On ARM, MIPS, and MIPSLE platforms, the default value is `0`.\n- On ARM64, MIPS64, and MIPS64LE platforms, the default value is `4`.\n- On other platforms, the default value is `512`.\n\n",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "SystemPolicyObject": {
      "title": "SystemPolicyObject",
      "description": "\n```json\n{\n  \"statsInboundUplink\": false,\n  \"statsInboundDownlink\": false,\n  \"statsOutboundUplink\": false,\n  \"statsOutboundDownlink\": false\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"statsInboundUplink\": false,\n  \"statsInboundDownlink\": false,\n  \"statsOutboundUplink\": false,\n  \"statsOutboundDownlink\": false\n}\n```\n\n",
      "properties": {
        "statsInboundUplink": {
          "name": "statsInboundUplink",
          "description": "\nWhen set to `true`, enables upstream traffic statistics for all inbound proxies.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables upstream traffic statistics for all inbound proxies.\n\n",
          "type": "boolean"
        },
        "statsInboundDownlink": {
          "name": "statsInboundDownlink",
          "description": "\nWhen set to `true`, enables downstream traffic statistics for all inbound proxies.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables downstream traffic statistics for all inbound proxies.\n\n",
          "type": "boolean"
        },
        "statsOutboundUplink": {
          "name": "statsOutboundUplink",
          "description": "\nWhen set to `true`, enables upstream traffic statistics for all outbound proxies.\n\n",
          "markdownDescription": "\nWhen set to `true`, enables upstream traffic statistics for all outbound proxies.\n\n",
          "type": "boolean"
        },
        "statsOutboundDownlink": {
          "name": "statsOutboundDownlink",
          "description": "\nWhen set to `true`, enables downstream traffic statistics for all outbound proxies.\n# Built-in DNS Server\n\n",
          "markdownDescription": "\nWhen set to `true`, enables downstream traffic statistics for all outbound proxies.\n# Built-in DNS Server\n\n",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "DNS Server": {
      "title": "DNS Server",
      "description": "\nThe DNS module built into Xray has two main purposes:\n\n- During the routing phase, it resolves domain names to IP addresses and performs traffic splitting based on the results of domain name resolution and the value of `domainStrategy` in the routing configuration module. The built-in DNS server is only used for DNS queries when either of the following values is set:\n  - \"IPIfNonMatch\": When a domain name is requested, it first tries to match it against the `domain` entries in the routing configuration. If no match is found, the built-in DNS server is used to perform a DNS query for the domain name, and the returned IP address is used to perform IP routing matching again.\n  - \"IPOnDemand\": When a domain name is matched against any IP-based rule, it is immediately resolved to an IP address for matching.\n- It resolves the target address for connection.\n  - In the `freedom` outbound setting, if `domainStrategy` is set to `UseIP`, requests made through the outbound proxy will first resolve the domain name to an IP address using the built-in server before making the connection.\n  - In the `sockopt` setting, if `domainStrategy` is set to `UseIP`, system connections initiated through the outbound proxy will first be resolved to an IP address using the built-in server before making the connection.\n\n::: tip TIP 1\nDNS queries sent by the built-in DNS server are automatically forwarded based on the routing configuration.\n:::\n\n::: tip TIP 2\nOnly basic IP queries (A and AAAA records) are supported. CNAME records will be queried repeatedly until an A/AAAA record is returned. Other queries will not enter the built-in DNS server.\n:::\n\n",
      "markdownDescription": "\nThe DNS module built into Xray has two main purposes:\n\n- During the routing phase, it resolves domain names to IP addresses and performs traffic splitting based on the results of domain name resolution and the value of `domainStrategy` in the routing configuration module. The built-in DNS server is only used for DNS queries when either of the following values is set:\n  - \"IPIfNonMatch\": When a domain name is requested, it first tries to match it against the `domain` entries in the routing configuration. If no match is found, the built-in DNS server is used to perform a DNS query for the domain name, and the returned IP address is used to perform IP routing matching again.\n  - \"IPOnDemand\": When a domain name is matched against any IP-based rule, it is immediately resolved to an IP address for matching.\n- It resolves the target address for connection.\n  - In the `freedom` outbound setting, if `domainStrategy` is set to `UseIP`, requests made through the outbound proxy will first resolve the domain name to an IP address using the built-in server before making the connection.\n  - In the `sockopt` setting, if `domainStrategy` is set to `UseIP`, system connections initiated through the outbound proxy will first be resolved to an IP address using the built-in server before making the connection.\n\n::: tip TIP 1\nDNS queries sent by the built-in DNS server are automatically forwarded based on the routing configuration.\n:::\n\n::: tip TIP 2\nOnly basic IP queries (A and AAAA records) are supported. CNAME records will be queried repeatedly until an A/AAAA record is returned. Other queries will not enter the built-in DNS server.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "DNS Processing Flow": {
      "title": "DNS Processing Flow",
      "description": "\nIf the domain name to be queried:\n\n- Matches the mapping of \"domain name - IP\" or \"domain name - IP array\" in the `hosts`, then the IP or IP array will be returned as the DNS resolution result.\n\n- Matches the mapping of \"domain name - domain name\" in the `hosts`, then the value of this mapping (another domain name) will be used as the domain name to be queried, and enter the DNS processing flow until an IP is resolved and returned, or an empty resolution is returned.\n\n- Does not match `hosts`, but matches the `domains` list in one or more DNS servers, then according to the priority of the matching rule, use the DNS server corresponding to the rule to perform the query in sequence. If the DNS server that is hit fails to query or `expectIPs` does not match, then use the next hit DNS server to perform the query. Otherwise, return the resolved IP. If all hit DNS servers fail to query or `expectIPs` does not match, then the DNS component:\n\n  - By default, it will perform \"DNS fallback query\": use the \"DNS server that has not been used in the last failed query and has a default value of `false` for `skipFallback`\" to perform the query in sequence. If the query fails or `expectIPs` does not match, return an empty resolution; otherwise, return the resolved IP.\n  - If `disableFallback` is set to `true`, \"DNS fallback query\" will not be performed.\n\n- If neither `hosts` nor the `domains` list in DNS servers matches, then:\n\n  - By default, use the \"DNS server that has a default value of `false` for `skipFallback`\" to perform the query in sequence. If the first selected DNS server fails to query or `expectIPs` does not match, then use the next selected DNS server to perform the query. Otherwise, return the resolved IP. If all selected DNS servers fail to query or `expectIPs` does not match, return an empty resolution.\n  - If the number of \"DNS servers that have a default value of `false` for `skipFallback`\" is 0 or `disableFallback` is set to `true`, use the first DNS server in the DNS configuration to perform the query. If the query fails or `expectIPs` does not match, return an empty resolution; otherwise, return the resolved IP.\n\n",
      "markdownDescription": "\nIf the domain name to be queried:\n\n- Matches the mapping of \"domain name - IP\" or \"domain name - IP array\" in the `hosts`, then the IP or IP array will be returned as the DNS resolution result.\n\n- Matches the mapping of \"domain name - domain name\" in the `hosts`, then the value of this mapping (another domain name) will be used as the domain name to be queried, and enter the DNS processing flow until an IP is resolved and returned, or an empty resolution is returned.\n\n- Does not match `hosts`, but matches the `domains` list in one or more DNS servers, then according to the priority of the matching rule, use the DNS server corresponding to the rule to perform the query in sequence. If the DNS server that is hit fails to query or `expectIPs` does not match, then use the next hit DNS server to perform the query. Otherwise, return the resolved IP. If all hit DNS servers fail to query or `expectIPs` does not match, then the DNS component:\n\n  - By default, it will perform \"DNS fallback query\": use the \"DNS server that has not been used in the last failed query and has a default value of `false` for `skipFallback`\" to perform the query in sequence. If the query fails or `expectIPs` does not match, return an empty resolution; otherwise, return the resolved IP.\n  - If `disableFallback` is set to `true`, \"DNS fallback query\" will not be performed.\n\n- If neither `hosts` nor the `domains` list in DNS servers matches, then:\n\n  - By default, use the \"DNS server that has a default value of `false` for `skipFallback`\" to perform the query in sequence. If the first selected DNS server fails to query or `expectIPs` does not match, then use the next selected DNS server to perform the query. Otherwise, return the resolved IP. If all selected DNS servers fail to query or `expectIPs` does not match, return an empty resolution.\n  - If the number of \"DNS servers that have a default value of `false` for `skipFallback`\" is 0 or `disableFallback` is set to `true`, use the first DNS server in the DNS configuration to perform the query. If the query fails or `expectIPs` does not match, return an empty resolution; otherwise, return the resolved IP.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "DnsObject": {
      "title": "DnsObject",
      "description": "\n`DnsObject` corresponds to the `dns` section in the configuration file.\n\n```json\n{\n  \"dns\": {\n    \"hosts\": {\n      \"baidu.com\": \"127.0.0.1\",\n      \"dns.google\": [\"8.8.8.8\", \"8.8.4.4\"]\n    },\n    \"servers\": [\n      \"8.8.8.8\",\n      \"8.8.4.4\",\n      {\n        \"address\": \"1.2.3.4\",\n        \"port\": 5353,\n        \"domains\": [\"domain:xray.com\"],\n        \"expectIPs\": [\"geoip:cn\"],\n        \"skipFallback\": false,\n        \"clientIP\": \"1.2.3.4\"\n      },\n      {\n        \"address\": \"https://1.1.1.1/dns-query\",\n        \"domains\": [\n          \"geosite:netflix\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv4\"\n      },\n      {\n        \"address\": \"https://1.1.1.1/dns-query\",\n        \"domains\": [\n          \"geosite:openai\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv6\"\n      },\n      \"localhost\"\n    ],\n    \"clientIp\": \"1.2.3.4\",\n    \"queryStrategy\": \"UseIP\",\n    \"disableCache\": false,\n    \"disableFallback\": false,\n    \"disableFallbackIfMatch\": false,\n    \"tag\": \"dns_inbound\"\n  }\n}\n```\n\n",
      "markdownDescription": "\n`DnsObject` corresponds to the `dns` section in the configuration file.\n\n```json\n{\n  \"dns\": {\n    \"hosts\": {\n      \"baidu.com\": \"127.0.0.1\",\n      \"dns.google\": [\"8.8.8.8\", \"8.8.4.4\"]\n    },\n    \"servers\": [\n      \"8.8.8.8\",\n      \"8.8.4.4\",\n      {\n        \"address\": \"1.2.3.4\",\n        \"port\": 5353,\n        \"domains\": [\"domain:xray.com\"],\n        \"expectIPs\": [\"geoip:cn\"],\n        \"skipFallback\": false,\n        \"clientIP\": \"1.2.3.4\"\n      },\n      {\n        \"address\": \"https://1.1.1.1/dns-query\",\n        \"domains\": [\n          \"geosite:netflix\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv4\"\n      },\n      {\n        \"address\": \"https://1.1.1.1/dns-query\",\n        \"domains\": [\n          \"geosite:openai\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv6\"\n      },\n      \"localhost\"\n    ],\n    \"clientIp\": \"1.2.3.4\",\n    \"queryStrategy\": \"UseIP\",\n    \"disableCache\": false,\n    \"disableFallback\": false,\n    \"disableFallbackIfMatch\": false,\n    \"tag\": \"dns_inbound\"\n  }\n}\n```\n\n",
      "properties": {
        "hosts": {
          "name": "hosts",
          "description": "\nA list of static IP addresses, with values consisting of a series of \"domain\": \"address\" or \"domain\": [\"address 1\",\"address 2\"]. The address can be an IP or a domain name. When resolving a domain name, if the domain name matches an item in this list:\n\n- If the address of the item is an IP, the resolution result will be that IP.\n- If the address of the item is a domain name, this domain name will be used for IP resolution instead of the original domain name.\n- If multiple IPs and domain names are set in the address, only the first domain name will be returned, and the rest of the IPs and domain names will be ignored.\n\nThe domain name can take several forms:\n\n- Plain string: When this string matches the target domain name exactly, the rule takes effect. For example, \"xray.com\" matches \"xray.com\" but not \"www.xray.com\".\n- Regular expression: Starting with `\"regexp:\"`, the rest is a regular expression. When this regular expression matches the target domain name, the rule takes effect. For example, \"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com$\" matches \"www.google.com\" and \"fonts.googleapis.com\", but not \"google.com\".\n- Subdomain (recommended): Starting with `\"domain:\"`, the rest is a domain name. When this domain name is the target domain name or its subdomain, the rule takes effect. For example, \"domain:xray.com\" matches \"www.xray.com\" and \"xray.com\", but not \"wxray.com\".\n- Substring: Starting with `\"keyword:\"`, the rest is a string. When this string matches any part of the target domain name, the rule takes effect. For example, \"keyword:sina.com\" can match \"sina.com\", \"sina.com.cn\", and \"www.sina.com\", but not \"sina.cn\".\n- Predefined domain name list: Starting with `\"geosite:\"`, the rest is a name, such as `geosite:google` or `geosite:cn`. The names and domain name lists are listed in [Predefined Domain Name Lists](#predefined-domain-name-lists).\n\n",
          "markdownDescription": "\nA list of static IP addresses, with values consisting of a series of \"domain\": \"address\" or \"domain\": [\"address 1\",\"address 2\"]. The address can be an IP or a domain name. When resolving a domain name, if the domain name matches an item in this list:\n\n- If the address of the item is an IP, the resolution result will be that IP.\n- If the address of the item is a domain name, this domain name will be used for IP resolution instead of the original domain name.\n- If multiple IPs and domain names are set in the address, only the first domain name will be returned, and the rest of the IPs and domain names will be ignored.\n\nThe domain name can take several forms:\n\n- Plain string: When this string matches the target domain name exactly, the rule takes effect. For example, \"xray.com\" matches \"xray.com\" but not \"www.xray.com\".\n- Regular expression: Starting with `\"regexp:\"`, the rest is a regular expression. When this regular expression matches the target domain name, the rule takes effect. For example, \"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com$\" matches \"www.google.com\" and \"fonts.googleapis.com\", but not \"google.com\".\n- Subdomain (recommended): Starting with `\"domain:\"`, the rest is a domain name. When this domain name is the target domain name or its subdomain, the rule takes effect. For example, \"domain:xray.com\" matches \"www.xray.com\" and \"xray.com\", but not \"wxray.com\".\n- Substring: Starting with `\"keyword:\"`, the rest is a string. When this string matches any part of the target domain name, the rule takes effect. For example, \"keyword:sina.com\" can match \"sina.com\", \"sina.com.cn\", and \"www.sina.com\", but not \"sina.cn\".\n- Predefined domain name list: Starting with `\"geosite:\"`, the rest is a name, such as `geosite:google` or `geosite:cn`. The names and domain name lists are listed in [Predefined Domain Name Lists](#predefined-domain-name-lists).\n\n",
          "anyOf": [
            {
              "type": "object"
            },
            {
              "type": "object"
            }
          ]
        },
        "servers": {
          "name": "servers",
          "description": "\nA list of DNS servers that supports two types: DNS addresses (in string format) and [DnsServerObject](#dnsserverobject).\n\nWhen the value is `\"localhost\"`, it means to use the default DNS configuration on the local machine.\n\nWhen the value is a DNS `\"IP:Port\"` address, such as `\"8.8.8.8:53\"`, Xray will use the specified UDP port of this address for DNS queries. The query follows the routing rules. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"tcp://host:port\"`, such as `\"tcp://8.8.8.8:53\"`, Xray will use `DNS over TCP` for queries. The query follows the routing rules. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"tcp+local://host:port\"`, such as `\"tcp+local://8.8.8.8:53\"`, Xray will use `TCP local mode (TCPL)` for queries. That is, DNS requests will not pass through the routing component and will directly request outbound through Freedom, to reduce latency. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"https://host:port/dns-query\"`, such as `\"https://dns.google/dns-query\"`, Xray will use `DNS over HTTPS` (RFC8484, abbreviated as DOH) for queries. Some service providers have certificates with IP aliases, which can be directly written in IP form, such as `https://1.1.1.1/dns-query`. Non-standard ports and paths can also be used, such as `\"https://a.b.c.d:8443/my-dns-query\"`.\n\nWhen the value is in the form of `\"https+local://host:port/dns-query\"`, such as `\"https+local://dns.google/dns-query\"`, Xray will use `DOH local mode (DOHL)` for queries. That is, DOH requests will not pass through the routing component and will directly request outbound through Freedom, to reduce latency. This is generally suitable for use on the server side. Non-standard ports and paths can also be used.\n\nWhen the value is in the form of `\"quic+local://host\"`, such as `\"quic+local://dns.adguard.com\"`, Xray will use `DNS over QUIC local mode (DOQL)` for queries. That is, DNS requests will not pass through the routing component and will directly request outbound through Freedom. This method requires DNS server support for DNS over QUIC. The default port 853 is used for queries, and non-standard ports can also be used.\n\nWhen the value is `fakedns`, the FakeDNS function will be used for queries.\n\n::: tip TIP 1\nWhen using `localhost`, DNS requests on the local machine are not controlled by Xray and additional configuration is required to make DNS requests forwarded by Xray.\n:::\n\n::: tip TIP 2\nDNS clients initialized with different rules will be reflected in the Xray startup log at the `info` level, such as `local DOH`, `remote DOH`, and `udp` modes.\n:::\n\n::: tip TIP 3\n(v1.4.0+) DNS query logging can be enabled in the [log](./log.md).\n:::\n\n",
          "markdownDescription": "\nA list of DNS servers that supports two types: DNS addresses (in string format) and [DnsServerObject](#dnsserverobject).\n\nWhen the value is `\"localhost\"`, it means to use the default DNS configuration on the local machine.\n\nWhen the value is a DNS `\"IP:Port\"` address, such as `\"8.8.8.8:53\"`, Xray will use the specified UDP port of this address for DNS queries. The query follows the routing rules. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"tcp://host:port\"`, such as `\"tcp://8.8.8.8:53\"`, Xray will use `DNS over TCP` for queries. The query follows the routing rules. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"tcp+local://host:port\"`, such as `\"tcp+local://8.8.8.8:53\"`, Xray will use `TCP local mode (TCPL)` for queries. That is, DNS requests will not pass through the routing component and will directly request outbound through Freedom, to reduce latency. When the port is not specified, the default port 53 is used.\n\nWhen the value is in the form of `\"https://host:port/dns-query\"`, such as `\"https://dns.google/dns-query\"`, Xray will use `DNS over HTTPS` (RFC8484, abbreviated as DOH) for queries. Some service providers have certificates with IP aliases, which can be directly written in IP form, such as `https://1.1.1.1/dns-query`. Non-standard ports and paths can also be used, such as `\"https://a.b.c.d:8443/my-dns-query\"`.\n\nWhen the value is in the form of `\"https+local://host:port/dns-query\"`, such as `\"https+local://dns.google/dns-query\"`, Xray will use `DOH local mode (DOHL)` for queries. That is, DOH requests will not pass through the routing component and will directly request outbound through Freedom, to reduce latency. This is generally suitable for use on the server side. Non-standard ports and paths can also be used.\n\nWhen the value is in the form of `\"quic+local://host\"`, such as `\"quic+local://dns.adguard.com\"`, Xray will use `DNS over QUIC local mode (DOQL)` for queries. That is, DNS requests will not pass through the routing component and will directly request outbound through Freedom. This method requires DNS server support for DNS over QUIC. The default port 853 is used for queries, and non-standard ports can also be used.\n\nWhen the value is `fakedns`, the FakeDNS function will be used for queries.\n\n::: tip TIP 1\nWhen using `localhost`, DNS requests on the local machine are not controlled by Xray and additional configuration is required to make DNS requests forwarded by Xray.\n:::\n\n::: tip TIP 2\nDNS clients initialized with different rules will be reflected in the Xray startup log at the `info` level, such as `local DOH`, `remote DOH`, and `udp` modes.\n:::\n\n::: tip TIP 3\n(v1.4.0+) DNS query logging can be enabled in the [log](./log.md).\n:::\n\n",
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              }
            ]
          }
        },
        "clientIp": {
          "name": "clientIp",
          "description": "\nUsed to notify the server of the specified IP location during DNS queries. Cannot be a private address.\n\n::: tip TIP 1\nEDNS Client Subnet support is required for the DNS server.\n:::\n\n::: tip TIP 2\nYou can specify `clientIp` for all DNS servers in [DnsObject](#dnsobject), or specify it for each DNS server in the configuration of [DnsServerObject](#dnsserverobject) (which has higher priority than the configuration in [DnsObject](#dnsobject)).\n:::\n\n",
          "markdownDescription": "\nUsed to notify the server of the specified IP location during DNS queries. Cannot be a private address.\n\n::: tip TIP 1\nEDNS Client Subnet support is required for the DNS server.\n:::\n\n::: tip TIP 2\nYou can specify `clientIp` for all DNS servers in [DnsObject](#dnsobject), or specify it for each DNS server in the configuration of [DnsServerObject](#dnsserverobject) (which has higher priority than the configuration in [DnsObject](#dnsobject)).\n:::\n\n",
          "type": "string"
        },
        "queryStrategy": {
          "name": "queryStrategy",
          "description": "\n`UseIPv4` only queries A records; `UseIPv6` only queries AAAA records. The default value is `UseIP`, which queries both A and AAAA records.\n\nXray-core v1.8.6 New feature: `queryStrategy` can be set separately for each `DNS` server.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv4\" // geosite:netflix's domain name uses \"UseIPv4\"\n            },\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:openai\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // The domain name geosite:openai uses \"UseIPv6\".\n            }\n        ],\n        \"queryStrategy\": \"UseIP\" // Global use of \"UseIP\"\n    }\n```\n\n**NOTE\uff1a**<br>\nWhen the `\"queryStrategy\"` value in the child item conflicts with the global `\"queryStrategy\"` value, the query for the child item will respond null.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://8.8.8.8/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // \"UseIPv6\" conflicts with \"UseIPv4\".\n            }\n        ],\n        \"queryStrategy\": \"UseIPv4\"\n    }\n```\n\nSubterm geosite:netflix query gets null response due to conflicting `\"queryStrategy\"` values. geosite:netflix domain is queried by global DNS `https://1.1.1.1/dns-query` and gets A record.\n\n",
          "markdownDescription": "\n`UseIPv4` only queries A records; `UseIPv6` only queries AAAA records. The default value is `UseIP`, which queries both A and AAAA records.\n\nXray-core v1.8.6 New feature: `queryStrategy` can be set separately for each `DNS` server.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv4\" // geosite:netflix's domain name uses \"UseIPv4\"\n            },\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:openai\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // The domain name geosite:openai uses \"UseIPv6\".\n            }\n        ],\n        \"queryStrategy\": \"UseIP\" // Global use of \"UseIP\"\n    }\n```\n\n**NOTE\uff1a**<br>\nWhen the `\"queryStrategy\"` value in the child item conflicts with the global `\"queryStrategy\"` value, the query for the child item will respond null.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://8.8.8.8/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // \"UseIPv6\" conflicts with \"UseIPv4\".\n            }\n        ],\n        \"queryStrategy\": \"UseIPv4\"\n    }\n```\n\nSubterm geosite:netflix query gets null response due to conflicting `\"queryStrategy\"` values. geosite:netflix domain is queried by global DNS `https://1.1.1.1/dns-query` and gets A record.\n\n",
          "anyOf": [
            {
              "const": "UseIP"
            },
            {
              "const": "UseIPv4"
            },
            {
              "const": "UseIPv6"
            }
          ]
        },
        "disableCache": {
          "name": "disableCache",
          "description": "\n`true` disables DNS caching, default is `false` which means caching is not disabled.\n\n",
          "markdownDescription": "\n`true` disables DNS caching, default is `false` which means caching is not disabled.\n\n",
          "type": "boolean"
        },
        "disableFallback": {
          "name": "disableFallback",
          "description": "\n`true` disables fallback DNS queries, default is `false` which means fallback queries are not disabled.\n\n",
          "markdownDescription": "\n`true` disables fallback DNS queries, default is `false` which means fallback queries are not disabled.\n\n",
          "type": "boolean"
        },
        "disableFallbackIfMatch": {
          "name": "disableFallbackIfMatch",
          "description": "\n`true` disables fallback DNS queries when the matching domain list of the DNS server is hit, default is `false` which means fallback queries are not disabled.\n\n",
          "markdownDescription": "\n`true` disables fallback DNS queries when the matching domain list of the DNS server is hit, default is `false` which means fallback queries are not disabled.\n\n",
          "type": "boolean"
        },
        "tag": {
          "name": "tag",
          "description": "\nTraffic generated by built-in DNS, except for `localhost`, `fakedns`, `TCPL`, `DOHL`, and `DOQL` modes, can be matched with `inboundTag` in routing using this identifier.\n\n",
          "markdownDescription": "\nTraffic generated by built-in DNS, except for `localhost`, `fakedns`, `TCPL`, `DOHL`, and `DOQL` modes, can be matched with `inboundTag` in routing using this identifier.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "DnsServerObject": {
      "title": "DnsServerObject",
      "description": "\n```json\n{\n  \"address\": \"1.2.3.4\",\n  \"port\": 5353,\n  \"domains\": [\"domain:xray.com\"],\n  \"expectIPs\": [\"geoip:cn\"],\n  \"skipFallback\": false,\n  \"clientIP\": \"1.2.3.4\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"address\": \"1.2.3.4\",\n  \"port\": 5353,\n  \"domains\": [\"domain:xray.com\"],\n  \"expectIPs\": [\"geoip:cn\"],\n  \"skipFallback\": false,\n  \"clientIP\": \"1.2.3.4\"\n}\n```\n\n",
      "properties": {
        "address": {
          "name": "address",
          "description": "\nA list of DNS servers, which can be either DNS addresses (in string form) or DnsServerObjects.\n\nWhen the value is `\"localhost\"`, it means using the local DNS configuration.\n\nWhen the value is a DNS `\"IP\"` address, such as `\"8.8.8.8\"`, Xray will use the specified UDP port of this address for DNS queries. The query follows routing rules. By default, port 53 is used.\n\nWhen the value is in the form of `\"tcp://host\"`, such as `\"tcp://8.8.8.8\"`, Xray will use `DNS over TCP` for the query. The query follows routing rules. By default, port 53 is used.\n\nWhen the value is in the form of `\"tcp+local://host\"`, such as `\"tcp+local://8.8.8.8\"`, Xray will use `TCP local mode (TCPL)` for the query. That is, the DNS request will not go through the routing component and will be sent directly through the Freedom outbound to reduce latency. When no port is specified, port 53 is used by default.\n\nWhen the value is in the form of `\"https://host:port/dns-query\"`, such as `\"https://dns.google/dns-query\"`, Xray will use `DNS over HTTPS` (RFC8484, abbreviated as DOH) for the query. Some service providers have IP alias certificates, which can be directly written in IP form, such as `https://1.1.1.1/dns-query`. Non-standard ports and paths can also be used, such as `\"https://a.b.c.d:8443/my-dns-query\"`.\n\nWhen the value is in the form of `\"https+local://host:port/dns-query\"`, such as `\"https+local://dns.google/dns-query\"`, Xray will use `DOH local mode (DOHL)` for the query, which means that the DOH request will not go through the routing component and will be sent directly through the Freedom outbound to reduce latency. This is generally suitable for server-side use. Non-standard ports and paths can also be used.\n\nWhen the value is in the form of `\"quic+local://host:port\"`, such as `\"quic+local://dns.adguard.com\"`, Xray will use `DOQ local mode (DOQL)` for the query, which means that the DNS request will not go through the routing component and will be sent directly through the Freedom outbound. This method requires DNS server support for DNS over QUIC. By default, port 853 is used for the query, and non-standard ports can be used.\n\nWhen the value is `fakedns`, FakeDNS functionality will be used for the query.\n\n",
          "markdownDescription": "\nA list of DNS servers, which can be either DNS addresses (in string form) or DnsServerObjects.\n\nWhen the value is `\"localhost\"`, it means using the local DNS configuration.\n\nWhen the value is a DNS `\"IP\"` address, such as `\"8.8.8.8\"`, Xray will use the specified UDP port of this address for DNS queries. The query follows routing rules. By default, port 53 is used.\n\nWhen the value is in the form of `\"tcp://host\"`, such as `\"tcp://8.8.8.8\"`, Xray will use `DNS over TCP` for the query. The query follows routing rules. By default, port 53 is used.\n\nWhen the value is in the form of `\"tcp+local://host\"`, such as `\"tcp+local://8.8.8.8\"`, Xray will use `TCP local mode (TCPL)` for the query. That is, the DNS request will not go through the routing component and will be sent directly through the Freedom outbound to reduce latency. When no port is specified, port 53 is used by default.\n\nWhen the value is in the form of `\"https://host:port/dns-query\"`, such as `\"https://dns.google/dns-query\"`, Xray will use `DNS over HTTPS` (RFC8484, abbreviated as DOH) for the query. Some service providers have IP alias certificates, which can be directly written in IP form, such as `https://1.1.1.1/dns-query`. Non-standard ports and paths can also be used, such as `\"https://a.b.c.d:8443/my-dns-query\"`.\n\nWhen the value is in the form of `\"https+local://host:port/dns-query\"`, such as `\"https+local://dns.google/dns-query\"`, Xray will use `DOH local mode (DOHL)` for the query, which means that the DOH request will not go through the routing component and will be sent directly through the Freedom outbound to reduce latency. This is generally suitable for server-side use. Non-standard ports and paths can also be used.\n\nWhen the value is in the form of `\"quic+local://host:port\"`, such as `\"quic+local://dns.adguard.com\"`, Xray will use `DOQ local mode (DOQL)` for the query, which means that the DNS request will not go through the routing component and will be sent directly through the Freedom outbound. This method requires DNS server support for DNS over QUIC. By default, port 853 is used for the query, and non-standard ports can be used.\n\nWhen the value is `fakedns`, FakeDNS functionality will be used for the query.\n\n",
          "type": "string"
        },
        "port": {
          "name": "port",
          "description": "\nThe port number of the DNS server, such as `53`. If not specified, the default is `53`. This item is not applicable when using DOH, DOHL, or DOQL modes, and non-standard ports should be specified in the URL.\n\n",
          "markdownDescription": "\nThe port number of the DNS server, such as `53`. If not specified, the default is `53`. This item is not applicable when using DOH, DOHL, or DOQL modes, and non-standard ports should be specified in the URL.\n\n",
          "type": "number"
        },
        "domains": {
          "name": "domains",
          "description": "\nA list of domain names. The domain names in this list will be queried using this server first. The format of domain names is the same as in [routing configuration](./routing.md#ruleobject).\n\n",
          "markdownDescription": "\nA list of domain names. The domain names in this list will be queried using this server first. The format of domain names is the same as in [routing configuration](./routing.md#ruleobject).\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "expectIPs": {
          "name": "expectIPs",
          "description": "\nA list of IP ranges in the same format as in [routing configuration](./routing.md#ruleobject).\n\nWhen this item is configured, Xray DNS will verify the returned IP addresses and only return addresses that are included in the `expectIPs` list.\n\nIf this item is not configured, the IP address will be returned as is.\n\n",
          "markdownDescription": "\nA list of IP ranges in the same format as in [routing configuration](./routing.md#ruleobject).\n\nWhen this item is configured, Xray DNS will verify the returned IP addresses and only return addresses that are included in the `expectIPs` list.\n\nIf this item is not configured, the IP address will be returned as is.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "skipFallback": {
          "name": "skipFallback",
          "description": "\n`true` means to skip this server when performing DNS fallback queries, and the default is `false`, which means not to skip.\n# API Interface\n\nAPI interface configuration provides a set of APIs based on [gRPC](https://grpc.io/) for remote invocation.\n\nThe interface can be enabled through the api configuration module. When the api configuration is enabled, Xray will create an outbound proxy automatically. All incoming API connections need to be manually routed to this outbound proxy through [routing rule configuration](./routing.md).\n\nPlease refer to the [related configuration](#related-configuration) in this section.\n\n::: warning\nMost users do not need to use this API. Novices can ignore this page entirely.\n:::\n\n",
          "markdownDescription": "\n`true` means to skip this server when performing DNS fallback queries, and the default is `false`, which means not to skip.\n# API Interface\n\nAPI interface configuration provides a set of APIs based on [gRPC](https://grpc.io/) for remote invocation.\n\nThe interface can be enabled through the api configuration module. When the api configuration is enabled, Xray will create an outbound proxy automatically. All incoming API connections need to be manually routed to this outbound proxy through [routing rule configuration](./routing.md).\n\nPlease refer to the [related configuration](#related-configuration) in this section.\n\n::: warning\nMost users do not need to use this API. Novices can ignore this page entirely.\n:::\n\n",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "ApiObject": {
      "title": "ApiObject",
      "description": "\n`ApiObject` corresponds to the `api` item in the configuration file.\n\n```json\n{\n  \"api\": {\n    \"tag\": \"api\",\n    \"listen\": \"127.0.0.1:8080\",\n    \"services\": [\"HandlerService\", \"LoggerService\", \"StatsService\"]\n  }\n}\n```\n\n",
      "markdownDescription": "\n`ApiObject` corresponds to the `api` item in the configuration file.\n\n```json\n{\n  \"api\": {\n    \"tag\": \"api\",\n    \"listen\": \"127.0.0.1:8080\",\n    \"services\": [\"HandlerService\", \"LoggerService\", \"StatsService\"]\n  }\n}\n```\n\n",
      "properties": {
        "tag": {
          "name": "tag",
          "description": "\nOutbound proxy identifier.\n\n",
          "markdownDescription": "\nOutbound proxy identifier.\n\n",
          "type": "string"
        },
        "listen": {
          "name": "listen",
          "description": "\nThe IP and port that the API service listens on. This is an optional configuration item.\n\nWhen you omit this item, you need to add inbounds and routing configurations according to the examples in the [relevant configurations below](#related-configuration).\n\n\n",
          "markdownDescription": "\nThe IP and port that the API service listens on. This is an optional configuration item.\n\nWhen you omit this item, you need to add inbounds and routing configurations according to the examples in the [relevant configurations below](#related-configuration).\n\n\n",
          "type": "string"
        },
        "services": {
          "name": "services",
          "description": "\nList of enabled APIs, optional values can be found in [Supported API List](#supported-api-list).\n\n",
          "markdownDescription": "\nList of enabled APIs, optional values can be found in [Supported API List](#supported-api-list).\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "Related Configuration": {
      "title": "Related Configuration",
      "description": "\nAn api inbound can be added to the inbounds configuration.\n\n```json\n\"inbounds\": [\n  {\n    \"listen\": \"127.0.0.1\",\n    \"port\": 10085,\n    \"protocol\": \"dokodemo-door\",\n    \"settings\": {\n      \"address\": \"127.0.0.1\"\n    },\n    \"tag\": \"api\"\n  }\n]\n```\n\nAdd routing rules for the api inbound in the routing configuration.\n\n```json\n\"routing\": {\n  \"rules\": [\n    {\n      \"inboundTag\": [\n        \"api\"\n      ],\n      \"outboundTag\": \"api\",\n      \"type\": \"field\"\n    }\n  ]\n}\n```\n\nAdd api to basic configuration\n\n```\n\"api\": {\n  \"tag\": \"api\",\n  \"services\": [\n    \"StatsService\"\n  ]\n}\n```\n\n\n",
      "markdownDescription": "\nAn api inbound can be added to the inbounds configuration.\n\n```json\n\"inbounds\": [\n  {\n    \"listen\": \"127.0.0.1\",\n    \"port\": 10085,\n    \"protocol\": \"dokodemo-door\",\n    \"settings\": {\n      \"address\": \"127.0.0.1\"\n    },\n    \"tag\": \"api\"\n  }\n]\n```\n\nAdd routing rules for the api inbound in the routing configuration.\n\n```json\n\"routing\": {\n  \"rules\": [\n    {\n      \"inboundTag\": [\n        \"api\"\n      ],\n      \"outboundTag\": \"api\",\n      \"type\": \"field\"\n    }\n  ]\n}\n```\n\nAdd api to basic configuration\n\n```\n\"api\": {\n  \"tag\": \"api\",\n  \"services\": [\n    \"StatsService\"\n  ]\n}\n```\n\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Supported API List": {
      "title": "Supported API List",
      "description": "\n",
      "markdownDescription": "\n",
      "properties": {},
      "additionalProperties": true
    },
    "HandlerService": {
      "title": "HandlerService",
      "description": "\nAPIs that modify the inbound and outbound proxies, with the following available functions:\n\n- Add a new inbound proxy;\n- Add a new outbound proxy;\n- Delete an existing inbound proxy;\n- Delete an existing outbound proxy;\n- Add a user to an inbound proxy (VMess, VLESS, Trojan, and Shadowsocks(v1.3.0+) only);\n- Delete a user from an inbound proxy (VMess, VLESS, Trojan, and Shadowsocks(v1.3.0+) only);\n\n",
      "markdownDescription": "\nAPIs that modify the inbound and outbound proxies, with the following available functions:\n\n- Add a new inbound proxy;\n- Add a new outbound proxy;\n- Delete an existing inbound proxy;\n- Delete an existing outbound proxy;\n- Add a user to an inbound proxy (VMess, VLESS, Trojan, and Shadowsocks(v1.3.0+) only);\n- Delete a user from an inbound proxy (VMess, VLESS, Trojan, and Shadowsocks(v1.3.0+) only);\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "RoutingService": {
      "title": "RoutingService",
      "description": "\nAPI for adding, deleting, and replacing routing rules and querying equalizer statistics. The available functions are as follows:\n\n* `adrules` adds and replaces routing configuration\n* `rmrules` delete routing rules\n* `sib` Disconnect source IP\n* `bi` Query equalizer statistics\n* `bo` Forces the equalizer to select the specified outboundTag\n\nYou can use something like `./xray help api bi` to query the specific usage.\n\n",
      "markdownDescription": "\nAPI for adding, deleting, and replacing routing rules and querying equalizer statistics. The available functions are as follows:\n\n* `adrules` adds and replaces routing configuration\n* `rmrules` delete routing rules\n* `sib` Disconnect source IP\n* `bi` Query equalizer statistics\n* `bo` Forces the equalizer to select the specified outboundTag\n\nYou can use something like `./xray help api bi` to query the specific usage.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "LoggerService": {
      "title": "LoggerService",
      "description": "\nSupports restarting the built-in logger, which can be used in conjunction with logrotate to perform operations on log files.\n\n",
      "markdownDescription": "\nSupports restarting the built-in logger, which can be used in conjunction with logrotate to perform operations on log files.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "StatsService": {
      "title": "StatsService",
      "description": "\nBuilt-in data statistics service, see [Statistics Information](./stats.md) for details.\n\n",
      "markdownDescription": "\nBuilt-in data statistics service, see [Statistics Information](./stats.md) for details.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "ReflectionService": {
      "title": "ReflectionService",
      "description": "\nSupports gRPC clients to obtain the list of APIs from the server.\n\n```bash\n$ grpcurl -plaintext localhost:10085 list\ngrpc.reflection.v1alpha.ServerReflection\nv2ray.core.app.proxyman.command.HandlerService\nv2ray.core.app.stats.command.StatsService\nxray.app.proxyman.command.HandlerService\nxray.app.stats.command.StatsService\n```\n\n",
      "markdownDescription": "\nSupports gRPC clients to obtain the list of APIs from the server.\n\n```bash\n$ grpcurl -plaintext localhost:10085 list\ngrpc.reflection.v1alpha.ServerReflection\nv2ray.core.app.proxyman.command.HandlerService\nv2ray.core.app.stats.command.StatsService\nxray.app.proxyman.command.HandlerService\nxray.app.stats.command.StatsService\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "API Calling Example": {
      "title": "API Calling Example",
      "description": "\n[Xray-API-documents](https://github.com/XTLS/Xray-API-documents) @crossfw\n# Transport\n\nTransports specify how Xray communicates with peers.\n\nTransports specify how to achieve stable data transmission. Both ends of a connection often need to specify the same transport protocol to successfully establish a connection. Like, if one end uses WebSocket, the other end must also use WebSocket, or else the connection cannot be established.\n\n",
      "markdownDescription": "\n[Xray-API-documents](https://github.com/XTLS/Xray-API-documents) @crossfw\n# Transport\n\nTransports specify how Xray communicates with peers.\n\nTransports specify how to achieve stable data transmission. Both ends of a connection often need to specify the same transport protocol to successfully establish a connection. Like, if one end uses WebSocket, the other end must also use WebSocket, or else the connection cannot be established.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "StreamSettingsObject": {
      "title": "StreamSettingsObject",
      "description": "\n`StreamSettingsObject` corresponds to the `streamSettings` property in the inbound or outbound config. Each inbound or outbound can be configured with different transports and can use `streamSettings` to specify local configs.\n\n```json\n{\n  \"network\": \"tcp\",\n  \"security\": \"none\",\n  \"tlsSettings\": {},\n  \"realitySettings\": {},\n  \"tcpSettings\": {},\n  \"kcpSettings\": {},\n  \"wsSettings\": {},\n  \"httpSettings\": {},\n  \"grpcSettings\": {},\n  \"httpupgradeSettings\": {},\n  \"xhttpSettings\": {},\n  \"sockopt\": {\n    \"mark\": 0,\n    \"tcpMaxSeg\": 1440,\n    \"tcpFastOpen\": false,\n    \"tproxy\": \"off\",\n    \"domainStrategy\": \"AsIs\",\n    \"dialerProxy\": \"\",\n    \"acceptProxyProtocol\": false,\n    \"tcpKeepAliveInterval\": 0,\n    \"tcpKeepAliveIdle\": 300,\n    \"tcpUserTimeout\": 10000,\n    \"tcpCongestion\": \"bbr\",\n    \"interface\": \"wg0\",\n    \"v6only\": false,\n    \"tcpWindowClamp\": 600,\n    \"tcpMptcp\": false,\n    \"tcpNoDelay\": false\n  }\n}\n```\n\n",
      "markdownDescription": "\n`StreamSettingsObject` corresponds to the `streamSettings` property in the inbound or outbound config. Each inbound or outbound can be configured with different transports and can use `streamSettings` to specify local configs.\n\n```json\n{\n  \"network\": \"tcp\",\n  \"security\": \"none\",\n  \"tlsSettings\": {},\n  \"realitySettings\": {},\n  \"tcpSettings\": {},\n  \"kcpSettings\": {},\n  \"wsSettings\": {},\n  \"httpSettings\": {},\n  \"grpcSettings\": {},\n  \"httpupgradeSettings\": {},\n  \"xhttpSettings\": {},\n  \"sockopt\": {\n    \"mark\": 0,\n    \"tcpMaxSeg\": 1440,\n    \"tcpFastOpen\": false,\n    \"tproxy\": \"off\",\n    \"domainStrategy\": \"AsIs\",\n    \"dialerProxy\": \"\",\n    \"acceptProxyProtocol\": false,\n    \"tcpKeepAliveInterval\": 0,\n    \"tcpKeepAliveIdle\": 300,\n    \"tcpUserTimeout\": 10000,\n    \"tcpCongestion\": \"bbr\",\n    \"interface\": \"wg0\",\n    \"v6only\": false,\n    \"tcpWindowClamp\": 600,\n    \"tcpMptcp\": false,\n    \"tcpNoDelay\": false\n  }\n}\n```\n\n",
      "properties": {
        "network": {
          "name": "network",
          "description": "\nThe underlying protocol of the transport used by the data stream of the connection, defaulting to `\"tcp\"`.\n\n",
          "markdownDescription": "\nThe underlying protocol of the transport used by the data stream of the connection, defaulting to `\"tcp\"`.\n\n",
          "anyOf": [
            {
              "const": "tcp"
            },
            {
              "const": "kcp"
            },
            {
              "const": "ws"
            },
            {
              "const": "http"
            },
            {
              "const": "grpc"
            },
            {
              "const": "httpupgrade"
            },
            {
              "const": "xhttp"
            }
          ]
        },
        "security": {
          "name": "security",
          "description": "\nWhether to enable transport layer encryption. Supported options below.\n\n- `\"none\"` enables no encryption (default).\n- `\"tls\"` enables encryption with [TLS](https://en.wikipedia.org/wiki/transport_Layer_Security).\n- `\"reality\"` enables encryption with REALITY.\n\n",
          "markdownDescription": "\nWhether to enable transport layer encryption. Supported options below.\n\n- `\"none\"` enables no encryption (default).\n- `\"tls\"` enables encryption with [TLS](https://en.wikipedia.org/wiki/transport_Layer_Security).\n- `\"reality\"` enables encryption with REALITY.\n\n",
          "anyOf": [
            {
              "const": "none"
            },
            {
              "const": "tls"
            },
            {
              "const": "reality"
            }
          ]
        },
        "tlsSettings": {
          "name": "tlsSettings",
          "description": "\nConfigures vanilla TLS. The TLS encryption suite is provided by Golang, which often uses TLS 1.3, and has no support for DTLS.\n\n",
          "markdownDescription": "\nConfigures vanilla TLS. The TLS encryption suite is provided by Golang, which often uses TLS 1.3, and has no support for DTLS.\n\n",
          "$ref": "#/definitions/TLSObject"
        },
        "realitySettings": {
          "name": "realitySettings",
          "description": "\nConfigures REALITY. REALITY is a piece of advanced encryption technology developed in-house, with higher security than vanilla TLS, but configs of both are largely the same.\n\n::: tip\nREALITY is by far the most secure transport encryption solution, perfectly mimicking normal web browsing when observed. Enabling REALITY with appropriate XTLS Vision flow control schemes has the potential of reaching magnitudes of performance boosts.\n:::\n\n",
          "markdownDescription": "\nConfigures REALITY. REALITY is a piece of advanced encryption technology developed in-house, with higher security than vanilla TLS, but configs of both are largely the same.\n\n::: tip\nREALITY is by far the most secure transport encryption solution, perfectly mimicking normal web browsing when observed. Enabling REALITY with appropriate XTLS Vision flow control schemes has the potential of reaching magnitudes of performance boosts.\n:::\n\n",
          "$ref": "#/definitions/RealityObject"
        },
        "tcpSettings": {
          "name": "tcpSettings",
          "description": "\nConfigures the current TCP connection. Valid only when TCP is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current TCP connection. Valid only when TCP is used. Same schema as global.\n\n",
          "$ref": "#/definitions/TcpObject"
        },
        "kcpSettings": {
          "name": "kcpSettings",
          "description": "\nConfigures the current mKCP connection. Valid only when mKCP is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current mKCP connection. Valid only when mKCP is used. Same schema as global.\n\n",
          "$ref": "#/definitions/KcpObject"
        },
        "wsSettings": {
          "name": "wsSettings",
          "description": "\nConfigures the current WebSocket connection. Valid only when WebSocket is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current WebSocket connection. Valid only when WebSocket is used. Same schema as global.\n\n",
          "$ref": "#/definitions/WebSocketObject"
        },
        "httpSettings": {
          "name": "httpSettings",
          "description": "\nConfigures the current HTTP/2 connection. Valid only when HTTP/2 is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current HTTP/2 connection. Valid only when HTTP/2 is used. Same schema as global.\n\n",
          "$ref": "#/definitions/HttpObject"
        },
        "grpcSettings": {
          "name": "grpcSettings",
          "description": "\nConfigures the current gRPC connection. Valid only when gRPC is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current gRPC connection. Valid only when gRPC is used. Same schema as global.\n\n",
          "$ref": "#/definitions/GRPCObject"
        },
        "httpupgradeSettings": {
          "name": "httpupgradeSettings",
          "description": "\nConfigures the current HTTPUpgrade connection. Valid only when HTTPUpgrade is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures the current HTTPUpgrade connection. Valid only when HTTPUpgrade is used. Same schema as global.\n\n",
          "$ref": "#/definitions/HttpUpgradeObject"
        },
        "xhttpSettings": {
          "name": "xhttpSettings",
          "description": "\nConfigures XHTTP connections. Valid only when XHTTP is used. Same schema as global.\n\n",
          "markdownDescription": "\nConfigures XHTTP connections. Valid only when XHTTP is used. Same schema as global.\n\n",
          "$ref": "#/definitions/XHttpObject"
        },
        "sockopt": {
          "name": "sockopt",
          "description": "\nConfigures transparent proxies.\n\n",
          "markdownDescription": "\nConfigures transparent proxies.\n\n",
          "$ref": "#/definitions/SockoptObject"
        }
      },
      "additionalProperties": false
    },
    "TLSObject": {
      "title": "TLSObject",
      "description": "\n```json\n{\n  \"serverName\": \"xray.com\",\n  \"rejectUnknownSni\": false,\n  \"allowInsecure\": false,\n  \"alpn\": [\"h2\", \"http/1.1\"],\n  \"minVersion\": \"1.2\",\n  \"maxVersion\": \"1.3\",\n  \"cipherSuites\": \"Specify encryption suites here, separated by :\",\n  \"certificates\": [],\n  \"disableSystemRoot\": false,\n  \"enableSessionResumption\": false,\n  \"fingerprint\": \"\",\n  \"pinnedPeerCertificateChainSha256\": [\"\"],\n  \"masterKeyLog\": \"\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"serverName\": \"xray.com\",\n  \"rejectUnknownSni\": false,\n  \"allowInsecure\": false,\n  \"alpn\": [\"h2\", \"http/1.1\"],\n  \"minVersion\": \"1.2\",\n  \"maxVersion\": \"1.3\",\n  \"cipherSuites\": \"Specify encryption suites here, separated by :\",\n  \"certificates\": [],\n  \"disableSystemRoot\": false,\n  \"enableSessionResumption\": false,\n  \"fingerprint\": \"\",\n  \"pinnedPeerCertificateChainSha256\": [\"\"],\n  \"masterKeyLog\": \"\"\n}\n```\n\n",
      "properties": {
        "serverName": {
          "name": "serverName",
          "description": "\nSpecifies the domain of the server-side certificate, useful when connecting only via IP addresses.\n\nWhen the target is specified by domains, like when the domain is received by SOCKS inbounds or detected via sniffing, the extracted domain will automatically be used as `serverName`, without any need for manual configuration.\n\n",
          "markdownDescription": "\nSpecifies the domain of the server-side certificate, useful when connecting only via IP addresses.\n\nWhen the target is specified by domains, like when the domain is received by SOCKS inbounds or detected via sniffing, the extracted domain will automatically be used as `serverName`, without any need for manual configuration.\n\n",
          "type": "string"
        },
        "rejectUnknownSni": {
          "name": "rejectUnknownSni",
          "description": "\nWhen `true`, the server rejects TLS handshakes if the SNI received does not match domains specified in the certificate. The default value is `false`.\n\n",
          "markdownDescription": "\nWhen `true`, the server rejects TLS handshakes if the SNI received does not match domains specified in the certificate. The default value is `false`.\n\n",
          "type": "boolean"
        },
        "alpn": {
          "name": "alpn",
          "description": "\nAn array of strings specifying the ALPN values used in TLS handshakes. Defaults to `[\"h2\", \"http/1.1\"]`.\n\n",
          "markdownDescription": "\nAn array of strings specifying the ALPN values used in TLS handshakes. Defaults to `[\"h2\", \"http/1.1\"]`.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "minVersion": {
          "name": "minVersion",
          "description": "\n`minVersion` specifies the minimum SSL/TLS version accepted.\n\n",
          "markdownDescription": "\n`minVersion` specifies the minimum SSL/TLS version accepted.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "maxVersion": {
          "name": "maxVersion",
          "description": "\n`maxVersion` specifies the maximum SSL/TLS version accepted.\n\n",
          "markdownDescription": "\n`maxVersion` specifies the maximum SSL/TLS version accepted.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "cipherSuites": {
          "name": "cipherSuites",
          "description": "\n`CipherSuites` specifies a list of supported cryptographic suites, with names of each separated by a colon.\n\nYou can find the names and descriptions of encryption suites in Go [here](https://golang.org/src/crypto/tls/cipher_suites.go#L500) or [here](https://golang.org/src/crypto/tls/cipher_suites.go#L44).\n\n::: danger\nThe above two configs are optional and do not have impact on security under normal circumstances. When not configured, Go will select the parameters automatically on a per-device basis. If you are not familiar with these configs, leave them as is, or you will bear consequences of potential problems caused by your improper configuration.\n:::\n\n",
          "markdownDescription": "\n`CipherSuites` specifies a list of supported cryptographic suites, with names of each separated by a colon.\n\nYou can find the names and descriptions of encryption suites in Go [here](https://golang.org/src/crypto/tls/cipher_suites.go#L500) or [here](https://golang.org/src/crypto/tls/cipher_suites.go#L44).\n\n::: danger\nThe above two configs are optional and do not have impact on security under normal circumstances. When not configured, Go will select the parameters automatically on a per-device basis. If you are not familiar with these configs, leave them as is, or you will bear consequences of potential problems caused by your improper configuration.\n:::\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "allowInsecure": {
          "name": "allowInsecure",
          "description": "\nWhether to allow insecure connections (client-only). Defaults to `false`.\n\nWhen `true`, Xray will not verify the validity of the TLS certificate provided by the outbound.\n\n::: danger\nThis should not be set to `true` in deployments for security reaons, or it can be susceptible to man-in-the-middle attacks.\n:::\n\n",
          "markdownDescription": "\nWhether to allow insecure connections (client-only). Defaults to `false`.\n\nWhen `true`, Xray will not verify the validity of the TLS certificate provided by the outbound.\n\n::: danger\nThis should not be set to `true` in deployments for security reaons, or it can be susceptible to man-in-the-middle attacks.\n:::\n\n",
          "type": "boolean"
        },
        "disableSystemRoot": {
          "name": "disableSystemRoot",
          "description": "\nWhether to disable the CA certificates provided by the operating system. Defaults to `false`.\n\nWhen `true`, Xray will only use the certificates specified in `certificates` for TLS handshakes. When `false`, Xray will only use the CA certificates provided by the operating system for TLS handshakes.\n\n",
          "markdownDescription": "\nWhether to disable the CA certificates provided by the operating system. Defaults to `false`.\n\nWhen `true`, Xray will only use the certificates specified in `certificates` for TLS handshakes. When `false`, Xray will only use the CA certificates provided by the operating system for TLS handshakes.\n\n",
          "type": "boolean"
        },
        "enableSessionResumption": {
          "name": "enableSessionResumption",
          "description": "\nWhen `false`, the `session_ticket` extension will not be included in ClientHello. Oftentimes the ClientHello in Go programs does not have this extension enabled, so it is recommended to leave it as-is. Defaults to `false`.\n\n",
          "markdownDescription": "\nWhen `false`, the `session_ticket` extension will not be included in ClientHello. Oftentimes the ClientHello in Go programs does not have this extension enabled, so it is recommended to leave it as-is. Defaults to `false`.\n\n",
          "type": "boolean"
        },
        "fingerprint": {
          "name": "fingerprint",
          "description": "\nSpecifies the fingerprint of the `TLS Client Hello` message. When empty, fingerprint simulation will not be enabled. When enabled, Xray will **simulate** the `TLS` fingerprint through the uTLS library or have it generated randomly. Three types of options are supported:\n\n1. Simulate TLS fingerprints of the latest versions of popular browsers, including:\n\n- `\"chrome\"`\n- `\"firefox\"`\n- `\"safari\"`\n- `\"ios\"`\n- `\"android\"`\n- `\"edge\"`\n- `\"360\"`\n- `\"qq\"`\n\n1. Have a fingerprint generated automatically when xray starts\n\n- `\"random\"`: randomly select one of the up-to-date browsers\n- `\"randomized\"`: generate a completely random and unique fingerprint (100% compatible with TLS 1.3 using X25519)\n\n1. Use uTLS native fingerprint variable names, such as `\"HelloRandomizedNoALPN\"` `\"HelloChrome_106_Shuffle\"`. See the full list in the [uTLS library](https://github.com/refraction-networking/utls/blob/master/u_common.go#L162).\n\n::: tip\nThis feature only **simulates** the fingerprint of `TLS Client Hello` message, leaving other behaviours the same as vanilla Go TLS. If you want to simulate a browser `TLS` more completely, use the [Browser Dialer](./transports/websocket.md#browser-dialer).\n:::\n\n::: tip\nWhen using this feature, some TLS options that affect the TLS fingerprint will be overridden by the utls library and will no longer be effective, such as ALPN.\nThe parameters that will be passed are\n`\"serverName\" \"allowInsecure\" \"disableSystemRoot\" \"pinnedPeerCertificateChainSha256\" \"masterKeyLog\"`\n:::\n\n",
          "markdownDescription": "\nSpecifies the fingerprint of the `TLS Client Hello` message. When empty, fingerprint simulation will not be enabled. When enabled, Xray will **simulate** the `TLS` fingerprint through the uTLS library or have it generated randomly. Three types of options are supported:\n\n1. Simulate TLS fingerprints of the latest versions of popular browsers, including:\n\n- `\"chrome\"`\n- `\"firefox\"`\n- `\"safari\"`\n- `\"ios\"`\n- `\"android\"`\n- `\"edge\"`\n- `\"360\"`\n- `\"qq\"`\n\n1. Have a fingerprint generated automatically when xray starts\n\n- `\"random\"`: randomly select one of the up-to-date browsers\n- `\"randomized\"`: generate a completely random and unique fingerprint (100% compatible with TLS 1.3 using X25519)\n\n1. Use uTLS native fingerprint variable names, such as `\"HelloRandomizedNoALPN\"` `\"HelloChrome_106_Shuffle\"`. See the full list in the [uTLS library](https://github.com/refraction-networking/utls/blob/master/u_common.go#L162).\n\n::: tip\nThis feature only **simulates** the fingerprint of `TLS Client Hello` message, leaving other behaviours the same as vanilla Go TLS. If you want to simulate a browser `TLS` more completely, use the [Browser Dialer](./transports/websocket.md#browser-dialer).\n:::\n\n::: tip\nWhen using this feature, some TLS options that affect the TLS fingerprint will be overridden by the utls library and will no longer be effective, such as ALPN.\nThe parameters that will be passed are\n`\"serverName\" \"allowInsecure\" \"disableSystemRoot\" \"pinnedPeerCertificateChainSha256\" \"masterKeyLog\"`\n:::\n\n",
          "type": "string"
        },
        "pinnedPeerCertificateChainSha256": {
          "name": "pinnedPeerCertificateChainSha256",
          "description": "\nSpecifies the SHA256 hash values of the certificate chain of the remote server, using the standard encoding format. Only when the hash value of the server-side certificate chain matches any of the specified can a TLS connection be successfully established.\n\nWhen the connection fails with this active, the hash value of the remote certificate will be shown.\n\n::: danger\nIt is not recommended to use this method to obtain the hash value of the certificate chain, because in this case, there will be no opportunity to verify whether the certificate provided by the server at this time is a real certificate, and it cannot be guaranteed that the obtained certificate hash value is the expected hash value.\n:::\n\n::: tip\nIf you need to obtain the hash value of the certificate, run `xray tls certChainHash --cert <cert.pem>` in the command line, where `<cert.pem>` is replaced by the actual certificate file path.\n:::\n\n",
          "markdownDescription": "\nSpecifies the SHA256 hash values of the certificate chain of the remote server, using the standard encoding format. Only when the hash value of the server-side certificate chain matches any of the specified can a TLS connection be successfully established.\n\nWhen the connection fails with this active, the hash value of the remote certificate will be shown.\n\n::: danger\nIt is not recommended to use this method to obtain the hash value of the certificate chain, because in this case, there will be no opportunity to verify whether the certificate provided by the server at this time is a real certificate, and it cannot be guaranteed that the obtained certificate hash value is the expected hash value.\n:::\n\n::: tip\nIf you need to obtain the hash value of the certificate, run `xray tls certChainHash --cert <cert.pem>` in the command line, where `<cert.pem>` is replaced by the actual certificate file path.\n:::\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "certificates": {
          "name": "certificates",
          "description": "\nA list of certificates, each representing a single certificate (fullchain recommended).\n\n::: tip\nIf you want to achieve A/A+ rating in SSLLabs or MySSL tests, visit [here](https://github.com/XTLS/Xray-core/discussions/56#discussioncomment-215600) for further information.\n:::\n\n",
          "markdownDescription": "\nA list of certificates, each representing a single certificate (fullchain recommended).\n\n::: tip\nIf you want to achieve A/A+ rating in SSLLabs or MySSL tests, visit [here](https://github.com/XTLS/Xray-core/discussions/56#discussioncomment-215600) for further information.\n:::\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/CertificateObject"
          }
        },
        "masterKeyLog": {
          "name": "masterKeyLog",
          "description": "\nPath to the (Pre-)Master-Secret log file. Can be used by sniffers like WireShark to decrypt TLS connections managed by Xray. Cannot be used with uTLS at the moment, and requires Xray-core v.8.7 or later.\n\n",
          "markdownDescription": "\nPath to the (Pre-)Master-Secret log file. Can be used by sniffers like WireShark to decrypt TLS connections managed by Xray. Cannot be used with uTLS at the moment, and requires Xray-core v.8.7 or later.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "RealityObject": {
      "title": "RealityObject",
      "description": "\n```json\n{\n  \"show\": false,\n  \"dest\": \"example.com:443\",\n  \"xver\": 0,\n  \"serverNames\": [\"example.com\", \"www.example.com\"],\n  \"privateKey\": \"\",\n  \"minClientVer\": \"\",\n  \"maxClientVer\": \"\",\n  \"maxTimeDiff\": 0,\n  \"shortIds\": [\"\", \"0123456789abcdef\"],\n  \"fingerprint\": \"chrome\",\n  \"serverName\": \"\",\n  \"publicKey\": \"\",\n  \"shortId\": \"\",\n  \"spiderX\": \"\"\n}\n```\n\n::: tip\nFurther information available in the [REALITY project repo](https://github.com/XTLS/REALITY).\n:::\n\n",
      "markdownDescription": "\n```json\n{\n  \"show\": false,\n  \"dest\": \"example.com:443\",\n  \"xver\": 0,\n  \"serverNames\": [\"example.com\", \"www.example.com\"],\n  \"privateKey\": \"\",\n  \"minClientVer\": \"\",\n  \"maxClientVer\": \"\",\n  \"maxTimeDiff\": 0,\n  \"shortIds\": [\"\", \"0123456789abcdef\"],\n  \"fingerprint\": \"chrome\",\n  \"serverName\": \"\",\n  \"publicKey\": \"\",\n  \"shortId\": \"\",\n  \"spiderX\": \"\"\n}\n```\n\n::: tip\nFurther information available in the [REALITY project repo](https://github.com/XTLS/REALITY).\n:::\n\n",
      "properties": {
        "show": {
          "name": "show",
          "description": "\nEmits verbose logs when `true`.\n\n::: tip\n**Inbound** (**server-side**) configs below.\n:::\n\n",
          "markdownDescription": "\nEmits verbose logs when `true`.\n\n::: tip\n**Inbound** (**server-side**) configs below.\n:::\n\n",
          "type": "boolean"
        },
        "dest": {
          "name": "dest",
          "description": "\nRequired. Same schema as [dest](./features/fallback.md#fallbackobject) in VLESS `fallbacks`.\n\n",
          "markdownDescription": "\nRequired. Same schema as [dest](./features/fallback.md#fallbackobject) in VLESS `fallbacks`.\n\n",
          "type": "string"
        },
        "xver": {
          "name": "xver",
          "description": "\nOptional. Same schema as [xver](./features/fallback.md#fallbackobject) in VLESS `fallbacks`.\n\n",
          "markdownDescription": "\nOptional. Same schema as [xver](./features/fallback.md#fallbackobject) in VLESS `fallbacks`.\n\n",
          "type": "string"
        },
        "serverNames": {
          "name": "serverNames",
          "description": "\nRequired. A list of accepted server names. No support for `*` wildcards yet.\n\n",
          "markdownDescription": "\nRequired. A list of accepted server names. No support for `*` wildcards yet.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "privateKey": {
          "name": "privateKey",
          "description": "\nRequired. Generate with `./xray x25519`.\n\n",
          "markdownDescription": "\nRequired. Generate with `./xray x25519`.\n\n",
          "type": "string"
        },
        "minClientVer": {
          "name": "minClientVer",
          "description": "\nOptional. Minimal accepted version of the Xray client, specified in `x.y.z`.\n\n",
          "markdownDescription": "\nOptional. Minimal accepted version of the Xray client, specified in `x.y.z`.\n\n",
          "type": "string"
        },
        "maxClientVer": {
          "name": "maxClientVer",
          "description": "\nOptional. Maximum accepted version of the Xray client, specified in `x.y.z`.\n\n",
          "markdownDescription": "\nOptional. Maximum accepted version of the Xray client, specified in `x.y.z`.\n\n",
          "type": "string"
        },
        "maxTimeDiff": {
          "name": "maxTimeDiff",
          "description": "\nOptional. The maximum time difference allowed, specified in milliseconds.\n\n",
          "markdownDescription": "\nOptional. The maximum time difference allowed, specified in milliseconds.\n\n",
          "type": "number"
        },
        "shortIds": {
          "name": "shortIds",
          "description": "\nRequired. A list of `shortId`s accepted. Can be used to distinguish different clients.\n\nSpecified in hex strings, with the length as multiples of 2. Cannot be longer than 16 characters.\n\n`shortId` on clients can be left blank if a blank value exists on the server.\n\n::: tip\n**Outbound** (**client-side**) configs below.\n:::\n\n",
          "markdownDescription": "\nRequired. A list of `shortId`s accepted. Can be used to distinguish different clients.\n\nSpecified in hex strings, with the length as multiples of 2. Cannot be longer than 16 characters.\n\n`shortId` on clients can be left blank if a blank value exists on the server.\n\n::: tip\n**Outbound** (**client-side**) configs below.\n:::\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "serverName": {
          "name": "serverName",
          "description": "\nOne of the server names accepted by the server.\n\n",
          "markdownDescription": "\nOne of the server names accepted by the server.\n\n",
          "type": "string"
        },
        "fingerprint": {
          "name": "fingerprint",
          "description": "\nRequired. Same as the [TLSObject](#tlsobject).\n\n",
          "markdownDescription": "\nRequired. Same as the [TLSObject](#tlsobject).\n\n",
          "type": "string"
        },
        "shortId": {
          "name": "shortId",
          "description": "\nOne of the short IDs accepted by the server.\n\nSpecified in hex strings, with the length as multiples of 2. Cannot be longer than 16 characters.\n\n`shortId` on clients can be left blank if a blank value exists on the server.\n\n",
          "markdownDescription": "\nOne of the short IDs accepted by the server.\n\nSpecified in hex strings, with the length as multiples of 2. Cannot be longer than 16 characters.\n\n`shortId` on clients can be left blank if a blank value exists on the server.\n\n",
          "type": "string"
        },
        "publicKey": {
          "name": "publicKey",
          "description": "\nRequired. The public key that corresponds to the private key on the server. Can be obtained by `./xray x25519 -i \"privateKey\"`.\n\n",
          "markdownDescription": "\nRequired. The public key that corresponds to the private key on the server. Can be obtained by `./xray x25519 -i \"privateKey\"`.\n\n",
          "type": "string"
        },
        "spiderX": {
          "name": "spiderX",
          "description": "\nThe bootstrapping path and query params of the spider. It's recommended to have this varied per client.\n\n",
          "markdownDescription": "\nThe bootstrapping path and query params of the spider. It's recommended to have this varied per client.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "CertificateObject": {
      "title": "CertificateObject",
      "description": "\n```json\n{\n  \"ocspStapling\": 3600,\n  \"oneTimeLoading\": false,\n  \"usage\": \"encipherment\",\n  \"buildChain\": false,\n  \"certificateFile\": \"/path/to/certificate.crt\",\n  \"keyFile\": \"/path/to/key.key\",\n  \"certificate\": [\n    \"--BEGIN CERTIFICATE--\",\n    \"MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\",\n    \"ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\",\n    \"DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\",\n    \"3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\",\n    \"OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\",\n    \"pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\",\n    \"OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\",\n    \"noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\",\n    \"A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\",\n    \"MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\",\n    \"7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\",\n    \"9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\",\n    \"6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\",\n    \"r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\",\n    \"d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\",\n    \"--END CERTIFICATE--\"\n  ],\n  \"key\": [\n    \"--BEGIN RSA PRIVATE KEY--\",\n    \"MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\",\n    \"bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\",\n    \"GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\",\n    \"jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\",\n    \"itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\",\n    \"IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\",\n    \"qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\",\n    \"C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\",\n    \"/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\",\n    \"aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\",\n    \"/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\",\n    \"bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\",\n    \"8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\",\n    \"pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\",\n    \"L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\",\n    \"3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\",\n    \"az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\",\n    \"gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\",\n    \"TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\",\n    \"eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\",\n    \"64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\",\n    \"8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\",\n    \"GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\",\n    \"ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\",\n    \"cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\",\n    \"--END RSA PRIVATE KEY--\"\n  ]\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"ocspStapling\": 3600,\n  \"oneTimeLoading\": false,\n  \"usage\": \"encipherment\",\n  \"buildChain\": false,\n  \"certificateFile\": \"/path/to/certificate.crt\",\n  \"keyFile\": \"/path/to/key.key\",\n  \"certificate\": [\n    \"--BEGIN CERTIFICATE--\",\n    \"MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\",\n    \"ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\",\n    \"DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\",\n    \"3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\",\n    \"OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\",\n    \"pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\",\n    \"OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\",\n    \"noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\",\n    \"A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\",\n    \"MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\",\n    \"7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\",\n    \"9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\",\n    \"6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\",\n    \"r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\",\n    \"d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\",\n    \"--END CERTIFICATE--\"\n  ],\n  \"key\": [\n    \"--BEGIN RSA PRIVATE KEY--\",\n    \"MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\",\n    \"bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\",\n    \"GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\",\n    \"jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\",\n    \"itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\",\n    \"IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\",\n    \"qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\",\n    \"C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\",\n    \"/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\",\n    \"aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\",\n    \"/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\",\n    \"bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\",\n    \"8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\",\n    \"pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\",\n    \"L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\",\n    \"3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\",\n    \"az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\",\n    \"gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\",\n    \"TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\",\n    \"eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\",\n    \"64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\",\n    \"8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\",\n    \"GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\",\n    \"ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\",\n    \"cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\",\n    \"--END RSA PRIVATE KEY--\"\n  ]\n}\n```\n\n",
      "properties": {
        "ocspStapling": {
          "name": "ocspStapling",
          "description": "\nOCSP stapling update interval in seconds for certificate hot reload. Default value is `3600`, i.e. one hour.\n\n",
          "markdownDescription": "\nOCSP stapling update interval in seconds for certificate hot reload. Default value is `3600`, i.e. one hour.\n\n",
          "type": "number"
        },
        "oneTimeLoading": {
          "name": "oneTimeLoading",
          "description": "\nLoad only once. When set to `true`, it will disable certificate hot reload and OCSP stapling feature.\n\n::: warning\nWhen set to `true`, OCSP stapling will be disabled.\n:::\n\n",
          "markdownDescription": "\nLoad only once. When set to `true`, it will disable certificate hot reload and OCSP stapling feature.\n\n::: warning\nWhen set to `true`, OCSP stapling will be disabled.\n:::\n\n",
          "type": "boolean"
        },
        "usage": {
          "name": "usage",
          "description": "\nCertificate usage, default value is `\"encipherment\"`.\n\n- `\"encipherment\"`: The certificate is used for TLS authentication and encryption.\n- `\"verify\"`: The certificate is used to verify the remote TLS certificate. When using this option, the current certificate must be a CA certificate.\n- `\"issue\"`: The certificate is used to issue other certificates. When using this option, the current certificate must be a CA certificate.\n\n::: tip TIP 1\nOn Windows platform, self-signed CA certificate can be installed in the system for verifying remote TLS certificates.\n:::\n\n::: tip TIP 2\nWhen a new client request comes in, assuming the specified `serverName` is `\"xray.com\"`, Xray will first look for a certificate that can be used for `\"xray.com\"` in the certificate list. If not found, it will issue a certificate for `\"xray.com\"` using any certificate with `usage` set to `\"issue\"`, with a validity of one hour. The new certificate is then added to the certificate list for later use.\n:::\n\n::: tip TIP 3\nWhen both `certificateFile` and `certificate` are specified, Xray will use `certificateFile` as the priority. The same applies to `keyFile` and `key`.\n:::\n\n::: tip TIP 4\nWhen `usage` is set to `\"verify\"`, `keyFile` and `key` can both be empty.\n:::\n\n::: tip TIP 5\nUse `xray tls cert` to generate self-signed CA certificate.\n:::\n\n::: tip TIP 6\nIf you already have a domain name, you can use tools to obtain free third-party certificates easily, such as [acme.sh](https://github.com/acmesh-official/acme.sh).\n:::\n\n",
          "markdownDescription": "\nCertificate usage, default value is `\"encipherment\"`.\n\n- `\"encipherment\"`: The certificate is used for TLS authentication and encryption.\n- `\"verify\"`: The certificate is used to verify the remote TLS certificate. When using this option, the current certificate must be a CA certificate.\n- `\"issue\"`: The certificate is used to issue other certificates. When using this option, the current certificate must be a CA certificate.\n\n::: tip TIP 1\nOn Windows platform, self-signed CA certificate can be installed in the system for verifying remote TLS certificates.\n:::\n\n::: tip TIP 2\nWhen a new client request comes in, assuming the specified `serverName` is `\"xray.com\"`, Xray will first look for a certificate that can be used for `\"xray.com\"` in the certificate list. If not found, it will issue a certificate for `\"xray.com\"` using any certificate with `usage` set to `\"issue\"`, with a validity of one hour. The new certificate is then added to the certificate list for later use.\n:::\n\n::: tip TIP 3\nWhen both `certificateFile` and `certificate` are specified, Xray will use `certificateFile` as the priority. The same applies to `keyFile` and `key`.\n:::\n\n::: tip TIP 4\nWhen `usage` is set to `\"verify\"`, `keyFile` and `key` can both be empty.\n:::\n\n::: tip TIP 5\nUse `xray tls cert` to generate self-signed CA certificate.\n:::\n\n::: tip TIP 6\nIf you already have a domain name, you can use tools to obtain free third-party certificates easily, such as [acme.sh](https://github.com/acmesh-official/acme.sh).\n:::\n\n",
          "anyOf": [
            {
              "const": "encipherment"
            },
            {
              "const": "verify"
            },
            {
              "const": "issue"
            }
          ]
        },
        "buildChain": {
          "name": "buildChain",
          "description": "\nOnly valid when `usage` is `issue`. When set to `true`, the CA certificate will be appended to leaf certificate as chain during issuing certificates.\n\n::: tip TIP 1\nRoot certificates should not be embedded in the certificate chain. This option is only applicable when the signing CA certificate is an intermediate certificate.\n:::\n\n",
          "markdownDescription": "\nOnly valid when `usage` is `issue`. When set to `true`, the CA certificate will be appended to leaf certificate as chain during issuing certificates.\n\n::: tip TIP 1\nRoot certificates should not be embedded in the certificate chain. This option is only applicable when the signing CA certificate is an intermediate certificate.\n:::\n\n",
          "type": "boolean"
        },
        "certificateFile": {
          "name": "certificateFile",
          "description": "\nPath to the certificate file generated by OpenSSL, with the suffix `.crt`.\n\n",
          "markdownDescription": "\nPath to the certificate file generated by OpenSSL, with the suffix `.crt`.\n\n",
          "type": "string"
        },
        "certificate": {
          "name": "certificate",
          "description": "\nA string array representing the certificate content, in the format shown in the example. Either `certificate` or `certificateFile` can be used.\n\n",
          "markdownDescription": "\nA string array representing the certificate content, in the format shown in the example. Either `certificate` or `certificateFile` can be used.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "keyFile": {
          "name": "keyFile",
          "description": "\nPath to the key file generated by OpenSSL, with the suffix `.key`. Password-protected key files are not currently supported.\n\n",
          "markdownDescription": "\nPath to the key file generated by OpenSSL, with the suffix `.key`. Password-protected key files are not currently supported.\n\n",
          "type": "string"
        },
        "key": {
          "name": "key",
          "description": "\nA string array representing the key content, in the format shown in the example. Either `key` or `keyFile` can be used.\n\n",
          "markdownDescription": "\nA string array representing the key content, in the format shown in the example. Either `key` or `keyFile` can be used.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "SockoptObject": {
      "title": "SockoptObject",
      "description": "\n```json\n{\n  \"mark\": 0,\n  \"tcpFastOpen\": false,\n  \"tproxy\": \"off\",\n  \"domainStrategy\": \"AsIs\",\n  \"dialerProxy\": \"\",\n  \"acceptProxyProtocol\": false,\n  \"tcpKeepAliveInterval\": 0,\n  \"tcpcongestion\": \"bbr\",\n  \"interface\": \"wg0\",\n  \"tcpMptcp\": false,\n  \"tcpNoDelay\": false\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"mark\": 0,\n  \"tcpFastOpen\": false,\n  \"tproxy\": \"off\",\n  \"domainStrategy\": \"AsIs\",\n  \"dialerProxy\": \"\",\n  \"acceptProxyProtocol\": false,\n  \"tcpKeepAliveInterval\": 0,\n  \"tcpcongestion\": \"bbr\",\n  \"interface\": \"wg0\",\n  \"tcpMptcp\": false,\n  \"tcpNoDelay\": false\n}\n```\n\n",
      "properties": {
        "mark": {
          "name": "mark",
          "description": "\nAn integer value. When its value is non-zero, SO_MARK is marked with this value on the outbound connection.\n\n- Only applicable to Linux systems.\n- Requires CAP_NET_ADMIN permission.\n\n",
          "markdownDescription": "\nAn integer value. When its value is non-zero, SO_MARK is marked with this value on the outbound connection.\n\n- Only applicable to Linux systems.\n- Requires CAP_NET_ADMIN permission.\n\n",
          "type": "number"
        },
        "tcpFastOpen": {
          "name": "tcpFastOpen",
          "description": "\nSpecifies whether [TCP Fast Open](https://en.wikipedia.org/wiki/TCP_Fast_Open) is enabled.\n\nWhen its value is `true` or a positive integer, TFO is enabled; when its value is `false` or a negative integer, TFO is forced to be disabled; when this item does not exist or is `0`, the system default setting is used. It can be used for inbound/outbound connections.\n\n- Only available in the following (or later) versions of operating systems:\n  - Windows 10 (1607)\n  - Mac OS 10.11 / iOS 9\n  - Linux 3.16: It needs to be set through the kernel parameter `net.ipv4.tcp_fastopen`, which is a bitmap. `0x1` represents the client allows enabling it, and `0x2` represents the server allows enabling it. The default value is `0x1`. If the server wants to enable TFO, set this kernel parameter value to `0x3`.\n  - FreeBSD 10.3 (Server) / 12.0 (Client): The kernel parameters `net.inet.tcp.fastopen.server_enabled` and `net.inet.tcp.fastopen.client_enabled` need to be set to `1`.\n- For inbound, the `positive integer` set here represents the maximum number of TFO connection requests to be processed, **note that not all operating systems support this setting**:\n  - Linux/FreeBSD: The `positive integer` value set here represents the upper limit, and the maximum acceptable value is 2147483647. If it is set to `true`, it will take `256`. Note that in Linux, `net.core.somaxconn` will limit the upper limit of this value. If it exceeds `somaxconn`, please also increase `somaxconn`.\n  - Mac OS: When it is `true` or a `positive integer`, it only represents enabling TFO, and the upper limit needs to be set separately through the kernel parameter `net.inet.tcp.fastopen_backlog`.\n  - Windows: When it is `true` or a `positive integer`, it only represents enabling TFO.\n- For outbound, setting it to `true` or a `positive integer` only represents enabling TFO on any operating system.\n\n",
          "markdownDescription": "\nSpecifies whether [TCP Fast Open](https://en.wikipedia.org/wiki/TCP_Fast_Open) is enabled.\n\nWhen its value is `true` or a positive integer, TFO is enabled; when its value is `false` or a negative integer, TFO is forced to be disabled; when this item does not exist or is `0`, the system default setting is used. It can be used for inbound/outbound connections.\n\n- Only available in the following (or later) versions of operating systems:\n  - Windows 10 (1607)\n  - Mac OS 10.11 / iOS 9\n  - Linux 3.16: It needs to be set through the kernel parameter `net.ipv4.tcp_fastopen`, which is a bitmap. `0x1` represents the client allows enabling it, and `0x2` represents the server allows enabling it. The default value is `0x1`. If the server wants to enable TFO, set this kernel parameter value to `0x3`.\n  - FreeBSD 10.3 (Server) / 12.0 (Client): The kernel parameters `net.inet.tcp.fastopen.server_enabled` and `net.inet.tcp.fastopen.client_enabled` need to be set to `1`.\n- For inbound, the `positive integer` set here represents the maximum number of TFO connection requests to be processed, **note that not all operating systems support this setting**:\n  - Linux/FreeBSD: The `positive integer` value set here represents the upper limit, and the maximum acceptable value is 2147483647. If it is set to `true`, it will take `256`. Note that in Linux, `net.core.somaxconn` will limit the upper limit of this value. If it exceeds `somaxconn`, please also increase `somaxconn`.\n  - Mac OS: When it is `true` or a `positive integer`, it only represents enabling TFO, and the upper limit needs to be set separately through the kernel parameter `net.inet.tcp.fastopen_backlog`.\n  - Windows: When it is `true` or a `positive integer`, it only represents enabling TFO.\n- For outbound, setting it to `true` or a `positive integer` only represents enabling TFO on any operating system.\n\n",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "boolean"
            },
            {
              "type": "number"
            }
          ]
        },
        "tproxy": {
          "name": "tproxy",
          "description": "\nSpecifies whether to enable transparent proxy (only applicable to Linux).\n\n- `\"redirect\"`: Use the transparent proxy in Redirect mode. It supports all TCP connections based on IPv4/6.\n- `\"tproxy\"`: Use the transparent proxy in TProxy mode. It supports all TCP and UDP connections based on IPv4/6.\n- `\"off\"`: Turn off transparent proxy.\n\nTransparent proxy requires Root or `CAP\\_NET\\_ADMIN` permission.\n\n::: danger\nWhen `followRedirect` is set to `true` in [Dokodemo-door](./inbounds/dokodemo.md), and `tproxy` in the Sockopt settings is empty, the value of `tproxy` in the Sockopt settings will be set to `\"redirect\"`.\n:::\n\n",
          "markdownDescription": "\nSpecifies whether to enable transparent proxy (only applicable to Linux).\n\n- `\"redirect\"`: Use the transparent proxy in Redirect mode. It supports all TCP connections based on IPv4/6.\n- `\"tproxy\"`: Use the transparent proxy in TProxy mode. It supports all TCP and UDP connections based on IPv4/6.\n- `\"off\"`: Turn off transparent proxy.\n\nTransparent proxy requires Root or `CAP\\_NET\\_ADMIN` permission.\n\n::: danger\nWhen `followRedirect` is set to `true` in [Dokodemo-door](./inbounds/dokodemo.md), and `tproxy` in the Sockopt settings is empty, the value of `tproxy` in the Sockopt settings will be set to `\"redirect\"`.\n:::\n\n",
          "anyOf": [
            {
              "const": "redirect"
            },
            {
              "const": "tproxy"
            },
            {
              "const": "off"
            }
          ]
        },
        "domainStrategy": {
          "name": "domainStrategy",
          "description": "\nIn previous versions, when Xray attempted to establish a system connection using a domain name, the resolution of the domain name was completed by the system and not controlled by Xray. This led to issues such as the inability to resolve domain names in non-standard Linux environments. To solve this problem, Xray 1.3.1 introduced Freedom's `domainStrategy` into Sockopt.\n\nWhen the target address is a domain name, the corresponding value is configured, and the behavior of SystemDialer is as follows:\n\n- `\"AsIs\"`: Resolve the IP address using the system DNS server and connect to the domain name.\n- `\"UseIP\"`, `\"UseIPv4\"`, and `\"UseIPv6\"`: Resolve the IP address using the [built-in DNS server](./dns.md) and connect to the IP address directly.\n\nThe default value is `\"AsIs\"`.\n\n::: danger\n\nImproper configuration may cause infinite loops when this feature is enabled.\n\nIn short, connecting to the server requires waiting for the DNS query result, and completing the DNS query requires connecting to the server.\n\n\nExplanation:\n\n1. Trigger condition: proxy server (proxy.com). Built-in DNS server, non-local mode.\n2. Before Xray attempts to establish a TCP connection to proxy.com, it queries proxy.com using the built-in DNS server.\n3. The built-in DNS server establishes a connection to dns.com and sends a query to obtain the IP address of proxy.com.\n4. Improper routing rules cause proxy.com to proxy the query sent in step 3.\n5. Xray attempts to establish another TCP connection to proxy.com.\n6. Before establishing the connection, Xray queries proxy.com using the built-in DNS server.\n7. The built-in DNS server reuses the connection established in step 3 to send a query.\n8. A problem arises. The establishment of the connection in step 3 requires waiting for the query result in step 7, and the completion of the query in step 7 requires waiting for the connection in step 3 to be fully established.\n9. Good game!\n\nSolution:\n\n- Adjust the split of internal DNS servers.\n- Use Hosts file.\n- ~~If you still don't know the solution, then don't use this feature.~~\n\nTherefore, it is **not recommended** for inexperienced users to use this feature.\n\n:::\n\n",
          "markdownDescription": "\nIn previous versions, when Xray attempted to establish a system connection using a domain name, the resolution of the domain name was completed by the system and not controlled by Xray. This led to issues such as the inability to resolve domain names in non-standard Linux environments. To solve this problem, Xray 1.3.1 introduced Freedom's `domainStrategy` into Sockopt.\n\nWhen the target address is a domain name, the corresponding value is configured, and the behavior of SystemDialer is as follows:\n\n- `\"AsIs\"`: Resolve the IP address using the system DNS server and connect to the domain name.\n- `\"UseIP\"`, `\"UseIPv4\"`, and `\"UseIPv6\"`: Resolve the IP address using the [built-in DNS server](./dns.md) and connect to the IP address directly.\n\nThe default value is `\"AsIs\"`.\n\n::: danger\n\nImproper configuration may cause infinite loops when this feature is enabled.\n\nIn short, connecting to the server requires waiting for the DNS query result, and completing the DNS query requires connecting to the server.\n\n\nExplanation:\n\n1. Trigger condition: proxy server (proxy.com). Built-in DNS server, non-local mode.\n2. Before Xray attempts to establish a TCP connection to proxy.com, it queries proxy.com using the built-in DNS server.\n3. The built-in DNS server establishes a connection to dns.com and sends a query to obtain the IP address of proxy.com.\n4. Improper routing rules cause proxy.com to proxy the query sent in step 3.\n5. Xray attempts to establish another TCP connection to proxy.com.\n6. Before establishing the connection, Xray queries proxy.com using the built-in DNS server.\n7. The built-in DNS server reuses the connection established in step 3 to send a query.\n8. A problem arises. The establishment of the connection in step 3 requires waiting for the query result in step 7, and the completion of the query in step 7 requires waiting for the connection in step 3 to be fully established.\n9. Good game!\n\nSolution:\n\n- Adjust the split of internal DNS servers.\n- Use Hosts file.\n- ~~If you still don't know the solution, then don't use this feature.~~\n\nTherefore, it is **not recommended** for inexperienced users to use this feature.\n\n:::\n\n",
          "anyOf": [
            {
              "const": "AsIs"
            },
            {
              "const": "UseIP"
            },
            {
              "const": "UseIPv4"
            },
            {
              "const": "UseIPv6"
            }
          ]
        },
        "dialerProxy": {
          "name": "dialerProxy",
          "description": "\nAn identifier for an outbound proxy. When the value is not empty, the specified outbound will be used to establish the connection. This option can be used to support chain forwarding of underlying transport protocols.\n\n::: danger\nThis option is incompatible with ProxySettingsObject.Tag\n:::\n\n",
          "markdownDescription": "\nAn identifier for an outbound proxy. When the value is not empty, the specified outbound will be used to establish the connection. This option can be used to support chain forwarding of underlying transport protocols.\n\n::: danger\nThis option is incompatible with ProxySettingsObject.Tag\n:::\n\n",
          "const": ""
        },
        "acceptProxyProtocol": {
          "name": "acceptProxyProtocol",
          "description": "\nOnly used for inbound, indicates whether to accept the PROXY protocol.\n\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to pass the true source IP and port of a request. **If you are not familiar with it, please ignore this option first**.\n\nCommon reverse proxy software (such as HAProxy, Nginx) can be configured to send it, and VLESS fallbacks xver can also send it.\n\nWhen set to `true`, after the lowest-level TCP connection is established, the requesting party must first send PROXY protocol v1 or v2, otherwise the connection will be closed.\n\n",
          "markdownDescription": "\nOnly used for inbound, indicates whether to accept the PROXY protocol.\n\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to pass the true source IP and port of a request. **If you are not familiar with it, please ignore this option first**.\n\nCommon reverse proxy software (such as HAProxy, Nginx) can be configured to send it, and VLESS fallbacks xver can also send it.\n\nWhen set to `true`, after the lowest-level TCP connection is established, the requesting party must first send PROXY protocol v1 or v2, otherwise the connection will be closed.\n\n",
          "type": "boolean"
        },
        "tcpKeepAliveInterval": {
          "name": "tcpKeepAliveInterval",
          "description": "\nInterval between TCP keep-alive packets, in seconds. ~~This setting only applies to Linux.~~\n\nNot configuring this item or configuring it as 0 means using the default value of Go.\n\n::: tip\nWhen filling in a negative number, such as `-1`, TCP keep-alive is not enabled.\n:::\n\n",
          "markdownDescription": "\nInterval between TCP keep-alive packets, in seconds. ~~This setting only applies to Linux.~~\n\nNot configuring this item or configuring it as 0 means using the default value of Go.\n\n::: tip\nWhen filling in a negative number, such as `-1`, TCP keep-alive is not enabled.\n:::\n\n",
          "type": "number"
        },
        "tcpcongestion": {
          "name": "tcpcongestion",
          "description": "\nTCP congestion control algorithm. Only supported by Linux. Not configuring this item means using the system default value.\n\n::: tip\nCommon algorithms\n\n- bbr (recommended)\n- cubic\n- reno\n\n:::\n\n::: tip\nExecute the command `sysctl net.ipv4.tcp_congestion_control` to get the system default value.\n:::\n\n",
          "markdownDescription": "\nTCP congestion control algorithm. Only supported by Linux. Not configuring this item means using the system default value.\n\n::: tip\nCommon algorithms\n\n- bbr (recommended)\n- cubic\n- reno\n\n:::\n\n::: tip\nExecute the command `sysctl net.ipv4.tcp_congestion_control` to get the system default value.\n:::\n\n",
          "const": ""
        },
        "interface": {
          "name": "interface",
          "description": "\nSpecifies the name of the bound outbound network interface. supported by Linux MacOS iOS.<br>\nMacOS iOS Requires Xray-core v1.8.6 or higher.\n\n",
          "markdownDescription": "\nSpecifies the name of the bound outbound network interface. supported by Linux MacOS iOS.<br>\nMacOS iOS Requires Xray-core v1.8.6 or higher.\n\n",
          "const": ""
        },
        "tcpMptcp": {
          "name": "tcpMptcp",
          "description": "\nXray-core v1.8.6 New parameter.<br>\nDefault value `false`, fill in `true` to enable [Multipath TCP](https://en.wikipedia.org/wiki/Multipath_TCP), need to be enabled in both server and client configuration.\n\n",
          "markdownDescription": "\nXray-core v1.8.6 New parameter.<br>\nDefault value `false`, fill in `true` to enable [Multipath TCP](https://en.wikipedia.org/wiki/Multipath_TCP), need to be enabled in both server and client configuration.\n\n",
          "type": "boolean"
        },
        "tcpNoDelay": {
          "name": "tcpNoDelay",
          "description": "\nDefault value `false`, recommended to be enabled with \"tcpMptcp\": true.\n\n",
          "markdownDescription": "\nDefault value `false`, recommended to be enabled with \"tcpMptcp\": true.\n\n",
          "type": "boolean"
        },
        "customSockopt": {
          "name": "customSockopt",
          "description": "\nAn array for advanced users to specify any sockopt. In theory, all the above connection-related settings can be set equivalently here. Naturally, other options that exist in Linux but have not been added to the core can also be set. The example below is equivalent to `\"tcpcongestion\": \"bbr\"` in core.\n\nPlease make sure you understand Linux socket programming before using it.\n\n```json\n\"customSockopt\": [\n  {\n    \"type\": \"str\",\n    \"level\":\"6\",\n    \"opt\": \"13\",\n    \"value\": \"bbr\"\n  }\n]\n```\n\n",
          "markdownDescription": "\nAn array for advanced users to specify any sockopt. In theory, all the above connection-related settings can be set equivalently here. Naturally, other options that exist in Linux but have not been added to the core can also be set. The example below is equivalent to `\"tcpcongestion\": \"bbr\"` in core.\n\nPlease make sure you understand Linux socket programming before using it.\n\n```json\n\"customSockopt\": [\n  {\n    \"type\": \"str\",\n    \"level\":\"6\",\n    \"opt\": \"13\",\n    \"value\": \"bbr\"\n  }\n]\n```\n\n",
          "type": "array",
          "items": {}
        },
        "type": {
          "name": "type",
          "description": "\nRequired, the type of setting, valid values are `int` or `str`.\n\n",
          "markdownDescription": "\nRequired, the type of setting, valid values are `int` or `str`.\n\n",
          "const": ""
        },
        "level": {
          "name": "level",
          "description": "\nOptional, protocol level, used to specify the effective range, the default is `6`, which is TCP.\n\n",
          "markdownDescription": "\nOptional, protocol level, used to specify the effective range, the default is `6`, which is TCP.\n\n",
          "const": ""
        },
        "opt": {
          "name": "opt",
          "description": "\nThe option name of the operation, using decimal (the example here is that the value of `TCP_CONGESTION` is defined as `0xd` and converted to decimal is 13)\n\n",
          "markdownDescription": "\nThe option name of the operation, using decimal (the example here is that the value of `TCP_CONGESTION` is defined as `0xd` and converted to decimal is 13)\n\n",
          "const": ""
        },
        "value": {
          "name": "value",
          "description": "\nThe option value to be set, the example here is set to bbr.\n\nDecimal numbers are required when type is specified as int.\n---\ntitle: Configurations\nlang: en-US\n---\n\n> **This section will tell you all the details of Xray configuration. By mastering these contents, Xray will unleash its full power in your hands.**\n\n",
          "markdownDescription": "\nThe option value to be set, the example here is set to bbr.\n\nDecimal numbers are required when type is specified as int.\n---\ntitle: Configurations\nlang: en-US\n---\n\n> **This section will tell you all the details of Xray configuration. By mastering these contents, Xray will unleash its full power in your hands.**\n\n",
          "const": ""
        }
      },
      "additionalProperties": false
    },
    "Overview": {
      "title": "Overview",
      "description": "\nThe configuration file of Xray is in JSON format, and the configuration format for the client and server is the same, except for the actual configuration content. It takes the following form:\n\n```json\n{\n  \"log\": {},\n  \"api\": {},\n  \"dns\": {},\n  \"routing\": {},\n  \"policy\": {},\n  \"inbounds\": [],\n  \"outbounds\": [],\n  \"transport\": {},\n  \"stats\": {},\n  \"reverse\": {},\n  \"fakedns\": {},\n  \"metrics\": {},\n  \"observatory\": {},\n  \"burstObservatory\": {}\n}\n```\n\n::: warning\nIf you are new to Xray, you can first click to view [configuration and running in the Quick Start guide](../document/install.md), to learn the most basic configuration method, and then refer to the contents of this section to master all the configuration methods of Xray.\n:::\n\n",
      "markdownDescription": "\nThe configuration file of Xray is in JSON format, and the configuration format for the client and server is the same, except for the actual configuration content. It takes the following form:\n\n```json\n{\n  \"log\": {},\n  \"api\": {},\n  \"dns\": {},\n  \"routing\": {},\n  \"policy\": {},\n  \"inbounds\": [],\n  \"outbounds\": [],\n  \"transport\": {},\n  \"stats\": {},\n  \"reverse\": {},\n  \"fakedns\": {},\n  \"metrics\": {},\n  \"observatory\": {},\n  \"burstObservatory\": {}\n}\n```\n\n::: warning\nIf you are new to Xray, you can first click to view [configuration and running in the Quick Start guide](../document/install.md), to learn the most basic configuration method, and then refer to the contents of this section to master all the configuration methods of Xray.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Basic Configuration Modules": {
      "title": "Basic Configuration Modules",
      "description": "\n",
      "markdownDescription": "\n",
      "properties": {
        "log": {
          "name": "log",
          "description": "\nLog configurations, controlling how Xray emits logs.\n\n",
          "markdownDescription": "\nLog configurations, controlling how Xray emits logs.\n\n",
          "$ref": "#/definitions/LogObject"
        },
        "api": {
          "name": "api",
          "description": "\nConfigures how Xray provides API interfaces for calling remotely.\n\n",
          "markdownDescription": "\nConfigures how Xray provides API interfaces for calling remotely.\n\n",
          "$ref": "#/definitions/ApiObject"
        },
        "dns": {
          "name": "dns",
          "description": "\nConfigures the built-in DNS server. System DNS will be used if not configured.\n\n",
          "markdownDescription": "\nConfigures the built-in DNS server. System DNS will be used if not configured.\n\n",
          "$ref": "#/definitions/DnsObject"
        },
        "routing": {
          "name": "routing",
          "description": "\nConfigures routing. Specify rules to route connections through different outbounds.\n\n",
          "markdownDescription": "\nConfigures routing. Specify rules to route connections through different outbounds.\n\n",
          "$ref": "#/definitions/RoutingObject"
        },
        "policy": {
          "name": "policy",
          "description": "\nLocal policy configurations, specifying different user levels and corresponding policies.\n\n",
          "markdownDescription": "\nLocal policy configurations, specifying different user levels and corresponding policies.\n\n",
          "$ref": "#/definitions/PolicyObject"
        },
        "inbounds": {
          "name": "inbounds",
          "description": "\nAn array of inbound connection configurations.\n\n",
          "markdownDescription": "\nAn array of inbound connection configurations.\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/InboundObject"
          }
        },
        "outbounds": {
          "name": "outbounds",
          "description": "\nAn array of outbound connection configurations.\n\n",
          "markdownDescription": "\nAn array of outbound connection configurations.\n\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/OutboundObject"
          }
        },
        "transport": {
          "name": "transport",
          "description": "\nConfigures how Xray establishes and uses network connections to other servers.\n\n",
          "markdownDescription": "\nConfigures how Xray establishes and uses network connections to other servers.\n\n",
          "type": "object"
        },
        "stats": {
          "name": "stats",
          "description": "\nConfigures traffic statistics.\n\n",
          "markdownDescription": "\nConfigures traffic statistics.\n\n",
          "$ref": "#/definitions/StatsObject"
        },
        "reverse": {
          "name": "reverse",
          "description": "\nConfigures the built-in reverse proxy. You can forward server traffic to the client, effectively achieving reverse proxying.\n\n",
          "markdownDescription": "\nConfigures the built-in reverse proxy. You can forward server traffic to the client, effectively achieving reverse proxying.\n\n",
          "$ref": "#/definitions/ReverseObject"
        },
        "fakedns": {
          "name": "fakedns",
          "description": "\nFakeDNS configuration. Can be used with a transparent proxy to obtain the actual domains.\n\n",
          "markdownDescription": "\nFakeDNS configuration. Can be used with a transparent proxy to obtain the actual domains.\n\n",
          "type": "object"
        },
        "metrics": {
          "name": "metrics",
          "description": "\nMetrics configuration. A more straightforward (and hopefully better) way to export metrics.\n\n",
          "markdownDescription": "\nMetrics configuration. A more straightforward (and hopefully better) way to export metrics.\n\n",
          "type": "object"
        },
        "observatory": {
          "name": "observatory",
          "description": "\nBackground connection observation. Detect the connection status of outbound proxies.\n\n",
          "markdownDescription": "\nBackground connection observation. Detect the connection status of outbound proxies.\n\n",
          "$ref": "#/definitions/ObservatoryObject"
        },
        "burstObservatory": {
          "name": "burstObservatory",
          "description": "\nConcurrent connection observation. Detect the connection status of outbound proxies.\n# Freedom\n\nFreedom is an outbound protocol that can be used to send (normal) TCP or UDP data to any network.\n\n",
          "markdownDescription": "\nConcurrent connection observation. Detect the connection status of outbound proxies.\n# Freedom\n\nFreedom is an outbound protocol that can be used to send (normal) TCP or UDP data to any network.\n\n",
          "$ref": "#/definitions/BurstObservatoryObject"
        }
      },
      "additionalProperties": false
    },
    "OutboundConfigurationObject": {
      "anyOf": [
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"domainStrategy\": \"AsIs\",\n  \"redirect\": \"127.0.0.1:3366\",\n  \"userLevel\": 0,\n  \"fragment\": {\n    \"packets\": \"tlshello\",\n    \"length\": \"100-200\",\n    \"interval\": \"10-20\" // ms\n  },\n  \"noises\":[\n  {\n    \"type\":\"base64\",\n    \"packet\":\"7nQBAAABAAAAAAAABnQtcmluZwZtc2VkZ2UDbmV0AAABAAE=\",\n    \"delay\":\"10-16\"\n  },\n  {\n    \"type\":\"rand\",\n    \"packet\":\"10-20\",\n    \"delay\":\"10-16\"\n  },\n  {\n    \"type\":\"str\",\n    \"packet\":\"hiGFW\",\n    \"delay\":\"10-16\"\n  }\n],\n  \"proxyProtocol\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"domainStrategy\": \"AsIs\",\n  \"redirect\": \"127.0.0.1:3366\",\n  \"userLevel\": 0,\n  \"fragment\": {\n    \"packets\": \"tlshello\",\n    \"length\": \"100-200\",\n    \"interval\": \"10-20\" // ms\n  },\n  \"noises\":[\n  {\n    \"type\":\"base64\",\n    \"packet\":\"7nQBAAABAAAAAAAABnQtcmluZwZtc2VkZ2UDbmV0AAABAAE=\",\n    \"delay\":\"10-16\"\n  },\n  {\n    \"type\":\"rand\",\n    \"packet\":\"10-20\",\n    \"delay\":\"10-16\"\n  },\n  {\n    \"type\":\"str\",\n    \"packet\":\"hiGFW\",\n    \"delay\":\"10-16\"\n  }\n],\n  \"proxyProtocol\": 0\n}\n```\n\n",
          "properties": {
            "domainStrategy": {
              "name": "domainStrategy",
              "description": "\nWhen the destination address is a domain name, configure the corresponding value for Freedom's behavior:\n\n- `\"AsIs\"`: Freedom resolves the domain name using the system DNS server and connects to it.\n- `\"UseIP\"`, `\"UseIPv4\"`, and `\"UseIPv6\"`: Xray resolves the domain name using the built-in [DNS server](../dns.md) and connects to it. The default value is `\"AsIs\"`.\n\n::: tip TIP 1\nWhen using the `\"UseIP\"` mode and the `sendThrough` field is specified in the [outbound connection configuration](../outbound.md#outboundobject), Freedom will automatically determine the required IP type, IPv4 or IPv6, based on the value of `sendThrough`.\n:::\n\n::: tip TIP 2\nWhen using the `\"UseIPv4\"` or `\"UseIPv6\"` mode, Freedom will only use the corresponding IPv4 or IPv6 address. If `sendThrough` specifies a mismatched local address, the connection will fail.\n:::\n\n",
              "markdownDescription": "\nWhen the destination address is a domain name, configure the corresponding value for Freedom's behavior:\n\n- `\"AsIs\"`: Freedom resolves the domain name using the system DNS server and connects to it.\n- `\"UseIP\"`, `\"UseIPv4\"`, and `\"UseIPv6\"`: Xray resolves the domain name using the built-in [DNS server](../dns.md) and connects to it. The default value is `\"AsIs\"`.\n\n::: tip TIP 1\nWhen using the `\"UseIP\"` mode and the `sendThrough` field is specified in the [outbound connection configuration](../outbound.md#outboundobject), Freedom will automatically determine the required IP type, IPv4 or IPv6, based on the value of `sendThrough`.\n:::\n\n::: tip TIP 2\nWhen using the `\"UseIPv4\"` or `\"UseIPv6\"` mode, Freedom will only use the corresponding IPv4 or IPv6 address. If `sendThrough` specifies a mismatched local address, the connection will fail.\n:::\n\n",
              "anyOf": [
                {
                  "const": "AsIs"
                },
                {
                  "const": "UseIP"
                },
                {
                  "const": "UseIPv4"
                },
                {
                  "const": "UseIPv6"
                }
              ]
            },
            "redirect": {
              "name": "redirect",
              "description": "\nFreedom will force all data to be sent to the specified address (instead of the address specified in the inbound).\n\nIt is a string value, for example: `\"127.0.0.1:80\"`, `\":1234\"`.\n\nWhen the address is not specified, such as `\":443\"`, Freedom will not modify the original destination address. When the port is `0`, such as `\"xray.com:0\"`, Freedom will not modify the original port.\n\n",
              "markdownDescription": "\nFreedom will force all data to be sent to the specified address (instead of the address specified in the inbound).\n\nIt is a string value, for example: `\"127.0.0.1:80\"`, `\":1234\"`.\n\nWhen the address is not specified, such as `\":443\"`, Freedom will not modify the original destination address. When the port is `0`, such as `\"xray.com:0\"`, Freedom will not modify the original port.\n\n",
              "type": "string"
            },
            "userLevel": {
              "name": "userLevel",
              "description": "\nUser level. The connection will use the corresponding [local policy](../policy.md#levelpolicyobject) for this user level.\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nUser level. The connection will use the corresponding [local policy](../policy.md#levelpolicyobject) for this user level.\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            },
            "fragment": {
              "name": "fragment",
              "description": "\nA key-value map used to control TCP fragmentation\uff0cunder some circumstances it can cheat the censor system, like bypass a SNI blacklist.\n\n`\"packets\"`\uff1asupport two different methods. \"1-3\" is for segmentation at TCP layer, applying to the beginning 1 to 3 data writes by the client. \"tlshello\" is for TLS client hello packet fragmentation.\n\n`\"length\"`: length to make the cut\n\n`\"interval\"`: time between fragments\uff08ms\uff09\n\n::: warning\n\u26a0\ufe0f \"noise\":{} is deptecated,only \"noises\":[{}] is supported in 24.9.16 and later\n  :::\n\n",
              "markdownDescription": "\nA key-value map used to control TCP fragmentation\uff0cunder some circumstances it can cheat the censor system, like bypass a SNI blacklist.\n\n`\"packets\"`\uff1asupport two different methods. \"1-3\" is for segmentation at TCP layer, applying to the beginning 1 to 3 data writes by the client. \"tlshello\" is for TLS client hello packet fragmentation.\n\n`\"length\"`: length to make the cut\n\n`\"interval\"`: time between fragments\uff08ms\uff09\n\n::: warning\n\u26a0\ufe0f \"noise\":{} is deptecated,only \"noises\":[{}] is supported in 24.9.16 and later\n  :::\n\n",
              "type": "object"
            },
            "noises": {
              "name": "noises",
              "description": "\nA Array used to control UDP noise\uff0cunder some circumstances it can bypass some udp based protocol restrictions.\nxray will loop through this array and send each noise packet one by one\n\n`\"type\"`\uff1aThree types are supported. \"rand\" generates a random byte , \"str\" uses a user input string, \"base64\" uses a user input base64 encoded string\n\n`\"packet\"`\uff1aIf type is set to \"rand\" this field will take a range \"50-100\" or a single value \"50\"\n\nif type is set to \"str\" this field will take a string\n\nif type is set to \"base64\" this field will take a base64 encoded string\n\n`\"delay\"`\uff1adelay before sending real data (ms). can be a string range like \"10-20\" or a single integer\n\nIf not specified, the default value is 0.\n\n",
              "markdownDescription": "\nA Array used to control UDP noise\uff0cunder some circumstances it can bypass some udp based protocol restrictions.\nxray will loop through this array and send each noise packet one by one\n\n`\"type\"`\uff1aThree types are supported. \"rand\" generates a random byte , \"str\" uses a user input string, \"base64\" uses a user input base64 encoded string\n\n`\"packet\"`\uff1aIf type is set to \"rand\" this field will take a range \"50-100\" or a single value \"50\"\n\nif type is set to \"str\" this field will take a string\n\nif type is set to \"base64\" this field will take a base64 encoded string\n\n`\"delay\"`\uff1adelay before sending real data (ms). can be a string range like \"10-20\" or a single integer\n\nIf not specified, the default value is 0.\n\n",
              "type": "array",
              "items": {
                "type": "object"
              }
            },
            "proxyProtocol": {
              "name": "proxyProtocol",
              "description": "\nThe value of `proxyProtocol` represents the PROXY Protocol version. default value is `0`.\n# Socks\n\nThe Socks protocol is a standard protocol implementation that is compatible with [Socks 5](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol).\n\n::: danger\nThe Socks protocol does not provide encryption for transmission and is not suitable for transmitting data over public networks.\n:::\n\n",
              "markdownDescription": "\nThe value of `proxyProtocol` represents the PROXY Protocol version. default value is `0`.\n# Socks\n\nThe Socks protocol is a standard protocol implementation that is compatible with [Socks 5](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol).\n\n::: danger\nThe Socks protocol does not provide encryption for transmission and is not suitable for transmitting data over public networks.\n:::\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"users\": [\n        {\n          \"user\": \"test user\",\n          \"pass\": \"test pass\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"users\": [\n        {\n          \"user\": \"test user\",\n          \"pass\": \"test pass\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "servers": {
              "name": "servers",
              "description": "\nAn array representing a list of Socks servers, where each item is a server configuration.\n\n",
              "markdownDescription": "\nAn array representing a list of Socks servers, where each item is a server configuration.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServerObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"secretKey\": \"PRIVATE_KEY\",\n  \"address\": [\n    // optional, default [\"10.0.0.1\", \"fd59:7153:2388:b5fd:0000:0000:0000:0001\"]\n    \"IPv4_CIDR\",\n    \"IPv6_CIDR\",\n    \"and more...\"\n  ],\n  \"peers\": [\n    {\n      \"endpoint\": \"ENDPOINT_ADDR\",\n      \"publicKey\": \"PUBLIC_KEY\"\n    }\n  ],\n  \"mtu\": 1420, // optional, default 1420\n  \"reserved\": [1, 2, 3],\n  \"workers\": 2 // optional, default runtime.NumCPU()\n  \"domainStrategy\": \"ForceIP\"\n}\n```\n\n::: tip\nCurrently, the Wireguard protocol outbound does not support setting `streamSettings`.\n:::\n\n",
          "markdownDescription": "\n```json\n{\n  \"secretKey\": \"PRIVATE_KEY\",\n  \"address\": [\n    // optional, default [\"10.0.0.1\", \"fd59:7153:2388:b5fd:0000:0000:0000:0001\"]\n    \"IPv4_CIDR\",\n    \"IPv6_CIDR\",\n    \"and more...\"\n  ],\n  \"peers\": [\n    {\n      \"endpoint\": \"ENDPOINT_ADDR\",\n      \"publicKey\": \"PUBLIC_KEY\"\n    }\n  ],\n  \"mtu\": 1420, // optional, default 1420\n  \"reserved\": [1, 2, 3],\n  \"workers\": 2 // optional, default runtime.NumCPU()\n  \"domainStrategy\": \"ForceIP\"\n}\n```\n\n::: tip\nCurrently, the Wireguard protocol outbound does not support setting `streamSettings`.\n:::\n\n",
          "properties": {
            "secretKey": {
              "name": "secretKey",
              "description": "\nThe user's private key. Required.\n\n",
              "markdownDescription": "\nThe user's private key. Required.\n\n",
              "type": "string"
            },
            "address": {
              "name": "address",
              "description": "\nWireguard will create a virtual network interface `tun` locally. Use one or more IP addresses, including IPv6.\n\n",
              "markdownDescription": "\nWireguard will create a virtual network interface `tun` locally. Use one or more IP addresses, including IPv6.\n\n",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "mtu": {
              "name": "mtu",
              "description": "\nThe fragment size of the underlying `tun` device in Wireguard.\n\n> `reserved` \\[ number \\]\n\nWireguard Reserved Bytes.\n\nXray-core v1.8.0 New parameter.<br>\nWhen connecting to warp via wireguard, due to cloudflare limitations, some IPs in Hong Kong and Los Angeles need to have a `reserved` value in order to connect successfully.<br>\nThe value of `reserved` can be obtained using third-party tools such as [warp-reg](https://github.com/badafans/warp-reg), [warp-reg.sh](https://github.com/chise0713/warp-reg.sh).\u3002\n\n",
              "markdownDescription": "\nThe fragment size of the underlying `tun` device in Wireguard.\n\n> `reserved` \\[ number \\]\n\nWireguard Reserved Bytes.\n\nXray-core v1.8.0 New parameter.<br>\nWhen connecting to warp via wireguard, due to cloudflare limitations, some IPs in Hong Kong and Los Angeles need to have a `reserved` value in order to connect successfully.<br>\nThe value of `reserved` can be obtained using third-party tools such as [warp-reg](https://github.com/badafans/warp-reg), [warp-reg.sh](https://github.com/chise0713/warp-reg.sh).\u3002\n\n",
              "type": "integer"
            },
            "workers": {
              "name": "workers",
              "description": "\nThe number of threads used by Wireguard.\n\n",
              "markdownDescription": "\nThe number of threads used by Wireguard.\n\n",
              "type": "integer"
            },
            "peers": {
              "name": "peers",
              "description": "\nA list of Wireguard servers, where each item is a server configuration.\n\n",
              "markdownDescription": "\nA list of Wireguard servers, where each item is a server configuration.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Peers"
              }
            },
            "domainStrategy": {
              "name": "domainStrategy",
              "description": "\nXray-core v1.8.6 New parameter.<br>\nIf you do not write this parameter, or leave it blank, the default value is `\"ForceIP\"`.<br>\nWhen the destination address is a domain name, use the Xray-core [built-in DNS server](./dns.md) to get an IP (if no `\"dns\"` configuration is written, system DNS is used), and send a connection to this IP via wireguard.<br>\n\n| domainStrategy | test-ipv6.com | bgp.he.net | chat.openai.com |\n| :--- | :---: | :---: | :---: |\n| ForceIPv6v4 | IPv6v4 | IPv6 | IPv6 |\n| ForceIPv6 | The website won't open. | IPv6 | IPv6 |\n| ForceIPv4v6 | IPv6v4 **1** | IPv4 | IPv4 |\n| ForceIPv4 | IPv4 | IPv4 | IPv4 |\n| ForceIP | IPv6v4 **2** | IPv6 | IPv6 |\n\n**1\uff1a** Tip `You already have an IPv6 address, but your browser is less inclined to use it, which is more worrying. `<br>\n**2\uff1a** The chances of prompting `You already have an IPv6 address, but your browser is less inclined to use it, which is more worrisome. `\n\n**Note 1**\uff1a\n- Conflicts with `\"queryStrategy\"` may cause the site to fail to open.\n- For example when `domainStrategy: \"ForceIPv4\"` is used, geosite:openai's site with `\"queryStrategy\": \"UseIPv6\"` will fail to open.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:openai\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // Query only AAAA records.\n            }\n        ],\n        \"queryStrategy\": \"UseIP\" // If this parameter is not written, the default value is UseIP, i.e. both A and AAAA records are queried, optional values are UseIPv4 and UseIPv6, other record types are queried by the system DNS.\n    },\n```\n\n**Note 2**\uff1a\n- Xray-core v1.8.0 - v1.8.4 without `\"domainStrategy\"`.\n- When the destination address is a domain name, use the Xray-core built-in DNS server query to obtain the IP, using the value of `\"queryStrategy\"` in the `\"dns\"` configuration to control the IPv4 or IPv6 priority.\n- If the `\"dns\"` configuration is not written, the system DNS query is used to obtain IP, and the IPv4 or IPv6 priority is controlled by the system.\n\n",
              "markdownDescription": "\nXray-core v1.8.6 New parameter.<br>\nIf you do not write this parameter, or leave it blank, the default value is `\"ForceIP\"`.<br>\nWhen the destination address is a domain name, use the Xray-core [built-in DNS server](./dns.md) to get an IP (if no `\"dns\"` configuration is written, system DNS is used), and send a connection to this IP via wireguard.<br>\n\n| domainStrategy | test-ipv6.com | bgp.he.net | chat.openai.com |\n| :--- | :---: | :---: | :---: |\n| ForceIPv6v4 | IPv6v4 | IPv6 | IPv6 |\n| ForceIPv6 | The website won't open. | IPv6 | IPv6 |\n| ForceIPv4v6 | IPv6v4 **1** | IPv4 | IPv4 |\n| ForceIPv4 | IPv4 | IPv4 | IPv4 |\n| ForceIP | IPv6v4 **2** | IPv6 | IPv6 |\n\n**1\uff1a** Tip `You already have an IPv6 address, but your browser is less inclined to use it, which is more worrying. `<br>\n**2\uff1a** The chances of prompting `You already have an IPv6 address, but your browser is less inclined to use it, which is more worrisome. `\n\n**Note 1**\uff1a\n- Conflicts with `\"queryStrategy\"` may cause the site to fail to open.\n- For example when `domainStrategy: \"ForceIPv4\"` is used, geosite:openai's site with `\"queryStrategy\": \"UseIPv6\"` will fail to open.\n\n```jsonc\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:openai\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // Query only AAAA records.\n            }\n        ],\n        \"queryStrategy\": \"UseIP\" // If this parameter is not written, the default value is UseIP, i.e. both A and AAAA records are queried, optional values are UseIPv4 and UseIPv6, other record types are queried by the system DNS.\n    },\n```\n\n**Note 2**\uff1a\n- Xray-core v1.8.0 - v1.8.4 without `\"domainStrategy\"`.\n- When the destination address is a domain name, use the Xray-core built-in DNS server query to obtain the IP, using the value of `\"queryStrategy\"` in the `\"dns\"` configuration to control the IPv4 or IPv6 priority.\n- If the `\"dns\"` configuration is not written, the system DNS query is used to obtain IP, and the IPv4 or IPv6 priority is controlled by the system.\n\n",
              "anyOf": [
                {
                  "const": "ForceIPv6v4"
                },
                {
                  "const": "ForceIPv6"
                },
                {
                  "const": "ForceIPv4v6"
                },
                {
                  "const": "ForceIPv4"
                },
                {
                  "const": "ForceIP"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"vnext\": [\n    {\n      \"address\": \"example.com\",\n      \"port\": 443,\n      \"users\": [\n        {\n          \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n          \"encryption\": \"none\",\n          \"flow\": \"xtls-rprx-vision\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"vnext\": [\n    {\n      \"address\": \"example.com\",\n      \"port\": 443,\n      \"users\": [\n        {\n          \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n          \"encryption\": \"none\",\n          \"flow\": \"xtls-rprx-vision\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "vnext": {
              "name": "vnext",
              "description": "\nAn array, representing the VLESS server list, containing a set of configurations pointing to the server, each of which is a server configuration.\n\n",
              "markdownDescription": "\nAn array, representing the VLESS server list, containing a set of configurations pointing to the server, each of which is a server configuration.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServerObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"password\": \"password\",\n      \"email\": \"love@xray.com\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"password\": \"password\",\n      \"email\": \"love@xray.com\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "servers": {
              "name": "servers",
              "description": "\nAn array representing a list of servers, where each item is a [ServerObject](#serverobject).\n\n",
              "markdownDescription": "\nAn array representing a list of servers, where each item is a [ServerObject](#serverobject).\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServerObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"response\": {\n    \"type\": \"none\"\n  }\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"response\": {\n    \"type\": \"none\"\n  }\n}\n```\n\n",
          "properties": {
            "response": {
              "name": "response",
              "description": "\nConfigures the response data for the blackhole.\n\nAfter receiving the data to be forwarded, the blackhole will send the specified response data and then close the connection. The data to be forwarded will be discarded. If this field is not specified, the blackhole will simply close the connection.\n\n",
              "markdownDescription": "\nConfigures the response data for the blackhole.\n\nAfter receiving the data to be forwarded, the blackhole will send the specified response data and then close the connection. The data to be forwarded will be discarded. If this field is not specified, the blackhole will simply close the connection.\n\n",
              "$ref": "#/definitions/ResponseObject"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"network\": \"tcp\",\n  \"address\": \"1.1.1.1\",\n  \"port\": 53,\n  \"nonIPQuery\": \"drop\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"network\": \"tcp\",\n  \"address\": \"1.1.1.1\",\n  \"port\": 53,\n  \"nonIPQuery\": \"drop\"\n}\n```\n\n",
          "properties": {
            "network": {
              "name": "network",
              "description": "\nModifies the transport layer protocol for DNS traffic. The possible values are `\"tcp\"` and `\"udp\"`. When not specified, the original transport method will be retained.\n\n",
              "markdownDescription": "\nModifies the transport layer protocol for DNS traffic. The possible values are `\"tcp\"` and `\"udp\"`. When not specified, the original transport method will be retained.\n\n",
              "anyOf": [
                {
                  "const": "tcp"
                },
                {
                  "const": "udp"
                }
              ]
            },
            "address": {
              "name": "address",
              "description": "\nModifies the DNS server address. When not specified, the original address specified in the source will be retained.\n\n",
              "markdownDescription": "\nModifies the DNS server address. When not specified, the original address specified in the source will be retained.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nModifies the DNS server port. When not specified, the original port specified in the source will be retained.\n\n",
              "markdownDescription": "\nModifies the DNS server port. When not specified, the original port specified in the source will be retained.\n\n",
              "type": "number"
            },
            "nonIPQuery": {
              "name": "nonIPQuery",
              "description": "\nControl non IP queries (neither A or AAAA), `\"drop\"` this request or `\"skip\"` processing in DNS module\uff0cthe request will be forwarded to target. By default is `\"drop\"`.\n\n",
              "markdownDescription": "\nControl non IP queries (neither A or AAAA), `\"drop\"` this request or `\"skip\"` processing in DNS module\uff0cthe request will be forwarded to target. By default is `\"drop\"`.\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"servers\": [\n    {\n      \"email\": \"love@xray.com\",\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"method\": \"encryption method\",\n      \"password\": \"password\",\n      \"uot\": true,\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"servers\": [\n    {\n      \"email\": \"love@xray.com\",\n      \"address\": \"127.0.0.1\",\n      \"port\": 1234,\n      \"method\": \"encryption method\",\n      \"password\": \"password\",\n      \"uot\": true,\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "servers": {
              "name": "servers",
              "description": "\nAn array representing a group of Shadowsocks server settings, where each item is a [ServerObject](#serverobject).\n\n",
              "markdownDescription": "\nAn array representing a group of Shadowsocks server settings, where each item is a [ServerObject](#serverobject).\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServerObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"vnext\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 37192,\n      \"users\": [\n        {\n          \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n          \"security\": \"auto\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n> `vnext`\uff1a\\[ [ServerObject](#serverobject) \\]\n\nAn array containing a set of server configurations.\n\nEach item in the array is a server configuration [ServerObject](#serverobject).\n\n",
          "markdownDescription": "\n```json\n{\n  \"vnext\": [\n    {\n      \"address\": \"127.0.0.1\",\n      \"port\": 37192,\n      \"users\": [\n        {\n          \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n          \"security\": \"auto\",\n          \"level\": 0\n        }\n      ]\n    }\n  ]\n}\n```\n\n> `vnext`\uff1a\\[ [ServerObject](#serverobject) \\]\n\nAn array containing a set of server configurations.\n\nEach item in the array is a server configuration [ServerObject](#serverobject).\n\n",
          "properties": {},
          "additionalProperties": true
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"192.168.108.1\",\n      \"port\": 3128,\n      \"users\": [\n        {\n          \"user\": \"my-username\",\n          \"pass\": \"my-password\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n::: tip\nCurrently, in the HTTP outbound protocol, the `streamSettings` configuration with `security` and `tlsSettings` is effective.\n:::\n\n",
          "markdownDescription": "\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"192.168.108.1\",\n      \"port\": 3128,\n      \"users\": [\n        {\n          \"user\": \"my-username\",\n          \"pass\": \"my-password\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n::: tip\nCurrently, in the HTTP outbound protocol, the `streamSettings` configuration with `security` and `tlsSettings` is effective.\n:::\n\n",
          "properties": {
            "servers": {
              "name": "servers",
              "description": "\nA list of HTTP servers, where each item represents a server configuration. If multiple servers are configured, they will be used in a round-robin manner.\n\n",
              "markdownDescription": "\nA list of HTTP servers, where each item represents a server configuration. If multiple servers are configured, they will be used in a round-robin manner.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ServerObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "OutboundConfigurationObject",
          "description": "\n```json\n{\n  \"inboundTag\": \"TagUseAsInbound\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"inboundTag\": \"TagUseAsInbound\"\n}\n```\n\n",
          "properties": {
            "inboundTag": {
              "name": "inboundTag",
              "description": "\nUse as an inbound tag for routing.\n\nThis tag can be used as `inboundTag` in routing rules, all traffics going through this outbound can be rerouted with routing rules with corresponding inbound tag.\n\n",
              "markdownDescription": "\nUse as an inbound tag for routing.\n\nThis tag can be used as `inboundTag` in routing rules, all traffics going through this outbound can be rerouted with routing rules with corresponding inbound tag.\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ServerObject": {
      "anyOf": [
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"users\": [\n    {\n      \"user\": \"test user\",\n      \"pass\": \"test pass\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"users\": [\n    {\n      \"user\": \"test user\",\n      \"pass\": \"test pass\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nThe server address. Required.\n\n::: tip\nOnly connections to Socks 5 servers are supported.\n:::\n\n",
              "markdownDescription": "\nThe server address. Required.\n\n::: tip\nOnly connections to Socks 5 servers are supported.\n:::\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe server port. Required.\n\n",
              "markdownDescription": "\nThe server port. Required.\n\n",
              "type": "number"
            },
            "users": {
              "name": "users",
              "description": "\nAn array representing a list of users. Each item in the array is a user configuration.\n\nWhen the list is not empty, the Socks client will authenticate using the user information. If not specified, no authentication is performed.\n\nThe default value is an empty array.\n\n",
              "markdownDescription": "\nAn array representing a list of users. Each item in the array is a user configuration.\n\nWhen the list is not empty, the Socks client will authenticate using the user information. If not specified, no authentication is performed.\n\nThe default value is an empty array.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/UserObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"address\": \"example.com\",\n  \"port\": 443,\n  \"users\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"encryption\": \"none\",\n      \"flow\": \"xtls-rprx-vision\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"example.com\",\n  \"port\": 443,\n  \"users\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"encryption\": \"none\",\n      \"flow\": \"xtls-rprx-vision\",\n      \"level\": 0\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nServer address, pointing to the server, supporting domain names, IPv4, and IPv6.\n\n",
              "markdownDescription": "\nServer address, pointing to the server, supporting domain names, IPv4, and IPv6.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nServer port, usually the same as the port listened by the server.\n\n",
              "markdownDescription": "\nServer port, usually the same as the port listened by the server.\n\n",
              "type": "number"
            },
            "users": {
              "name": "users",
              "description": "\nArray, a list of users recognized by the server, each of which is a user configuration.\n\n",
              "markdownDescription": "\nArray, a list of users recognized by the server, each of which is a user configuration.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/UserObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"password\": \"password\",\n  \"email\": \"love@xray.com\",\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"password\": \"password\",\n  \"email\": \"love@xray.com\",\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nThe server address, which can be an IPv4, IPv6, or domain name. Required.\n\n",
              "markdownDescription": "\nThe server address, which can be an IPv4, IPv6, or domain name. Required.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe server port, usually the same port that the server is listening on.\n\n",
              "markdownDescription": "\nThe server port, usually the same port that the server is listening on.\n\n",
              "type": "number"
            },
            "password": {
              "name": "password",
              "description": "\nThe password for authentication. Required. It can be any string.\n\n",
              "markdownDescription": "\nThe password for authentication. Required. It can be any string.\n\n",
              "type": "string"
            },
            "email": {
              "name": "email",
              "description": "\nThe email address, optional, used to identify the user.\n\n",
              "markdownDescription": "\nThe email address, optional, used to identify the user.\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Blackhole\n\nBlackhole is an outbound data protocol that blocks all outbound data. When used in conjunction with [routing configurations](../routing.md), it can be used to block access to certain websites.\n\n",
              "markdownDescription": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Blackhole\n\nBlackhole is an outbound data protocol that blocks all outbound data. When used in conjunction with [routing configurations](../routing.md), it can be used to block access to certain websites.\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"email\": \"love@xray.com\",\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"method\": \"encryption method\",\n  \"password\": \"password\",\n  \"uot\": true,\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"email\": \"love@xray.com\",\n  \"address\": \"127.0.0.1\",\n  \"port\": 1234,\n  \"method\": \"encryption method\",\n  \"password\": \"password\",\n  \"uot\": true,\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "email": {
              "name": "email",
              "description": "\nEmail address (optional) used to identify the user.\n\n",
              "markdownDescription": "\nEmail address (optional) used to identify the user.\n\n",
              "type": "string"
            },
            "address": {
              "name": "address",
              "description": "\nThe address of the Shadowsocks server, supporting IPv4, IPv6, and domain names. Required.\n\n",
              "markdownDescription": "\nThe address of the Shadowsocks server, supporting IPv4, IPv6, and domain names. Required.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe port of the Shadowsocks server. Required.\n\n",
              "markdownDescription": "\nThe port of the Shadowsocks server. Required.\n\n",
              "type": "number"
            },
            "method": {
              "name": "method",
              "description": "\nEncryption method. Required.\n\n",
              "markdownDescription": "\nEncryption method. Required.\n\n",
              "type": "string"
            },
            "password": {
              "name": "password",
              "description": "\nPassword. Required.\n\n",
              "markdownDescription": "\nPassword. Required.\n\n",
              "type": "string"
            },
            "uot": {
              "name": "uot",
              "description": "\nWhen enabled, UDP over TCP (UOT) will be used.\n\n- Shadowsocks 2022\n\nUse a pre-shared key (PSK) similar to WireGuard as the password.\n\nTo generate a compatible key with shadowsocks-rust, use `openssl rand -base64 <length>`, where the length depends on the encryption method used.\n\n| Encryption Method             | Key Length |\n| ----------------------------- | ---------: |\n| 2022-blake3-aes-128-gcm       |         16 |\n| 2022-blake3-aes-256-gcm       |         32 |\n| 2022-blake3-chacha20-poly1305 |         32 |\n\nIn the Go implementation, a 32-byte key always works.\n\n- Other encryption methods\n\nAny string can be used as a password. There is no limit on the password length, but shorter passwords are more susceptible to cracking. It is recommended to use a password of 16 characters or longer.\n\n",
              "markdownDescription": "\nWhen enabled, UDP over TCP (UOT) will be used.\n\n- Shadowsocks 2022\n\nUse a pre-shared key (PSK) similar to WireGuard as the password.\n\nTo generate a compatible key with shadowsocks-rust, use `openssl rand -base64 <length>`, where the length depends on the encryption method used.\n\n| Encryption Method             | Key Length |\n| ----------------------------- | ---------: |\n| 2022-blake3-aes-128-gcm       |         16 |\n| 2022-blake3-aes-256-gcm       |         32 |\n| 2022-blake3-chacha20-poly1305 |         32 |\n\nIn the Go implementation, a 32-byte key always works.\n\n- Other encryption methods\n\nAny string can be used as a password. There is no limit on the password length, but shorter passwords are more susceptible to cracking. It is recommended to use a password of 16 characters or longer.\n\n",
              "type": "boolean"
            },
            "level": {
              "name": "level",
              "description": "\nUser level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# VMess\n\n[VMess](../../development/protocols/vmess.md) is an encrypted transport protocol commonly used as a bridge between Xray clients and servers.\n\n::: danger\nVMess relies on system time. Please ensure that the UTC time of your system, when using Xray, has an error within 120 seconds, regardless of the time zone. On Linux systems, you can install the `ntp` service to automatically synchronize the system time.\n:::\n\n",
              "markdownDescription": "\nUser level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# VMess\n\n[VMess](../../development/protocols/vmess.md) is an encrypted transport protocol commonly used as a bridge between Xray clients and servers.\n\n::: danger\nVMess relies on system time. Please ensure that the UTC time of your system, when using Xray, has an error within 120 seconds, regardless of the time zone. On Linux systems, you can install the `ntp` service to automatically synchronize the system time.\n:::\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 37192,\n  \"users\": []\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"127.0.0.1\",\n  \"port\": 37192,\n  \"users\": []\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nThe server address, which can be an IP address or domain name.\n\n",
              "markdownDescription": "\nThe server address, which can be an IP address or domain name.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe port number that the server is listening on. Required.\n\n",
              "markdownDescription": "\nThe port number that the server is listening on. Required.\n\n",
              "type": "number"
            },
            "users": {
              "name": "users",
              "description": "\nAn array representing a group of users authorized by the server.\n\nEach item is a user configuration [UserObject](#userobject).\n\n",
              "markdownDescription": "\nAn array representing a group of users authorized by the server.\n\nEach item is a user configuration [UserObject](#userobject).\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/UserObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ServerObject",
          "description": "\n```json\n{\n  \"address\": \"192.168.108.1\",\n  \"port\": 3128,\n  \"users\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"192.168.108.1\",\n  \"port\": 3128,\n  \"users\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nThe address of the HTTP proxy server. Required.\n\n",
              "markdownDescription": "\nThe address of the HTTP proxy server. Required.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe port of the HTTP proxy server. Required.\n\n",
              "markdownDescription": "\nThe port of the HTTP proxy server. Required.\n\n",
              "type": "integer"
            },
            "user": {
              "name": "user",
              "description": "\nAn array of user accounts. Default value is an empty array.\n\n",
              "markdownDescription": "\nAn array of user accounts. Default value is an empty array.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/AccountObject"
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "UserObject": {
      "anyOf": [
        {
          "title": "UserObject",
          "description": "\n```json\n{\n  \"user\": \"test user\",\n  \"pass\": \"test pass\",\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"user\": \"test user\",\n  \"pass\": \"test pass\",\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "user": {
              "name": "user",
              "description": "\nThe username. Required.\n\n",
              "markdownDescription": "\nThe username. Required.\n\n",
              "type": "string"
            },
            "pass": {
              "name": "pass",
              "description": "\nThe password. Required.\n\n",
              "markdownDescription": "\nThe password. Required.\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Wireguard\n\nWireguard is a standard implementation of the Wireguard protocol.\n\n::: danger\n**The Wireguard protocol is not specifically designed for circumvention purposes. If used as the outer layer for circumvention, its characteristics may lead to server blocking.**\n:::\n\n",
              "markdownDescription": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Wireguard\n\nWireguard is a standard implementation of the Wireguard protocol.\n\n::: danger\n**The Wireguard protocol is not specifically designed for circumvention purposes. If used as the outer layer for circumvention, its characteristics may lead to server blocking.**\n:::\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "UserObject",
          "description": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"encryption\": \"none\",\n  \"flow\": \"xtls-rprx-vision\",\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"encryption\": \"none\",\n  \"flow\": \"xtls-rprx-vision\",\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "id": {
              "name": "id",
              "description": "\nThe user ID of VLESS, which can be any string less than 30 bytes, or a valid UUID.\nCustom strings and their mapped UUIDs are equivalent, which means you can write an id in the configuration file to identify the same user, i.e.\n\n- Write `\"id\": \"I love \ud83c\udf49 teacher 1314\"`,\n- Or write `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (this UUID is the UUID mapping of `I love \ud83c\udf49 teacher 1314`)\n\nThe mapping standard is in [VLESS UUID mapping standard: mapping custom strings to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158)\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID mapped by the custom string, or use the command `xray uuid` to generate a random UUID.\n\n",
              "markdownDescription": "\nThe user ID of VLESS, which can be any string less than 30 bytes, or a valid UUID.\nCustom strings and their mapped UUIDs are equivalent, which means you can write an id in the configuration file to identify the same user, i.e.\n\n- Write `\"id\": \"I love \ud83c\udf49 teacher 1314\"`,\n- Or write `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (this UUID is the UUID mapping of `I love \ud83c\udf49 teacher 1314`)\n\nThe mapping standard is in [VLESS UUID mapping standard: mapping custom strings to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158)\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID mapped by the custom string, or use the command `xray uuid` to generate a random UUID.\n\n",
              "type": "string"
            },
            "encryption": {
              "name": "encryption",
              "description": "\nNeed to fill in `\"none\"`, cannot be left empty.\n\nThis requirement is to remind users that there is no encryption and to prevent users from filling in the wrong attribute name or location, causing exposure when encryption methods come out in the future.\n\nIf the value of encryption is not set correctly, an error message will be received when using Xray or -test.\n\n",
              "markdownDescription": "\nNeed to fill in `\"none\"`, cannot be left empty.\n\nThis requirement is to remind users that there is no encryption and to prevent users from filling in the wrong attribute name or location, causing exposure when encryption methods come out in the future.\n\nIf the value of encryption is not set correctly, an error message will be received when using Xray or -test.\n\n",
              "const": "none"
            },
            "flow": {
              "name": "flow",
              "description": "\nFlow control mode, used to select the XTLS algorithm.\n\nCurrently, there are the following flow control modes available in the outbound protocol:\n\n- No `flow` or empty string: Use regular TLS proxy.\n- `xtls-rprx-vision`: using the new XTLS mode includes inner handshake random padding supports uTLS client fingerprint simulation\n- `xtls-rprx-vision-udp443`: same as `xtls-rprx-vision`, but allows UDP traffic with a destination of port 443\n\nAdditionally, XTLS currently only supports TCP+TLS/Reality.\n\n<!-- prettier-ignore -->\n::: tip About xtls-rprx-*-udp443 flow control mode\n\nWhen using Xray-core's XTLS, traffic to UDP port 443 is blocked by default (generally for QUIC), so the application will use TLS instead of QUIC, and XTLS will take effect. In fact, QUIC itself is not suitable for proxying because it has its own TCP functionality. When it is transmitted as UDP traffic through the VLESS protocol, the underlying protocol is TCP, which is equivalent to two layers of TCP.\n\nIf you do not need to block it, please fill in `xtls-rprx-*-udp443` on the client side and do not change the server side.\n:::\n\n::: tip About Splice mode\nSplice is a function provided by the Linux Kernel. The system kernel directly forwards TCP without going through Xray's memory, greatly reducing the number of data copies and CPU context switches.\n\nThe usage restrictions of Splice mode are:\n\n- Linux environment\n- Inbound protocols are `Dokodemo door`, `Socks`, `HTTP`, etc., pure TCP connections, or other inbound protocols that use XTLS\n- Outbound protocol is VLESS + XTLS\n- It is worth noting that when using the mKCP protocol, Splice will not be used (yes, although there is no error, it is not used at all)\n\nIn addition, when using Splice, the speed display will lag behind, which is a feature, not a bug.\n\nUsing Vision mode will automatically enable Splice if the above conditions are met.\n:::\n\n",
              "markdownDescription": "\nFlow control mode, used to select the XTLS algorithm.\n\nCurrently, there are the following flow control modes available in the outbound protocol:\n\n- No `flow` or empty string: Use regular TLS proxy.\n- `xtls-rprx-vision`: using the new XTLS mode includes inner handshake random padding supports uTLS client fingerprint simulation\n- `xtls-rprx-vision-udp443`: same as `xtls-rprx-vision`, but allows UDP traffic with a destination of port 443\n\nAdditionally, XTLS currently only supports TCP+TLS/Reality.\n\n<!-- prettier-ignore -->\n::: tip About xtls-rprx-*-udp443 flow control mode\n\nWhen using Xray-core's XTLS, traffic to UDP port 443 is blocked by default (generally for QUIC), so the application will use TLS instead of QUIC, and XTLS will take effect. In fact, QUIC itself is not suitable for proxying because it has its own TCP functionality. When it is transmitted as UDP traffic through the VLESS protocol, the underlying protocol is TCP, which is equivalent to two layers of TCP.\n\nIf you do not need to block it, please fill in `xtls-rprx-*-udp443` on the client side and do not change the server side.\n:::\n\n::: tip About Splice mode\nSplice is a function provided by the Linux Kernel. The system kernel directly forwards TCP without going through Xray's memory, greatly reducing the number of data copies and CPU context switches.\n\nThe usage restrictions of Splice mode are:\n\n- Linux environment\n- Inbound protocols are `Dokodemo door`, `Socks`, `HTTP`, etc., pure TCP connections, or other inbound protocols that use XTLS\n- Outbound protocol is VLESS + XTLS\n- It is worth noting that when using the mKCP protocol, Splice will not be used (yes, although there is no error, it is not used at all)\n\nIn addition, when using Splice, the speed display will lag behind, which is a feature, not a bug.\n\nUsing Vision mode will automatically enable Splice if the above conditions are met.\n:::\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nUser level, the connection will use the [local policy](../policy.md#levelpolicyobject) corresponding to this user level.\n\nThe value of level corresponds to the value of `level` in [policy](../policy.md#policyobject). If not specified, the default is 0.\n# Trojan\n\n[Trojan](https://trojan-gfw.github.io/trojan/protocol) protocol\n\n::: danger\nTrojan is designed to work with correctly configured encrypted TLS tunnels.\n:::\n\n",
              "markdownDescription": "\nUser level, the connection will use the [local policy](../policy.md#levelpolicyobject) corresponding to this user level.\n\nThe value of level corresponds to the value of `level` in [policy](../policy.md#policyobject). If not specified, the default is 0.\n# Trojan\n\n[Trojan](https://trojan-gfw.github.io/trojan/protocol) protocol\n\n::: danger\nTrojan is designed to work with correctly configured encrypted TLS tunnels.\n:::\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "UserObject",
          "description": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"security\": \"auto\",\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"security\": \"auto\",\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "id": {
              "name": "id",
              "description": "\nThe user ID for VMess, which can be any string less than 30 bytes or a valid UUID.\n\nCustom strings and their corresponding UUIDs are equivalent. This means that you can use either a custom string or its corresponding UUID to identify the same user in the configuration file. For example:\n\n- Write `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`,\n- Or write `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (this UUID is the mapping of the custom string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string, or use the command `xray uuid` to generate a random UUID.\n\n",
              "markdownDescription": "\nThe user ID for VMess, which can be any string less than 30 bytes or a valid UUID.\n\nCustom strings and their corresponding UUIDs are equivalent. This means that you can use either a custom string or its corresponding UUID to identify the same user in the configuration file. For example:\n\n- Write `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`,\n- Or write `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (this UUID is the mapping of the custom string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string, or use the command `xray uuid` to generate a random UUID.\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level. Connections will use the corresponding [local policy](../policy.md#levelpolicyobject) associated with this user level.\n\nThe `level` value corresponds to the `level` value in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            },
            "security": {
              "name": "security",
              "description": "\nThe encryption method. The client will use the configured encryption method to send data, and the server will automatically recognize it without the need for configuration.\n\n- `\"aes-128-gcm\"`: Recommended for use on PCs.\n- `\"chacha20-poly1305\"`: Recommended for use on mobile devices.\n- `\"auto\"`: Default value. Automatically selects the encryption method (uses aes-128-gcm when running on AMD64, ARM64, or s390x architecture, and Chacha20-Poly1305 in other cases).\n- `\"none\"`: No encryption.\n- `\"zero\"`: No encryption and no message authentication (v1.4.0+).\n\n::: tip\nIt is recommended to use the `\"auto\"` encryption method as it ensures long-term security and compatibility.\n\nThe `\"none\"` pseudo-encryption method calculates and verifies the packet's checksum. However, due to the lack of hardware support for the authentication algorithm, it may be slower than the hardware-accelerated `\"aes-128-gcm\"` on some platforms.\n\nThe `\"zero\"` pseudo-encryption method neither encrypts the message nor calculates the checksum, theoretically providing higher speed than any other encryption method. The actual speed may be influenced by other factors.\n\nIt is not recommended to use the `\"none\"` or `\"zero\"` pseudo-encryption methods without enabling TLS encryption and forcibly verifying certificates. If you use a CDN or other intermediate platforms or network environments that decrypt TLS connections, it is not recommended to use the `\"none\"` or `\"zero\"` pseudo-encryption methods.\n\nRegardless of the encryption method used, the VMess packet header is protected by encryption and authentication.\n:::\n# HTTP\n\nHTTP is a protocol that is used for communication over the internet. Please note that HTTP does not provide encryption for data transmission and is not suitable for transmitting sensitive information over public networks, as it can be easily targeted for attacks.\n\n::: danger\n**The HTTP protocol does not provide encryption for transmission, making it unsuitable for transmitting over public networks and more susceptible to being used as a compromised host for attacks.**\n:::\n\n::: tip\nHTTP can only proxy TCP protocols, and cannot handle UDP-based protocols.\n:::\n\n",
              "markdownDescription": "\nThe encryption method. The client will use the configured encryption method to send data, and the server will automatically recognize it without the need for configuration.\n\n- `\"aes-128-gcm\"`: Recommended for use on PCs.\n- `\"chacha20-poly1305\"`: Recommended for use on mobile devices.\n- `\"auto\"`: Default value. Automatically selects the encryption method (uses aes-128-gcm when running on AMD64, ARM64, or s390x architecture, and Chacha20-Poly1305 in other cases).\n- `\"none\"`: No encryption.\n- `\"zero\"`: No encryption and no message authentication (v1.4.0+).\n\n::: tip\nIt is recommended to use the `\"auto\"` encryption method as it ensures long-term security and compatibility.\n\nThe `\"none\"` pseudo-encryption method calculates and verifies the packet's checksum. However, due to the lack of hardware support for the authentication algorithm, it may be slower than the hardware-accelerated `\"aes-128-gcm\"` on some platforms.\n\nThe `\"zero\"` pseudo-encryption method neither encrypts the message nor calculates the checksum, theoretically providing higher speed than any other encryption method. The actual speed may be influenced by other factors.\n\nIt is not recommended to use the `\"none\"` or `\"zero\"` pseudo-encryption methods without enabling TLS encryption and forcibly verifying certificates. If you use a CDN or other intermediate platforms or network environments that decrypt TLS connections, it is not recommended to use the `\"none\"` or `\"zero\"` pseudo-encryption methods.\n\nRegardless of the encryption method used, the VMess packet header is protected by encryption and authentication.\n:::\n# HTTP\n\nHTTP is a protocol that is used for communication over the internet. Please note that HTTP does not provide encryption for data transmission and is not suitable for transmitting sensitive information over public networks, as it can be easily targeted for attacks.\n\n::: danger\n**The HTTP protocol does not provide encryption for transmission, making it unsuitable for transmitting over public networks and more susceptible to being used as a compromised host for attacks.**\n:::\n\n::: tip\nHTTP can only proxy TCP protocols, and cannot handle UDP-based protocols.\n:::\n\n",
              "anyOf": [
                {
                  "const": "aes-128-gcm"
                },
                {
                  "const": "chacha20-poly1305"
                },
                {
                  "const": "auto"
                },
                {
                  "const": "none"
                },
                {
                  "const": "zero"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Peers": {
      "anyOf": [
        {
          "title": "Peers",
          "description": "\n```json\n{\n  \"endpoint\": \"ENDPOINT_ADDR\",\n  \"publicKey\": \"PUBLIC_KEY\",\n  \"preSharedKey\": \"PRE_SHARED_KEY\", // optional, default \"0000000000000000000000000000000000000000000000000000000000000000\"\n  \"keepAlive\": 0, // optional, default 0\n  \"allowedIPs\": [\"0.0.0.0/0\"] // optional, default [\"0.0.0.0/0\", \"::/0\"]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"endpoint\": \"ENDPOINT_ADDR\",\n  \"publicKey\": \"PUBLIC_KEY\",\n  \"preSharedKey\": \"PRE_SHARED_KEY\", // optional, default \"0000000000000000000000000000000000000000000000000000000000000000\"\n  \"keepAlive\": 0, // optional, default 0\n  \"allowedIPs\": [\"0.0.0.0/0\"] // optional, default [\"0.0.0.0/0\", \"::/0\"]\n}\n```\n\n",
          "properties": {
            "endpoint": {
              "name": "endpoint",
              "description": "\nThe server address. Required.\n\nURL:port format, e.g. `engage.cloudflareclient.com:2408`.<br>\nIP:port format, e.g. `162.159.192.1:2408` or `[2606:4700:d0::a29f:c001]:2408`.\n\n",
              "markdownDescription": "\nThe server address. Required.\n\nURL:port format, e.g. `engage.cloudflareclient.com:2408`.<br>\nIP:port format, e.g. `162.159.192.1:2408` or `[2606:4700:d0::a29f:c001]:2408`.\n\n",
              "type": "string"
            },
            "publicKey": {
              "name": "publicKey",
              "description": "\nThe server's public key used for verification. Required.\n\n",
              "markdownDescription": "\nThe server's public key used for verification. Required.\n\n",
              "type": "string"
            },
            "preSharedKey": {
              "name": "preSharedKey",
              "description": "\nAn additional symmetric encryption key.\n\n",
              "markdownDescription": "\nAn additional symmetric encryption key.\n\n",
              "type": "string"
            },
            "keepAlive": {
              "name": "keepAlive",
              "description": "\nThe interval of keep-alive packets in seconds. The default is 0, which means no keep-alive.\n\n",
              "markdownDescription": "\nThe interval of keep-alive packets in seconds. The default is 0, which means no keep-alive.\n\n",
              "type": "integer"
            },
            "allowedIPs": {
              "name": "allowedIPs",
              "description": "\nOnly allow traffic from specific source IP addresses in Wireguard.\n# VLESS\n\n::: danger\nCurrently, VLESS does not have built-in encryption, please use it on a reliable channel, such as TLS.\n:::\n\nVLESS is a stateless lightweight transport protocol, which is divided into inbound and outbound parts, and can be used as a bridge between Xray clients and servers.\n\nUnlike [VMess](./vmess.md), VLESS does not rely on system time, and the authentication method is also UUID.\n\n",
              "markdownDescription": "\nOnly allow traffic from specific source IP addresses in Wireguard.\n# VLESS\n\n::: danger\nCurrently, VLESS does not have built-in encryption, please use it on a reliable channel, such as TLS.\n:::\n\nVLESS is a stateless lightweight transport protocol, which is divided into inbound and outbound parts, and can be used as a bridge between Xray clients and servers.\n\nUnlike [VMess](./vmess.md), VLESS does not rely on system time, and the authentication method is also UUID.\n\n",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "Peers",
          "description": "\n```json\n{\n  \"publicKey\": \"PUBLIC_KEY\",\n  \"allowedIPs\": [\"0.0.0.0/0\"] // optional, default [\"0.0.0.0/0\", \"::/0\"]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"publicKey\": \"PUBLIC_KEY\",\n  \"allowedIPs\": [\"0.0.0.0/0\"] // optional, default [\"0.0.0.0/0\", \"::/0\"]\n}\n```\n\n",
          "properties": {
            "publicKey": {
              "name": "publicKey",
              "description": "\nPublic key, used for verification.\n\n",
              "markdownDescription": "\nPublic key, used for verification.\n\n",
              "type": "string"
            },
            "allowedIPs": {
              "name": "allowedIPs",
              "description": "\nAllowed source IPs.\n# VLESS\n\n::: danger\nCurrently, VLESS does not provide built-in encryption. Please use it with a reliable channel, such as TLS.\n:::\n\nVLESS is a stateless lightweight transport protocol that consists of inbound and outbound parts. It can serve as a bridge between Xray clients and servers.\n\nUnlike [VMess](./vmess.md), VLESS does not rely on system time. The authentication method is still UUID-based.\n\n",
              "markdownDescription": "\nAllowed source IPs.\n# VLESS\n\n::: danger\nCurrently, VLESS does not provide built-in encryption. Please use it with a reliable channel, such as TLS.\n:::\n\nVLESS is a stateless lightweight transport protocol that consists of inbound and outbound parts. It can serve as a bridge between Xray clients and servers.\n\nUnlike [VMess](./vmess.md), VLESS does not rely on system time. The authentication method is still UUID-based.\n\n",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ResponseObject": {
      "title": "ResponseObject",
      "description": "\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "properties": {
        "type": {
          "name": "type",
          "description": "\nWhen `type` is set to `\"none\"` (default value), the blackhole will simply close the connection.\n\nWhen `type` is set to `\"http\"`, the blackhole will send a simple HTTP 403 packet as the response and then close the connection.\n# DNS\n\nDNS is an outbound protocol used for intercepting and forwarding DNS queries.\n\nThis outbound protocol can only handle DNS traffic, including queries based on UDP and TCP protocols. Other types of traffic will result in an error.\n\nWhen handling DNS queries, this outbound protocol will forward IP queries (A and AAAA) to the built-in [DNS server](../dns.md). Other types of query traffic will be forwarded to their original destination addresses.\n\n",
          "markdownDescription": "\nWhen `type` is set to `\"none\"` (default value), the blackhole will simply close the connection.\n\nWhen `type` is set to `\"http\"`, the blackhole will send a simple HTTP 403 packet as the response and then close the connection.\n# DNS\n\nDNS is an outbound protocol used for intercepting and forwarding DNS queries.\n\nThis outbound protocol can only handle DNS traffic, including queries based on UDP and TCP protocols. Other types of traffic will result in an error.\n\nWhen handling DNS queries, this outbound protocol will forward IP queries (A and AAAA) to the built-in [DNS server](../dns.md). Other types of query traffic will be forwarded to their original destination addresses.\n\n",
          "anyOf": [
            {
              "const": "http"
            },
            {
              "const": "none"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "DNS Configuration Example <Badge text=\"WIP\" type=\"warning\"/>": {
      "title": "DNS Configuration Example <Badge text=\"WIP\" type=\"warning\"/>",
      "description": "# Shadowsocks\n\n[Shadowsocks](https://en.wikipedia.org/wiki/Shadowsocks) protocol is compatible with most other implementations.\n\nHere are the features and compatibility of Shadowsocks:\n\n- It supports TCP and UDP packet forwarding, with the option to disable UDP.\n- Recommended encryption methods:\n  - 2022-blake3-aes-128-gcm\n  - 2022-blake3-aes-256-gcm\n  - 2022-blake3-chacha20-poly1305\n- Other encryption methods:\n  - aes-256-gcm\n  - aes-128-gcm\n  - chacha20-poly1305 (also known as chacha20-ietf-poly1305)\n  - none or plain\n\nThe new protocol format of Shadowsocks 2022 improves performance and includes full replay protection, addressing security issues present in the old protocol:\n\n- [Serious vulnerabilities in Shadowsocks AEAD encryption methods that compromise the integrity of communications](https://github.com/shadowsocks/shadowsocks-org/issues/183)\n- Increasing false-positive rate of TCP replay filters over time\n- Lack of replay protection for UDP\n- TCP behaviors that can be used for active probing\n\n::: danger\nUsing the \"none\" encryption method will transmit traffic in plaintext. It is not recommended to use \"none\" encryption on public networks to ensure security.\n:::\n\n",
      "markdownDescription": "# Shadowsocks\n\n[Shadowsocks](https://en.wikipedia.org/wiki/Shadowsocks) protocol is compatible with most other implementations.\n\nHere are the features and compatibility of Shadowsocks:\n\n- It supports TCP and UDP packet forwarding, with the option to disable UDP.\n- Recommended encryption methods:\n  - 2022-blake3-aes-128-gcm\n  - 2022-blake3-aes-256-gcm\n  - 2022-blake3-chacha20-poly1305\n- Other encryption methods:\n  - aes-256-gcm\n  - aes-128-gcm\n  - chacha20-poly1305 (also known as chacha20-ietf-poly1305)\n  - none or plain\n\nThe new protocol format of Shadowsocks 2022 improves performance and includes full replay protection, addressing security issues present in the old protocol:\n\n- [Serious vulnerabilities in Shadowsocks AEAD encryption methods that compromise the integrity of communications](https://github.com/shadowsocks/shadowsocks-org/issues/183)\n- Increasing false-positive rate of TCP replay filters over time\n- Lack of replay protection for UDP\n- TCP behaviors that can be used for active probing\n\n::: danger\nUsing the \"none\" encryption method will transmit traffic in plaintext. It is not recommended to use \"none\" encryption on public networks to ensure security.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "AccountObject": {
      "anyOf": [
        {
          "title": "AccountObject",
          "description": "\n```json\n{\n  \"user\": \"my-username\",\n  \"pass\": \"my-password\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"user\": \"my-username\",\n  \"pass\": \"my-password\"\n}\n```\n\n",
          "properties": {
            "user": {
              "name": "user",
              "description": "\nThe username. Required.\n\n",
              "markdownDescription": "\nThe username. Required.\n\n",
              "type": "string"
            },
            "pass": {
              "name": "pass",
              "description": "\nThe password. Required.\n# Loopback\n\nLoopback is an outbound protocol. It can send traffics through corresponding outbound to routing inbound, thus rerouting traffics to other routing rules without leaving Xray-core.\n\n",
              "markdownDescription": "\nThe password. Required.\n# Loopback\n\nLoopback is an outbound protocol. It can send traffics through corresponding outbound to routing inbound, thus rerouting traffics to other routing rules without leaving Xray-core.\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "AccountObject",
          "description": "\n```json\n{\n  \"user\": \"my-username\",\n  \"pass\": \"my-password\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"user\": \"my-username\",\n  \"pass\": \"my-password\"\n}\n```\n\n",
          "properties": {
            "user": {
              "name": "user",
              "description": "\nThe username as a string. Required.\n\n",
              "markdownDescription": "\nThe username as a string. Required.\n\n",
              "type": "string"
            },
            "pass": {
              "name": "pass",
              "description": "\nThe password as a string. Required.\n# Wireguard\n\nUser-space implementation of the Wireguard protocol.\n\n::: danger\n**The Wireguard protocol is not specifically designed for circumvention purposes. If used as the outer layer for circumvention, its characteristics may lead to server blocking.**\n:::\n\n",
              "markdownDescription": "\nThe password as a string. Required.\n# Wireguard\n\nUser-space implementation of the Wireguard protocol.\n\n::: danger\n**The Wireguard protocol is not specifically designed for circumvention purposes. If used as the outer layer for circumvention, its characteristics may lead to server blocking.**\n:::\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "How to use?": {
      "anyOf": [
        {
          "title": "How to use?",
          "description": "\nIf you need to do some more detailed routing for traffics that have been routed by routing rules, like splitting routed traffics to TCP traffics and UDP traffics and send them to different outbounds, this can be done with `loopback` outbound.\n\n``` jsonc\n{\n  \"outbounds\": [\n    {\n      \"protocol\": \"loopback\",\n      \"tag\": \"need-to-split\",\n      \"settings\": {\n        \"inboundTag\": \"traffic-input\" // This tag will be used as the inboundTag inside the RuleObject \n      }\n    },\n    {\n      \"tag\": \"tcp-output\",\n      // protocol, settings, streamSettings etc.\n    },\n    {\n      \"tag\": \"udp-output\",\n      // protocol, settings, streamSettings etc.\n    }\n  ],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"inboundTag\": [\"traffic-input\"], // tag set in the loopback outbound setting\n        \"network\": \"tcp\",\n        \"outboundTag\": \"tcp-output\"\n      },\n      {\n        \"inboundTag\": [\"traffic-input\"], // tag set in the loopback outbound \n        \"network\": \"udp\",\n        \"outboundTag\": \"udp-output\"\n      }\n    ]\n  }\n}\n```\n# Traffic Statistics\n\nUsed to configure traffic statistics for Xray.\n\n",
          "markdownDescription": "\nIf you need to do some more detailed routing for traffics that have been routed by routing rules, like splitting routed traffics to TCP traffics and UDP traffics and send them to different outbounds, this can be done with `loopback` outbound.\n\n``` jsonc\n{\n  \"outbounds\": [\n    {\n      \"protocol\": \"loopback\",\n      \"tag\": \"need-to-split\",\n      \"settings\": {\n        \"inboundTag\": \"traffic-input\" // This tag will be used as the inboundTag inside the RuleObject \n      }\n    },\n    {\n      \"tag\": \"tcp-output\",\n      // protocol, settings, streamSettings etc.\n    },\n    {\n      \"tag\": \"udp-output\",\n      // protocol, settings, streamSettings etc.\n    }\n  ],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"inboundTag\": [\"traffic-input\"], // tag set in the loopback outbound setting\n        \"network\": \"tcp\",\n        \"outboundTag\": \"tcp-output\"\n      },\n      {\n        \"inboundTag\": [\"traffic-input\"], // tag set in the loopback outbound \n        \"network\": \"udp\",\n        \"outboundTag\": \"udp-output\"\n      }\n    ]\n  }\n}\n```\n# Traffic Statistics\n\nUsed to configure traffic statistics for Xray.\n\n",
          "properties": {},
          "additionalProperties": true
        },
        {
          "title": "How to use?",
          "description": "\nFakeDNS is essentially a [DNS server](./dns.md#serverobject) that can be used in conjunction with any DNS rules.\n\nOnly by routing DNS queries to FakeDNS can it be effective.\n\n```json\n{\n  \"dns\": {\n    \"servers\": [\n      \"fakedns\", // fakedns comes first\n      \"8.8.8.8\"\n    ]\n  },\n  \"outbounds\": [\n    {\n      \"protocol\": \"dns\",\n      \"tag\": \"dns-out\"\n    }\n  ],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"type\": \"field\",\n        \"inboundTag\": [\"dns-in\"], // Intercept DNS traffic from DNS query inbound or from inbound traffic of transparent proxies.\n        \"port\": 53,\n        \"outboundTag\": \"dns-out\"\n      }\n    ]\n  }\n}\n```\n\nWhen external DNS requests enter the FakeDNS component, it will return IP addresses within its own `ipPool` as the virtual resolution results of the domain name, and record the mapping relationship between the domain name and the virtual resolution results.\n\nIn addition, you need to enable `Sniffing` in the **client** for incoming traffic that needs to be proxied, and use the `fakedns` target address reset.\n\n```json\n\"sniffing\": {\n  \"enabled\": true,\n  \"destOverride\": [\"fakedns\"], // Use \"fakedns\", or use it with other sniffer, or directly use \"fakedns+others\".\n  \"metadataOnly\": false        // When this item is true, destOverride can only use fakedns.\n},\n```\n\n::: warning\nIf the FakeIP is not correctly restored to the domain name, the server will not be accessible.\n:::\n\n",
          "markdownDescription": "\nFakeDNS is essentially a [DNS server](./dns.md#serverobject) that can be used in conjunction with any DNS rules.\n\nOnly by routing DNS queries to FakeDNS can it be effective.\n\n```json\n{\n  \"dns\": {\n    \"servers\": [\n      \"fakedns\", // fakedns comes first\n      \"8.8.8.8\"\n    ]\n  },\n  \"outbounds\": [\n    {\n      \"protocol\": \"dns\",\n      \"tag\": \"dns-out\"\n    }\n  ],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"type\": \"field\",\n        \"inboundTag\": [\"dns-in\"], // Intercept DNS traffic from DNS query inbound or from inbound traffic of transparent proxies.\n        \"port\": 53,\n        \"outboundTag\": \"dns-out\"\n      }\n    ]\n  }\n}\n```\n\nWhen external DNS requests enter the FakeDNS component, it will return IP addresses within its own `ipPool` as the virtual resolution results of the domain name, and record the mapping relationship between the domain name and the virtual resolution results.\n\nIn addition, you need to enable `Sniffing` in the **client** for incoming traffic that needs to be proxied, and use the `fakedns` target address reset.\n\n```json\n\"sniffing\": {\n  \"enabled\": true,\n  \"destOverride\": [\"fakedns\"], // Use \"fakedns\", or use it with other sniffer, or directly use \"fakedns+others\".\n  \"metadataOnly\": false        // When this item is true, destOverride can only use fakedns.\n},\n```\n\n::: warning\nIf the FakeIP is not correctly restored to the domain name, the server will not be accessible.\n:::\n\n",
          "properties": {},
          "additionalProperties": true
        }
      ]
    },
    "StatsObject": {
      "title": "StatsObject",
      "description": "\nThe `StatsObject` corresponds to the `stats` item in the configuration file.\n\n```json\n{\n  \"stats\": {}\n}\n```\n\nCurrently, no parameters are required for traffic statistics, and internal statistics will be enabled as long as the `StatsObject` item exists.\n\nAfter statistics are enabled, you only need to enable the corresponding items in the [Policy](./policy.md) to collect the corresponding data.\n\n",
      "markdownDescription": "\nThe `StatsObject` corresponds to the `stats` item in the configuration file.\n\n```json\n{\n  \"stats\": {}\n}\n```\n\nCurrently, no parameters are required for traffic statistics, and internal statistics will be enabled as long as the `StatsObject` item exists.\n\nAfter statistics are enabled, you only need to enable the corresponding items in the [Policy](./policy.md) to collect the corresponding data.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Retrieving Traffic Statistics": {
      "title": "Retrieving Traffic Statistics",
      "description": "\nYou can use the `xray api` command to retrieve traffic statistics.\n\nThe current traffic statistics are as follows:\n\n- User Data\n\n  - `user>>>[email]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific user, in bytes.\n\n  - `user>>>[email]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific user, in bytes.\n\n::: tip\nIf the corresponding user does not have an email specified, statistics will not be enabled.\n:::\n\n- Global Data\n\n  - `inbound>>>[tag]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific inbound, in bytes.\n\n  - `inbound>>>[tag]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific inbound, in bytes.\n\n  - `outbound>>>[tag]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific outbound, in bytes.\n\n  - `outbound>>>[tag]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific outbound, in bytes.\n# FakeDNS\n\nFakeDNS is used to obtain target domain names by forging DNS, which can reduce the delay in DNS queries and work with transparent proxies to obtain target domain names.\n\n::: warning\nFakeDNS may contaminate the local DNS and cause \"network unreachable\" after Xray is closed.\n:::\n\n",
      "markdownDescription": "\nYou can use the `xray api` command to retrieve traffic statistics.\n\nThe current traffic statistics are as follows:\n\n- User Data\n\n  - `user>>>[email]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific user, in bytes.\n\n  - `user>>>[email]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific user, in bytes.\n\n::: tip\nIf the corresponding user does not have an email specified, statistics will not be enabled.\n:::\n\n- Global Data\n\n  - `inbound>>>[tag]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific inbound, in bytes.\n\n  - `inbound>>>[tag]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific inbound, in bytes.\n\n  - `outbound>>>[tag]>>>traffic>>>uplink`\n\n    The uplink traffic of a specific outbound, in bytes.\n\n  - `outbound>>>[tag]>>>traffic>>>downlink`\n\n    The downlink traffic of a specific outbound, in bytes.\n# FakeDNS\n\nFakeDNS is used to obtain target domain names by forging DNS, which can reduce the delay in DNS queries and work with transparent proxies to obtain target domain names.\n\n::: warning\nFakeDNS may contaminate the local DNS and cause \"network unreachable\" after Xray is closed.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "FakeDNSObject": {
      "title": "FakeDNSObject",
      "description": "\n`FakeDNSObject` corresponds to the `fakedns` item in the configuration file.\n\n```json\n{\n  \"ipPool\": \"198.18.0.0/16\",\n  \"poolSize\": 65535\n}\n```\n\n`FakeDnsObject` can also be configured as an array containing multiple FakeIP Pools. When a DNS query request is received, FakeDNS returns a group of FakeIPs obtained by multiple FakeIP Pools at the same time.\n\n```json\n[\n  {\n    \"ipPool\": \"198.18.0.0/15\",\n    \"poolSize\": 65535\n  },\n  {\n    \"ipPool\": \"fc00::/18\",\n    \"poolSize\": 65535\n  }\n]\n```\n\n",
      "markdownDescription": "\n`FakeDNSObject` corresponds to the `fakedns` item in the configuration file.\n\n```json\n{\n  \"ipPool\": \"198.18.0.0/16\",\n  \"poolSize\": 65535\n}\n```\n\n`FakeDnsObject` can also be configured as an array containing multiple FakeIP Pools. When a DNS query request is received, FakeDNS returns a group of FakeIPs obtained by multiple FakeIP Pools at the same time.\n\n```json\n[\n  {\n    \"ipPool\": \"198.18.0.0/15\",\n    \"poolSize\": 65535\n  },\n  {\n    \"ipPool\": \"fc00::/18\",\n    \"poolSize\": 65535\n  }\n]\n```\n\n",
      "properties": {
        "ipPool": {
          "name": "ipPool",
          "description": "\nFakeDNS will use the IP block specified by this option to allocate addresses.\n\n",
          "markdownDescription": "\nFakeDNS will use the IP block specified by this option to allocate addresses.\n\n",
          "type": "string"
        },
        "poolSize": {
          "name": "poolSize",
          "description": "\nSpecifies the maximum number of domain name-IP mappings stored by FakeDNS. When the number of mappings exceeds this value, mappings will be eliminated according to the LRU rule. The default is 65535.\n\n::: warning\n`poolSize` must be less than or equal to the total number of addresses corresponding to `ipPool`.\n:::\n\n::: tip\nIf the `dns` item in the configuration file sets `fakedns`, but the configuration file does not set `FakeDNSObject`, Xray will initialize `FakeDNSObject` based on the `queryStrategy` of the DNS component.\n\nWhen `queryStrategy` is set to `UseIP`, the initialized FakeIP Pool is equivalent to\n\n```json\n[\n  {\n    \"ipPool\": \"198.18.0.0/15\",\n    \"poolSize\": 32768\n  },\n  {\n    \"ipPool\": \"fc00::/18\",\n    \"poolSize\": 32768\n  }\n]\n```\n\nWhen `queryStrategy` is set to `UseIPv4`, the initialized FakeIP Pool is equivalent to\n\n```json\n{\n  \"ipPool\": \"198.18.0.0/15\",\n  \"poolSize\": 65535\n}\n```\n\nWhen `queryStrategy` is set to `UseIPv6`, the initialized FakeIP Pool is equivalent to\n\n```json\n{\n  \"ipPool\": \"fc00::/18\",\n  \"poolSize\": 65535\n}\n```\n\n:::\n\n",
          "markdownDescription": "\nSpecifies the maximum number of domain name-IP mappings stored by FakeDNS. When the number of mappings exceeds this value, mappings will be eliminated according to the LRU rule. The default is 65535.\n\n::: warning\n`poolSize` must be less than or equal to the total number of addresses corresponding to `ipPool`.\n:::\n\n::: tip\nIf the `dns` item in the configuration file sets `fakedns`, but the configuration file does not set `FakeDNSObject`, Xray will initialize `FakeDNSObject` based on the `queryStrategy` of the DNS component.\n\nWhen `queryStrategy` is set to `UseIP`, the initialized FakeIP Pool is equivalent to\n\n```json\n[\n  {\n    \"ipPool\": \"198.18.0.0/15\",\n    \"poolSize\": 32768\n  },\n  {\n    \"ipPool\": \"fc00::/18\",\n    \"poolSize\": 32768\n  }\n]\n```\n\nWhen `queryStrategy` is set to `UseIPv4`, the initialized FakeIP Pool is equivalent to\n\n```json\n{\n  \"ipPool\": \"198.18.0.0/15\",\n  \"poolSize\": 65535\n}\n```\n\nWhen `queryStrategy` is set to `UseIPv6`, the initialized FakeIP Pool is equivalent to\n\n```json\n{\n  \"ipPool\": \"fc00::/18\",\n  \"poolSize\": 65535\n}\n```\n\n:::\n\n",
          "type": "integer"
        }
      },
      "additionalProperties": false
    },
    "Using with other types of DNS": {
      "title": "Using with other types of DNS",
      "description": "\n",
      "markdownDescription": "\n",
      "properties": {},
      "additionalProperties": true
    },
    "Coexistence with DNS shunting": {
      "title": "Coexistence with DNS shunting",
      "description": "\nWhen using DNS shunting, to give `fakedns` a higher priority, you need to add the same `domains` as other types of DNS.\n\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"fakedns\",\n      \"domains\": [\n        // consistent with the content used in the shunt below\n        \"geosite:cn\",\n        \"domain:example.com\"\n      ]\n    },\n    {\n      \"address\": \"1.2.3.4\",\n      \"domains\": [\"geosite:cn\"],\n      \"expectIPs\": [\"geoip:cn\"]\n    },\n    {\n      \"address\": \"1.1.1.1\",\n      \"domains\": [\"domain:example.com\"]\n    },\n    \"8.8.8.8\"\n  ]\n}\n```\n\n",
      "markdownDescription": "\nWhen using DNS shunting, to give `fakedns` a higher priority, you need to add the same `domains` as other types of DNS.\n\n```json\n{\n  \"servers\": [\n    {\n      \"address\": \"fakedns\",\n      \"domains\": [\n        // consistent with the content used in the shunt below\n        \"geosite:cn\",\n        \"domain:example.com\"\n      ]\n    },\n    {\n      \"address\": \"1.2.3.4\",\n      \"domains\": [\"geosite:cn\"],\n      \"expectIPs\": [\"geoip:cn\"]\n    },\n    {\n      \"address\": \"1.1.1.1\",\n      \"domains\": [\"domain:example.com\"]\n    },\n    \"8.8.8.8\"\n  ]\n}\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "FakeDNS blacklist": {
      "title": "FakeDNS blacklist",
      "description": "\nIf you do not want certain domain names to use FakeDNS, you can add `domains` configuration in other types of DNS configurations so that when the specified domain names are matched, other DNS servers have a higher priority than FakeDNS, thereby achieving the FakeDNS blacklist mechanism.\n\n```json\n{\n  \"servers\": [\n    \"fakedns\",\n    {\n      \"address\": \"1.2.3.4\",\n      \"domains\": [\"domain:do-not-use-fakedns.com\"]\n    }\n  ]\n}\n```\n\n",
      "markdownDescription": "\nIf you do not want certain domain names to use FakeDNS, you can add `domains` configuration in other types of DNS configurations so that when the specified domain names are matched, other DNS servers have a higher priority than FakeDNS, thereby achieving the FakeDNS blacklist mechanism.\n\n```json\n{\n  \"servers\": [\n    \"fakedns\",\n    {\n      \"address\": \"1.2.3.4\",\n      \"domains\": [\"domain:do-not-use-fakedns.com\"]\n    }\n  ]\n}\n```\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "FakeDNS whitelist": {
      "title": "FakeDNS whitelist",
      "description": "\nIf you only want certain domain names to use FakeDNS, you can add `domains` configuration to `fakedns` so that when the specified domain names are matched, `fakedns` has a higher priority than other DNS servers, thereby achieving the FakeDNS whitelist mechanism.\n\n```json\n{\n  \"servers\": [\n    \"1.2.3.4\",\n    {\n      \"address\": \"fakedns\",\n      \"domains\": [\"domain:only-this-use-fakedns.com\"]\n    }\n  ]\n}\n```\n# Log Configuration\n\nLog configuration controls how Xray outputs logs.\n\nXray has two types of logs: access logs and error logs. You can configure the output method for each type of log separately.\n\n",
      "markdownDescription": "\nIf you only want certain domain names to use FakeDNS, you can add `domains` configuration to `fakedns` so that when the specified domain names are matched, `fakedns` has a higher priority than other DNS servers, thereby achieving the FakeDNS whitelist mechanism.\n\n```json\n{\n  \"servers\": [\n    \"1.2.3.4\",\n    {\n      \"address\": \"fakedns\",\n      \"domains\": [\"domain:only-this-use-fakedns.com\"]\n    }\n  ]\n}\n```\n# Log Configuration\n\nLog configuration controls how Xray outputs logs.\n\nXray has two types of logs: access logs and error logs. You can configure the output method for each type of log separately.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "LogObject": {
      "title": "LogObject",
      "description": "\nLogObject corresponds to the `log` item in the configuration file.\n\n```json\n{\n  \"log\": {\n    \"access\": \"file_path\",\n    \"error\": \"file_path\",\n    \"loglevel\": \"warning\",\n    \"dnsLog\": false,\n    \"maskAddress\": \"\"\n  }\n}\n```\n\n",
      "markdownDescription": "\nLogObject corresponds to the `log` item in the configuration file.\n\n```json\n{\n  \"log\": {\n    \"access\": \"file_path\",\n    \"error\": \"file_path\",\n    \"loglevel\": \"warning\",\n    \"dnsLog\": false,\n    \"maskAddress\": \"\"\n  }\n}\n```\n\n",
      "properties": {
        "access": {
          "name": "access",
          "description": "\nThe file path for the access log. The value is a valid file path, such as `\"/var/log/Xray/access.log\"` (Linux) or `\"C:\\\\Temp\\\\Xray\\\\_access.log\"` (Windows). When this item is not specified or is an empty value, the log is output to stdout.\n\n- The special value `none` disables access logs.\n\n",
          "markdownDescription": "\nThe file path for the access log. The value is a valid file path, such as `\"/var/log/Xray/access.log\"` (Linux) or `\"C:\\\\Temp\\\\Xray\\\\_access.log\"` (Windows). When this item is not specified or is an empty value, the log is output to stdout.\n\n- The special value `none` disables access logs.\n\n",
          "type": "string"
        },
        "error": {
          "name": "error",
          "description": "\nThe file path for the error log. The value is a valid file path, such as `\"/var/log/Xray/error.log\"` (Linux) or `\"C:\\\\Temp\\\\Xray\\\\_error.log\"` (Windows). When this item is not specified or is an empty value, the log is output to stdout.\n\n- The special value `none` disables error logs.\n\n",
          "markdownDescription": "\nThe file path for the error log. The value is a valid file path, such as `\"/var/log/Xray/error.log\"` (Linux) or `\"C:\\\\Temp\\\\Xray\\\\_error.log\"` (Windows). When this item is not specified or is an empty value, the log is output to stdout.\n\n- The special value `none` disables error logs.\n\n",
          "type": "string"
        },
        "loglevel": {
          "name": "loglevel",
          "description": "\nThe log level for error logs, indicating the information that needs to be recorded. The default value is `\"warning\"`.\n\n- `\"debug\"`: Output information used for debugging the program. Includes all `\"info\"` content.\n- `\"info\"`: Runtime status information, etc., which does not affect normal use. Includes all `\"warning\"` content.\n- `\"warning\"`: Information output when there are some problems that do not affect normal operation but may affect user experience. Includes all `\"error\"` content.\n- `\"error\"`: Xray encountered a problem that cannot be run normally and needs to be resolved immediately.\n- `\"none\"`: Do not record any content.\n\n",
          "markdownDescription": "\nThe log level for error logs, indicating the information that needs to be recorded. The default value is `\"warning\"`.\n\n- `\"debug\"`: Output information used for debugging the program. Includes all `\"info\"` content.\n- `\"info\"`: Runtime status information, etc., which does not affect normal use. Includes all `\"warning\"` content.\n- `\"warning\"`: Information output when there are some problems that do not affect normal operation but may affect user experience. Includes all `\"error\"` content.\n- `\"error\"`: Xray encountered a problem that cannot be run normally and needs to be resolved immediately.\n- `\"none\"`: Do not record any content.\n\n",
          "anyOf": [
            {
              "const": "debug"
            },
            {
              "const": "info"
            },
            {
              "const": "warning"
            },
            {
              "const": "error"
            },
            {
              "const": "none"
            }
          ]
        },
        "dnsLog": {
          "name": "dnsLog",
          "description": "\nWhether to enable DNS query logs, for example: `DOH//doh.server got answer: domain.com -> [ip1, ip2] 2.333ms`.\n\n",
          "markdownDescription": "\nWhether to enable DNS query logs, for example: `DOH//doh.server got answer: domain.com -> [ip1, ip2] 2.333ms`.\n\n",
          "type": "boolean"
        },
        "maskAddress": {
          "name": "maskAddress",
          "description": "\nIP address masking, when enabled, will automatically replace the IP address appearing in the log. It is used to protect privacy when sharing logs. The default is empty and is not enabled.\n\nCurrently available levels are `quarter`, `half`, `full`. The mask form corresponds to the following:\n\n- ipv4 `1.2.*.*` `1.*.*.*` `[Masked IPv4]`\n- ipv6 `1234:5678::/32` `1234::/16` `[Masked IPv6]`\n# WebSocket\n\nUses standard WebSocket for data transmission.\n\nWebSocket connections can be proxied by other web servers (like NGINX) or by VLESS fallback paths.\n\n::: tip\nWebSocket inbounds will parse the `X-Forwarded-For` header received, overriding the source address with a higher priority than the source address got from PROXY protocol.\n:::\n\n",
          "markdownDescription": "\nIP address masking, when enabled, will automatically replace the IP address appearing in the log. It is used to protect privacy when sharing logs. The default is empty and is not enabled.\n\nCurrently available levels are `quarter`, `half`, `full`. The mask form corresponds to the following:\n\n- ipv4 `1.2.*.*` `1.*.*.*` `[Masked IPv4]`\n- ipv6 `1234:5678::/32` `1234::/16` `[Masked IPv6]`\n# WebSocket\n\nUses standard WebSocket for data transmission.\n\nWebSocket connections can be proxied by other web servers (like NGINX) or by VLESS fallback paths.\n\n::: tip\nWebSocket inbounds will parse the `X-Forwarded-For` header received, overriding the source address with a higher priority than the source address got from PROXY protocol.\n:::\n\n",
          "anyOf": [
            {
              "const": "quarter"
            },
            {
              "const": "half"
            },
            {
              "const": "full"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "WebSocketObject": {
      "title": "WebSocketObject",
      "description": "\n`WebSocketObject` corresponds to the `wsSettings` property of the transport configs.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  }\n}\n```\n\n",
      "markdownDescription": "\n`WebSocketObject` corresponds to the `wsSettings` property of the transport configs.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  }\n}\n```\n\n",
      "properties": {
        "acceptProxyProtocol": {
          "name": "acceptProxyProtocol",
          "description": "\nOnly used by inbounds. Indicates whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to transmit the real source IP and port of connections. **If you are not familiar with this, leave it alone.**\n\nCommonplace reverse proxy software solutions (like HAProxy and NGINX) can be configured to have source IPs and ports sent with PROXY protocol. Same goes to VLESS fallbacks `xver`.\n\nWhen `true`, after the underlying TCP connection is established, the downstream must first send the source IPs and ports in PROXY protocol v1 or v2, or the connection will be terminated.\n\n",
          "markdownDescription": "\nOnly used by inbounds. Indicates whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to transmit the real source IP and port of connections. **If you are not familiar with this, leave it alone.**\n\nCommonplace reverse proxy software solutions (like HAProxy and NGINX) can be configured to have source IPs and ports sent with PROXY protocol. Same goes to VLESS fallbacks `xver`.\n\nWhen `true`, after the underlying TCP connection is established, the downstream must first send the source IPs and ports in PROXY protocol v1 or v2, or the connection will be terminated.\n\n",
          "type": "boolean"
        },
        "path": {
          "name": "path",
          "description": "\nThe HTTP path used by the WebSocket connection. Defaults to `\"/\"`.\n\nIf `path` contains the `ed` query parameter, `early data` will be activated for latency reduction, and its value will be the length threshold of the first packet. If the length of the first packet exceeds this value, `early data` won't be activated. The recommended value is 2560, with a maximum of 8192. Compatibility problems can occur when the value is set too high. Try lowering the threshold when encountering such problems.\n\n",
          "markdownDescription": "\nThe HTTP path used by the WebSocket connection. Defaults to `\"/\"`.\n\nIf `path` contains the `ed` query parameter, `early data` will be activated for latency reduction, and its value will be the length threshold of the first packet. If the length of the first packet exceeds this value, `early data` won't be activated. The recommended value is 2560, with a maximum of 8192. Compatibility problems can occur when the value is set too high. Try lowering the threshold when encountering such problems.\n\n",
          "type": "string"
        },
        "host": {
          "name": "host",
          "description": "\nThe `Host` header sent in HTTP requests. Defaults to an empty string. Servers will not validate the `Host` header sent by clients when left blank.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: ```host``` > ```headers``` > ```address```\n\n",
          "markdownDescription": "\nThe `Host` header sent in HTTP requests. Defaults to an empty string. Servers will not validate the `Host` header sent by clients when left blank.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: ```host``` > ```headers``` > ```address```\n\n",
          "type": "string"
        },
        "headers": {
          "name": "headers",
          "description": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n\n",
          "markdownDescription": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n\n",
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    "Browser Dialer": {
      "anyOf": [
        {
          "title": "Browser Dialer",
          "description": "\nUse the browser to handle TLS, see [Browser Dialer](../features/browser_dialer.md)\n# HTTPUpgrade\n\nA WebSocket-like transport protocol implementing the HTTP/1.1 upgrade and response, allowing it to be reverse proxied by web servers or CDNs just like WebSocket, but without the need to implement the remaining portions of the WebSocket protocol, yielding better performance.\n\nStandalone usage is not recommended, but rather in conjunction with other security protocols like TLS.\n\n",
          "markdownDescription": "\nUse the browser to handle TLS, see [Browser Dialer](../features/browser_dialer.md)\n# HTTPUpgrade\n\nA WebSocket-like transport protocol implementing the HTTP/1.1 upgrade and response, allowing it to be reverse proxied by web servers or CDNs just like WebSocket, but without the need to implement the remaining portions of the WebSocket protocol, yielding better performance.\n\nStandalone usage is not recommended, but rather in conjunction with other security protocols like TLS.\n\n",
          "properties": {},
          "additionalProperties": true
        },
        {
          "title": "Browser Dialer",
          "description": "\n<Badge text=\"v1.8.17+\" type=\"warning\"/>\n\nIf uTLS is not enough, XHTTP's TLS can be handled by a browser using [Browser Dialer](../features/browser_dialer.md)\n\n",
          "markdownDescription": "\n<Badge text=\"v1.8.17+\" type=\"warning\"/>\n\nIf uTLS is not enough, XHTTP's TLS can be handled by a browser using [Browser Dialer](../features/browser_dialer.md)\n\n",
          "properties": {},
          "additionalProperties": true
        }
      ]
    },
    "HttpUpgradeObject": {
      "title": "HttpUpgradeObject",
      "description": "\nThe `HttpUpgradeObject` corresponds to the `httpupgradeSettings` section under transport configurations.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n  \t\"key\": \"value\"\n  }\n}\n```\n\n",
      "markdownDescription": "\nThe `HttpUpgradeObject` corresponds to the `httpupgradeSettings` section under transport configurations.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n  \t\"key\": \"value\"\n  }\n}\n```\n\n",
      "properties": {
        "acceptProxyProtocol": {
          "name": "acceptProxyProtocol",
          "description": "\nFor inbounds only. Specifies whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to pass the real IP address and port of a connection along. **Ignore it if you have no knowledge regarding this**.\n\nCommon reverse proxies (e.g. HAProxy, NGINX) and VLESS fallbacks xver can be configured for its inclusion.\n\nWhen `true`, the downstream must first send PROXY protocol version 1 or 2 after establishing the underlying TCP connection, or the connection will be closed.\n\n",
          "markdownDescription": "\nFor inbounds only. Specifies whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to pass the real IP address and port of a connection along. **Ignore it if you have no knowledge regarding this**.\n\nCommon reverse proxies (e.g. HAProxy, NGINX) and VLESS fallbacks xver can be configured for its inclusion.\n\nWhen `true`, the downstream must first send PROXY protocol version 1 or 2 after establishing the underlying TCP connection, or the connection will be closed.\n\n",
          "type": "boolean"
        },
        "path": {
          "name": "path",
          "description": "\nHTTP path used by the HTTPUpgrade connection. Defaults to `\"/\"`.\n\nIf the `path` property include an `ed` query field (e.g. ```/mypath?ed=2560```), \"early data\" will be used to decrease latency, with the value defining the threshold of the first packet's size. If the size of the first packet exceeds the defined value, \"early data\" will not be applied. The recommended value is `2560`.\n\n",
          "markdownDescription": "\nHTTP path used by the HTTPUpgrade connection. Defaults to `\"/\"`.\n\nIf the `path` property include an `ed` query field (e.g. ```/mypath?ed=2560```), \"early data\" will be used to decrease latency, with the value defining the threshold of the first packet's size. If the size of the first packet exceeds the defined value, \"early data\" will not be applied. The recommended value is `2560`.\n\n",
          "type": "string"
        },
        "host": {
          "name": "host",
          "description": "\nHTTP Host sent by the HTTPUpgrade connection. Empty by default. If this value is empty on the server, the host header sent by clients will not be validated.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: ```host``` > ```headers``` > ```address```\n\n",
          "markdownDescription": "\nHTTP Host sent by the HTTPUpgrade connection. Empty by default. If this value is empty on the server, the host header sent by clients will not be validated.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: ```host``` > ```headers``` > ```address```\n\n",
          "type": "string"
        },
        "headers": {
          "name": "headers",
          "description": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n# XHTTP (SplitHTTP)\n\n<Badge text=\"v1.8.16+\" type=\"warning\"/>\n\nUses HTTP chunked-transfer encoding for download, and multiple HTTP requests for upload.\n\nCan be deployed on CDNs that do not support WebSocket. However, **the CDN must\nsupport HTTP chunked transfer encoding in a streaming fashion**, no response\nbuffering.\n\nThis transport serves the same purpose as Meek (support non-WS CDN). It has the\nabove streaming requirement to the CDN so that download can be much faster than\n(v2fly) Meek, close to WebSocket performance. The upload is also optimized, but\nstill much more limited than WebSocket.\n\nLike WebSocket transport, XHTTP parses the `X-Forwarded-For` header for logging.\n\n",
          "markdownDescription": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n# XHTTP (SplitHTTP)\n\n<Badge text=\"v1.8.16+\" type=\"warning\"/>\n\nUses HTTP chunked-transfer encoding for download, and multiple HTTP requests for upload.\n\nCan be deployed on CDNs that do not support WebSocket. However, **the CDN must\nsupport HTTP chunked transfer encoding in a streaming fashion**, no response\nbuffering.\n\nThis transport serves the same purpose as Meek (support non-WS CDN). It has the\nabove streaming requirement to the CDN so that download can be much faster than\n(v2fly) Meek, close to WebSocket performance. The upload is also optimized, but\nstill much more limited than WebSocket.\n\nLike WebSocket transport, XHTTP parses the `X-Forwarded-For` header for logging.\n\n",
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    "XHttpObject": {
      "title": "XHttpObject",
      "description": "\nThe `XHttpObject` corresponds to the `xhttpSettings` section under transport configurations.\n\n```json\n{\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  },\n  \"scMaxEachPostBytes\": 1000000,\n  \"scMaxConcurrentPosts\": 100,\n  \"scMinPostsIntervalMs\": 30,\n  \"noSSEHeader\": false,\n  \"xPaddingBytes\": \"100-1000\",\n  \"xmux\": {\n    \"maxConcurrency\": 0,\n    \"maxConnections\": 0,\n    \"cMaxReuseTimes\": 0,\n    \"cMaxLifetimeMs\": 0\n  }\n}\n```\n\n",
      "markdownDescription": "\nThe `XHttpObject` corresponds to the `xhttpSettings` section under transport configurations.\n\n```json\n{\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  },\n  \"scMaxEachPostBytes\": 1000000,\n  \"scMaxConcurrentPosts\": 100,\n  \"scMinPostsIntervalMs\": 30,\n  \"noSSEHeader\": false,\n  \"xPaddingBytes\": \"100-1000\",\n  \"xmux\": {\n    \"maxConcurrency\": 0,\n    \"maxConnections\": 0,\n    \"cMaxReuseTimes\": 0,\n    \"cMaxLifetimeMs\": 0\n  }\n}\n```\n\n",
      "properties": {
        "path": {
          "name": "path",
          "description": "\nHTTP path used by the connection. Defaults to `\"/\"`.\n\n",
          "markdownDescription": "\nHTTP path used by the connection. Defaults to `\"/\"`.\n\n",
          "type": "string"
        },
        "host": {
          "name": "host",
          "description": "\nHTTP Host sent by the connection. Empty by default. If this value is empty on the server, the host header sent by clients will not be validated.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: `host` > `headers` > `address`\n\n",
          "markdownDescription": "\nHTTP Host sent by the connection. Empty by default. If this value is empty on the server, the host header sent by clients will not be validated.\n\nIf the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches.\n\nThe current priority of the `Host` header sent by clients: `host` > `headers` > `address`\n\n",
          "type": "string"
        },
        "headers": {
          "name": "headers",
          "description": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n\n",
          "markdownDescription": "\nCustomized HTTP headers defined in key-value pairs. Defaults to empty.\n\n",
          "type": "object"
        },
        "scMaxEachPostBytes": {
          "name": "scMaxEachPostBytes",
          "description": "\nThe maximum size of upload chunks, in bytes. Defaults to 1MB.\n\nThe size set by the client must be lower than this value, otherwise when the\nPOST request is sent larger than the value set by the server, the request will\nbe rejected.\n\nThis value should be smaller than the maximum request body allowed by the CDN\nor other HTTP reverse proxy, otherwise an HTTP 413 error will be thrown.\n\nIt can also be in the form of a string `\"1000000-2000000\"`. The core will\nrandomly select a value within the range each time to reduce fingerprints.\n\n",
          "markdownDescription": "\nThe maximum size of upload chunks, in bytes. Defaults to 1MB.\n\nThe size set by the client must be lower than this value, otherwise when the\nPOST request is sent larger than the value set by the server, the request will\nbe rejected.\n\nThis value should be smaller than the maximum request body allowed by the CDN\nor other HTTP reverse proxy, otherwise an HTTP 413 error will be thrown.\n\nIt can also be in the form of a string `\"1000000-2000000\"`. The core will\nrandomly select a value within the range each time to reduce fingerprints.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "scMaxConcurrentPosts": {
          "name": "scMaxConcurrentPosts",
          "description": "\nThe number of concurrent uploads to run. Defaults to 100 on the client, and\n200 on the server.\n\nThe value on the client must not be higher than on the server. Otherwise,\nconnectivity issues will occur. In practice, the upload concurrency is also\nlimited by `minUploadIntervalMs`, so the actual concurrency on the client side\nwill be much lower.\n\nIt can also be in the form of a string `\"100-200\"`, and the core will randomly\nselect a value within the range each time to reduce fingerprints.\n\n",
          "markdownDescription": "\nThe number of concurrent uploads to run. Defaults to 100 on the client, and\n200 on the server.\n\nThe value on the client must not be higher than on the server. Otherwise,\nconnectivity issues will occur. In practice, the upload concurrency is also\nlimited by `minUploadIntervalMs`, so the actual concurrency on the client side\nwill be much lower.\n\nIt can also be in the form of a string `\"100-200\"`, and the core will randomly\nselect a value within the range each time to reduce fingerprints.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "scMinPostsIntervalMs": {
          "name": "scMinPostsIntervalMs",
          "description": "\n(Client-only) How much time to pass between upload requests at a minimum.\nDefaults to `30` (milliseconds).\n\nIt can also be in the form of a string `\"10-50\"`, and the core will randomly\nselect a value within the range each time to reduce fingerprints.\n\n> `noSSEHeader`\n\n(Server-only) Do not send the `Content-Type: text/event-stream` response\nheader. Defaults to false (the header will be sent)\n\n> `xPaddingBytes`\n\n*Added in 1.8.24*\n\nControl the padding of requests and responses. Defaults to `\"100-1000\"`,\nmeaning that each GET and POST will be padded with a random amount of bytes in\nthat range.\n\nA value of `-1` disables padding entirely.\n\nYou can lower this to save bandwidth or increase it to improve censorship\nresistance. Too much padding may cause the CDN to reject traffic.\n\n",
          "markdownDescription": "\n(Client-only) How much time to pass between upload requests at a minimum.\nDefaults to `30` (milliseconds).\n\nIt can also be in the form of a string `\"10-50\"`, and the core will randomly\nselect a value within the range each time to reduce fingerprints.\n\n> `noSSEHeader`\n\n(Server-only) Do not send the `Content-Type: text/event-stream` response\nheader. Defaults to false (the header will be sent)\n\n> `xPaddingBytes`\n\n*Added in 1.8.24*\n\nControl the padding of requests and responses. Defaults to `\"100-1000\"`,\nmeaning that each GET and POST will be padded with a random amount of bytes in\nthat range.\n\nA value of `-1` disables padding entirely.\n\nYou can lower this to save bandwidth or increase it to improve censorship\nresistance. Too much padding may cause the CDN to reject traffic.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "xmux": {
          "name": "xmux",
          "description": "\n",
          "markdownDescription": "\n",
          "$ref": "#/definitions/XmuxObject"
        }
      },
      "additionalProperties": false
    },
    "XmuxObject": {
      "title": "XmuxObject",
      "description": "\n<Badge text=\"v24.9.19+\" type=\"warning\"/>\n\nAllows users to control the multiplexing behavior in h2 and h3. If not set, the default behavior is to multiplex all requests to one TCP/QUIC connection.\n\n```json\n{\n  \"maxConcurrency\": 0,\n  \"maxConnections\": 0,\n  \"cMaxReuseTimes\": 0,\n  \"cMaxLifetimeMs\": 0\n}\n```\n\nSince the default is unlimited reuse, `xmux` actually limits this. It's not recommended to enable `mux.cool` at the same time.\n\nTerminology: *Streams* will reuse physical connections, as in, one connection can hold many streams. In other places, streams are called sub-connections, they are the same thing.\n\n",
      "markdownDescription": "\n<Badge text=\"v24.9.19+\" type=\"warning\"/>\n\nAllows users to control the multiplexing behavior in h2 and h3. If not set, the default behavior is to multiplex all requests to one TCP/QUIC connection.\n\n```json\n{\n  \"maxConcurrency\": 0,\n  \"maxConnections\": 0,\n  \"cMaxReuseTimes\": 0,\n  \"cMaxLifetimeMs\": 0\n}\n```\n\nSince the default is unlimited reuse, `xmux` actually limits this. It's not recommended to enable `mux.cool` at the same time.\n\nTerminology: *Streams* will reuse physical connections, as in, one connection can hold many streams. In other places, streams are called sub-connections, they are the same thing.\n\n",
      "properties": {
        "maxConcurrency": {
          "name": "maxConcurrency",
          "description": "\nDefault 0 = infinite. The maximum number of streams reused in each connection. After the number of streams in the connection reaches this value, the core will create more connections to accommodate more streams, similar to the concurrency of mux.cool. Mutually exclusive with `maxConnections`.\n\n",
          "markdownDescription": "\nDefault 0 = infinite. The maximum number of streams reused in each connection. After the number of streams in the connection reaches this value, the core will create more connections to accommodate more streams, similar to the concurrency of mux.cool. Mutually exclusive with `maxConnections`.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "maxConnections": {
          "name": "maxConnections",
          "description": "\nDefault 0 = infinite. The maximum number of connections to open. Every stream will open a new connection until this value is reached, only then connections will be reused. Mutually exclusive with `maxConcurrency`.\n\n",
          "markdownDescription": "\nDefault 0 = infinite. The maximum number of connections to open. Every stream will open a new connection until this value is reached, only then connections will be reused. Mutually exclusive with `maxConcurrency`.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "cMaxReuseTimes": {
          "name": "cMaxReuseTimes",
          "description": "\nDefault 0 = infinite. A connection can be reused at most several times. When this value is reached, the core will not allocate streams to the connection. It will be disconnected after the last internal stream is closed.\n\n",
          "markdownDescription": "\nDefault 0 = infinite. A connection can be reused at most several times. When this value is reached, the core will not allocate streams to the connection. It will be disconnected after the last internal stream is closed.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "cMaxLifetimeMs": {
          "name": "cMaxLifetimeMs",
          "description": "\nDefault 0 = infinite. How long can a connection \"survive\" at most? When the connection is open for more than this value, the core will not redistribute streams to the connection, and it will be disconnected after the last internal stream is closed.\n\n",
          "markdownDescription": "\nDefault 0 = infinite. How long can a connection \"survive\" at most? When the connection is open for more than this value, the core will not redistribute streams to the connection, and it will be disconnected after the last internal stream is closed.\n\n",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "HTTP versions": {
      "title": "HTTP versions",
      "description": "\n*Added in 1.8.21: HTTP/3 support*\n\nXHTTP supports `http/1.1`, `h2` and `h3` ALPN values. If the value is not\nset, `h2` (prior-knowledge) is assumed when TLS is enabled, and `http/1.1`\nwithout TLS. If the value is set to `h3`, the client will attempt to connect as\nHTTP/3, so UDP instead of TCP.\n\nThe server listens to HTTP/1.1 and h2 by default, but if `h3` ALPN is set on\nthe server, it will listen as HTTP/3.\n\nPlease note that nginx, Caddy and all CDN will almost certainly translate\nclient requests to a different HTTP version for forwarding, and so the server\nmay have to be configured with a different ALPN value than the client. If you\nuse a CDN, it is very unlikely that `h3` is a correct value for the server,\neven if the client speaks `h3`.\n\n",
      "markdownDescription": "\n*Added in 1.8.21: HTTP/3 support*\n\nXHTTP supports `http/1.1`, `h2` and `h3` ALPN values. If the value is not\nset, `h2` (prior-knowledge) is assumed when TLS is enabled, and `http/1.1`\nwithout TLS. If the value is set to `h3`, the client will attempt to connect as\nHTTP/3, so UDP instead of TCP.\n\nThe server listens to HTTP/1.1 and h2 by default, but if `h3` ALPN is set on\nthe server, it will listen as HTTP/3.\n\nPlease note that nginx, Caddy and all CDN will almost certainly translate\nclient requests to a different HTTP version for forwarding, and so the server\nmay have to be configured with a different ALPN value than the client. If you\nuse a CDN, it is very unlikely that `h3` is a correct value for the server,\neven if the client speaks `h3`.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Troubleshooting": {
      "title": "Troubleshooting",
      "description": "\n* If a connection hangs, the CDN may not support streaming downloads. You can\n  use `curl -Nv https://example.com/abcdef` to initiate a download and see for\n  yourself (see protocol details).\n\n  If you do not see `200 OK` and a response body of `ok`, then the CDN is\n  buffering the response body. Please ensure that all HTTP middleboxes along\n  the path between client and server observe `X-Accel-Buffering: no` from their\n  origin server. If your chain is `xray -> nginx -> CDN -> xray`, nginx may\n  strip this response header and you have to re-add it.\n\n",
      "markdownDescription": "\n* If a connection hangs, the CDN may not support streaming downloads. You can\n  use `curl -Nv https://example.com/abcdef` to initiate a download and see for\n  yourself (see protocol details).\n\n  If you do not see `200 OK` and a response body of `ok`, then the CDN is\n  buffering the response body. Please ensure that all HTTP middleboxes along\n  the path between client and server observe `X-Accel-Buffering: no` from their\n  origin server. If your chain is `xray -> nginx -> CDN -> xray`, nginx may\n  strip this response header and you have to re-add it.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Protocol details": {
      "title": "Protocol details",
      "description": "\nSee [#3412](https://github.com/XTLS/Xray-core/pull/3412) and\n[#3462](https://github.com/XTLS/Xray-core/pull/3462) for extensive discussion\nand revision of the protocol. Here is a summary, and the minimum needed to be\ncompatible:\n\n1. `GET /<UUID>` opens the download. The server immediately responds with `200\n   OK`, and immediately sends the string `ok`\n   (arbitrary length, such as `ooook`) to force HTTP middleboxes into flushing\n   headers.\n\n   The server will send these headers:\n\n    * `X-Accel-Buffering: no` to prevent response buffering in nginx and CDN\n    * `Content-Type: text/event-stream` to prevent response buffering in some\n      CDN, can be disabled with `noSSEHeader`\n    * `Transfer-Encoding: chunked` in HTTP/1.1 only\n    * `Cache-Control: no-store` to disable any potential response caching.\n\n2. Client uploads using `POST /<UUID>/<seq>`. `seq` starts at `0` and can be\n   used like TCP seq number, and multiple \"packets\" may be sent concurrently.\n   The server has to reassemble the \"packets\" live. The sequence number never\n   resets for simplicity reasons.\n\n   The client may open upload and download in any order, either one starts a\n   session. However, eventually `GET` needs to be opened (current deadline is\n   hardcoded to 30 seconds) If not, the session will be terminated.\n\n3. The `GET` request is kept open until the tunneled connection has to be\n   terminated. Either server or client can close.\n\n   How this actually works depends on the HTTP version. For example, in\n   HTTP/1.1 it is only possible to disrupt chunked-transfer by closing the TCP\n   connection, in other versions the stream is closed or aborted.\n\nRecommendations:\n\n* Do not assume any custom headers are transferred correctly by the CDN. This\n  transport is built for CDN who do not support WebSocket, these CDN tend to\n  not be very modern (or good).\n\n* It should be assumed there is no streaming upload within a HTTP request, so\n  the size of a packet should be chosen to optimize between latency,\n  throughput, and any size limits imposed by the CDN (just like TCP, nagle's\n  algorithm and MTU...)\n\n* HTTP/1.1 and h2 should be supported by server and client, and it should be\n  expected that the CDN will translate arbitrarily between versions. A HTTP/1.1\n  server may indirectly end up talking to a h2 client, and vice versa.\n# TCP\n\nTCP (Transmission Control Protocol) is currently one of the recommended transport protocols\n\nIt can be combined with various protocols in multiple ways.\n\n",
      "markdownDescription": "\nSee [#3412](https://github.com/XTLS/Xray-core/pull/3412) and\n[#3462](https://github.com/XTLS/Xray-core/pull/3462) for extensive discussion\nand revision of the protocol. Here is a summary, and the minimum needed to be\ncompatible:\n\n1. `GET /<UUID>` opens the download. The server immediately responds with `200\n   OK`, and immediately sends the string `ok`\n   (arbitrary length, such as `ooook`) to force HTTP middleboxes into flushing\n   headers.\n\n   The server will send these headers:\n\n    * `X-Accel-Buffering: no` to prevent response buffering in nginx and CDN\n    * `Content-Type: text/event-stream` to prevent response buffering in some\n      CDN, can be disabled with `noSSEHeader`\n    * `Transfer-Encoding: chunked` in HTTP/1.1 only\n    * `Cache-Control: no-store` to disable any potential response caching.\n\n2. Client uploads using `POST /<UUID>/<seq>`. `seq` starts at `0` and can be\n   used like TCP seq number, and multiple \"packets\" may be sent concurrently.\n   The server has to reassemble the \"packets\" live. The sequence number never\n   resets for simplicity reasons.\n\n   The client may open upload and download in any order, either one starts a\n   session. However, eventually `GET` needs to be opened (current deadline is\n   hardcoded to 30 seconds) If not, the session will be terminated.\n\n3. The `GET` request is kept open until the tunneled connection has to be\n   terminated. Either server or client can close.\n\n   How this actually works depends on the HTTP version. For example, in\n   HTTP/1.1 it is only possible to disrupt chunked-transfer by closing the TCP\n   connection, in other versions the stream is closed or aborted.\n\nRecommendations:\n\n* Do not assume any custom headers are transferred correctly by the CDN. This\n  transport is built for CDN who do not support WebSocket, these CDN tend to\n  not be very modern (or good).\n\n* It should be assumed there is no streaming upload within a HTTP request, so\n  the size of a packet should be chosen to optimize between latency,\n  throughput, and any size limits imposed by the CDN (just like TCP, nagle's\n  algorithm and MTU...)\n\n* HTTP/1.1 and h2 should be supported by server and client, and it should be\n  expected that the CDN will translate arbitrarily between versions. A HTTP/1.1\n  server may indirectly end up talking to a h2 client, and vice versa.\n# TCP\n\nTCP (Transmission Control Protocol) is currently one of the recommended transport protocols\n\nIt can be combined with various protocols in multiple ways.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "TcpObject": {
      "title": "TcpObject",
      "description": "\n`TcpObject` corresponds to the `tcpSettings` item in the Transport Protocol.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"header\": {\n    \"type\": \"none\"\n  }\n}\n```\n\n",
      "markdownDescription": "\n`TcpObject` corresponds to the `tcpSettings` item in the Transport Protocol.\n\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"header\": {\n    \"type\": \"none\"\n  }\n}\n```\n\n",
      "properties": {
        "acceptProxyProtocol": {
          "name": "acceptProxyProtocol",
          "description": "\nOnly used for inbound, indicating whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to transmit the real source IP and port of the request. **If you are not familiar with it, please ignore this item.**\n\nCommon reverse proxy software (such as HAProxy and Nginx) can be configured to send it, and VLESS fallbacks xver can also send it.\n\nWhen filled in as `true`, after the underlying TCP connection is established, the requesting party must first send PROXY protocol v1 or v2, otherwise the connection will be closed.\n\nThe default value is `false`\n\n",
          "markdownDescription": "\nOnly used for inbound, indicating whether to accept the PROXY protocol.\n\nThe [PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) is used to transmit the real source IP and port of the request. **If you are not familiar with it, please ignore this item.**\n\nCommon reverse proxy software (such as HAProxy and Nginx) can be configured to send it, and VLESS fallbacks xver can also send it.\n\nWhen filled in as `true`, after the underlying TCP connection is established, the requesting party must first send PROXY protocol v1 or v2, otherwise the connection will be closed.\n\nThe default value is `false`\n\n",
          "type": "boolean"
        },
        "header": {
          "name": "header",
          "description": "\nPacket header obfuscation settings, the default value is `NoneHeaderObject`\n\n::: tip\nHTTP obfuscation cannot be proxied by other HTTP servers (such as Nginx), but it can be proxied by VLESS fallbacks path.\n:::\n\n",
          "markdownDescription": "\nPacket header obfuscation settings, the default value is `NoneHeaderObject`\n\n::: tip\nHTTP obfuscation cannot be proxied by other HTTP servers (such as Nginx), but it can be proxied by VLESS fallbacks path.\n:::\n\n",
          "$ref": "#/definitions/NoneHeaderObject"
        }
      },
      "additionalProperties": false
    },
    "NoneHeaderObject": {
      "title": "NoneHeaderObject",
      "description": "\nNo header obfuscation\n\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "markdownDescription": "\nNo header obfuscation\n\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "properties": {
        "type": {
          "name": "type",
          "description": "\nDisable header obfuscation.\n\n",
          "markdownDescription": "\nDisable header obfuscation.\n\n",
          "const": "none"
        }
      },
      "additionalProperties": false
    },
    "HttpHeaderObject": {
      "title": "HttpHeaderObject",
      "description": "\nHTTP header obfuscation. The configuration must be the same between connecting inbound and outbound.\n\n```json\n{\n  \"type\": \"http\",\n  \"request\": {},\n  \"response\": {}\n}\n```\n\n",
      "markdownDescription": "\nHTTP header obfuscation. The configuration must be the same between connecting inbound and outbound.\n\n```json\n{\n  \"type\": \"http\",\n  \"request\": {},\n  \"response\": {}\n}\n```\n\n",
      "properties": {
        "type": {
          "name": "type",
          "description": "\nEnable HTTP header obfuscation.\n\n",
          "markdownDescription": "\nEnable HTTP header obfuscation.\n\n",
          "const": "http"
        },
        "request": {
          "name": "request",
          "description": "\nHTTP request template.\n\n",
          "markdownDescription": "\nHTTP request template.\n\n",
          "$ref": "#/definitions/HTTPRequestObject"
        },
        "response": {
          "name": "response",
          "description": "\nHTTP response template.\n\n",
          "markdownDescription": "\nHTTP response template.\n\n",
          "$ref": "#/definitions/HTTPResponseObject"
        }
      },
      "additionalProperties": false
    },
    "HTTPRequestObject": {
      "title": "HTTPRequestObject",
      "description": "\n```json\n{\n  \"version\": \"1.1\",\n  \"method\": \"GET\",\n  \"path\": [\"/\"],\n  \"headers\": {\n    \"Host\": [\"www.baidu.com\", \"www.bing.com\"],\n    \"User-Agent\": [\n      \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\",\n      \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\"\n    ],\n    \"Accept-Encoding\": [\"gzip, deflate\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"version\": \"1.1\",\n  \"method\": \"GET\",\n  \"path\": [\"/\"],\n  \"headers\": {\n    \"Host\": [\"www.baidu.com\", \"www.bing.com\"],\n    \"User-Agent\": [\n      \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\",\n      \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\"\n    ],\n    \"Accept-Encoding\": [\"gzip, deflate\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```\n\n",
      "properties": {
        "version": {
          "name": "version",
          "description": "\nHTTP version, the default value is `\"1.1\"`\n\n",
          "markdownDescription": "\nHTTP version, the default value is `\"1.1\"`\n\n",
          "type": "string"
        },
        "method": {
          "name": "method",
          "description": "\nThe HTTP method, the default value is `\"GET\"`\n\n",
          "markdownDescription": "\nThe HTTP method, the default value is `\"GET\"`\n\n",
          "type": "string"
        },
        "path": {
          "name": "path",
          "description": "\npaths, an array of strings. The default value is `[\"/\"]`. When there are multiple values, a value is chosen randomly for each request.\n\n",
          "markdownDescription": "\npaths, an array of strings. The default value is `[\"/\"]`. When there are multiple values, a value is chosen randomly for each request.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "headers": {
          "name": "headers",
          "description": "\nHTTP header, a key-value pair, each key represents the name of an HTTP header, and the corresponding value is an array.\n\nEach request will include all the keys and randomly select a corresponding value. Please refer to the **default values** shown in the example above.\n\n",
          "markdownDescription": "\nHTTP header, a key-value pair, each key represents the name of an HTTP header, and the corresponding value is an array.\n\nEach request will include all the keys and randomly select a corresponding value. Please refer to the **default values** shown in the example above.\n\n",
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    "HTTPResponseObject": {
      "title": "HTTPResponseObject",
      "description": "\n```json\n{\n  \"version\": \"1.1\",\n  \"status\": \"200\",\n  \"reason\": \"OK\",\n  \"headers\": {\n    \"Content-Type\": [\"application/octet-stream\", \"video/mpeg\"],\n    \"Transfer-Encoding\": [\"chunked\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"version\": \"1.1\",\n  \"status\": \"200\",\n  \"reason\": \"OK\",\n  \"headers\": {\n    \"Content-Type\": [\"application/octet-stream\", \"video/mpeg\"],\n    \"Transfer-Encoding\": [\"chunked\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```\n\n",
      "properties": {
        "version": {
          "name": "version",
          "description": "\nHTTP version, default is `\"1.1\"`\n\n",
          "markdownDescription": "\nHTTP version, default is `\"1.1\"`\n\n",
          "type": "string"
        },
        "status": {
          "name": "status",
          "description": "\nHTTP status, default is `\"200\"`\n\n",
          "markdownDescription": "\nHTTP status, default is `\"200\"`\n\n",
          "type": "string"
        },
        "reason": {
          "name": "reason",
          "description": "\nHTTP status description, default value is `\"OK\"`\n\n",
          "markdownDescription": "\nHTTP status description, default value is `\"OK\"`\n\n",
          "type": "string"
        },
        "headers": {
          "name": "headers",
          "description": "\nHTTP header, a key-value pair, each key represents the name of an HTTP header, and the corresponding value is an array.\n\nEach request will include all the keys and randomly select a corresponding value. Please refer to the **default values** shown in the example above.\n# mKCP\n\nmKCP uses UDP to emulate TCP connections.\n\nmKCP sacrifices bandwidth to reduce latency. To transmit the same content, mKCP generally consumes more data than TCP.\n\n::: tip\nMake sure the firewall on the host is configured correctly.\n:::\n\n",
          "markdownDescription": "\nHTTP header, a key-value pair, each key represents the name of an HTTP header, and the corresponding value is an array.\n\nEach request will include all the keys and randomly select a corresponding value. Please refer to the **default values** shown in the example above.\n# mKCP\n\nmKCP uses UDP to emulate TCP connections.\n\nmKCP sacrifices bandwidth to reduce latency. To transmit the same content, mKCP generally consumes more data than TCP.\n\n::: tip\nMake sure the firewall on the host is configured correctly.\n:::\n\n",
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    "KcpObject": {
      "title": "KcpObject",
      "description": "\n`KcpObject` corresponds to the `kcpSettings` in the [Transport Protocol](../transport.md),\n\n```json\n{\n  \"mtu\": 1350,\n  \"tti\": 20,\n  \"uplinkCapacity\": 5,\n  \"downlinkCapacity\": 20,\n  \"congestion\": false,\n  \"readBufferSize\": 1,\n  \"writeBufferSize\": 1,\n  \"header\": {\n    \"type\": \"none\"\n  },\n  \"seed\": \"Password\"\n}\n```\n\n",
      "markdownDescription": "\n`KcpObject` corresponds to the `kcpSettings` in the [Transport Protocol](../transport.md),\n\n```json\n{\n  \"mtu\": 1350,\n  \"tti\": 20,\n  \"uplinkCapacity\": 5,\n  \"downlinkCapacity\": 20,\n  \"congestion\": false,\n  \"readBufferSize\": 1,\n  \"writeBufferSize\": 1,\n  \"header\": {\n    \"type\": \"none\"\n  },\n  \"seed\": \"Password\"\n}\n```\n\n",
      "properties": {
        "mtu": {
          "name": "mtu",
          "description": "\nMaximum transmission unit. It indicates the maxium bytes that an UDP packet can carry. Recommended value is between `576` and `1460`\n\nThe default value is `1350`\n\n",
          "markdownDescription": "\nMaximum transmission unit. It indicates the maxium bytes that an UDP packet can carry. Recommended value is between `576` and `1460`\n\nThe default value is `1350`\n\n",
          "type": "number"
        },
        "tti": {
          "name": "tti",
          "description": "\nTransmission time interval, measured in milliseconds (ms), determines how often mKCP sends data. Please choose a value between `10` and `100`\n\nThe default value is `50`\n\n",
          "markdownDescription": "\nTransmission time interval, measured in milliseconds (ms), determines how often mKCP sends data. Please choose a value between `10` and `100`\n\nThe default value is `50`\n\n",
          "type": "number"
        },
        "uplinkCapacity": {
          "name": "uplinkCapacity",
          "description": "\nUplink capacity refers to the maximum bandwidth used by the host to send data, measured in MB/s (note: Byte, not bit). It can be set to 0, indicating a very small bandwidth.\n\nThe default value is `5`\n\n",
          "markdownDescription": "\nUplink capacity refers to the maximum bandwidth used by the host to send data, measured in MB/s (note: Byte, not bit). It can be set to 0, indicating a very small bandwidth.\n\nThe default value is `5`\n\n",
          "type": "number"
        },
        "downlinkCapacity": {
          "name": "downlinkCapacity",
          "description": "\nDownlink capacity refers to the maximum bandwidth used by the host to receive data, measured in MB/s (note: Byte, not bit). It can be set to 0, indicating a very small bandwidth.\n\nThe default value is `20`\n\n::: tip\n`uplinkCapacity` and `downlinkCapacity` determine the transmission speed of mKCP. For example, when a client sends data, the client's `uplinkCapacity` specifies the speed of sending data, while the server's `downlinkCapacity` specifies the speed of receiving data. The value used is the smaller of the two.\n\nIt is recommended to set `downlinkCapacity` to a larger value, such as `100`, and set `uplinkCapacity` to the actual network speed. If the speed is insufficient, gradually increase the value of `uplinkCapacity` until it is about twice the bandwidth.\n:::\n\n",
          "markdownDescription": "\nDownlink capacity refers to the maximum bandwidth used by the host to receive data, measured in MB/s (note: Byte, not bit). It can be set to 0, indicating a very small bandwidth.\n\nThe default value is `20`\n\n::: tip\n`uplinkCapacity` and `downlinkCapacity` determine the transmission speed of mKCP. For example, when a client sends data, the client's `uplinkCapacity` specifies the speed of sending data, while the server's `downlinkCapacity` specifies the speed of receiving data. The value used is the smaller of the two.\n\nIt is recommended to set `downlinkCapacity` to a larger value, such as `100`, and set `uplinkCapacity` to the actual network speed. If the speed is insufficient, gradually increase the value of `uplinkCapacity` until it is about twice the bandwidth.\n:::\n\n",
          "type": "number"
        },
        "congestion": {
          "name": "congestion",
          "description": "\nWhether or not to enable congestion control.\nWhen congestion control is enabled, Xray will detect network quality. It will send less packets when packet loss is severe, or more packets when network is not fully filled.\n\nThe default value is `false`\n\n",
          "markdownDescription": "\nWhether or not to enable congestion control.\nWhen congestion control is enabled, Xray will detect network quality. It will send less packets when packet loss is severe, or more packets when network is not fully filled.\n\nThe default value is `false`\n\n",
          "type": "boolean"
        },
        "readBufferSize": {
          "name": "readBufferSize",
          "description": "\nThe read buffer size for a single connection, measured in `MB`\n\nThe default value is `2`\n\n",
          "markdownDescription": "\nThe read buffer size for a single connection, measured in `MB`\n\nThe default value is `2`\n\n",
          "type": "number"
        },
        "writeBufferSize": {
          "name": "writeBufferSize",
          "description": "\nThe write buffer size for a single connection, measured in `MB`\n\nThe default value is `2`\n\n::: tip\n`readBufferSize` and `writeBufferSize` specify the memory size used by a single connection. When high-speed transmissions are required, specifying larger values for `readBufferSize` and `writeBufferSize` can improve speed to some extent, but it will also consume more memory.\n\nWhen the network speed is no more than `20 MB/s`, the default value of `1MB` is sufficient; after exceeding this limit, you can increase the values of `readBufferSize` and `writeBufferSize` appropriately and then manually balance the relationship between speed and memory.\n:::\n\n",
          "markdownDescription": "\nThe write buffer size for a single connection, measured in `MB`\n\nThe default value is `2`\n\n::: tip\n`readBufferSize` and `writeBufferSize` specify the memory size used by a single connection. When high-speed transmissions are required, specifying larger values for `readBufferSize` and `writeBufferSize` can improve speed to some extent, but it will also consume more memory.\n\nWhen the network speed is no more than `20 MB/s`, the default value of `1MB` is sufficient; after exceeding this limit, you can increase the values of `readBufferSize` and `writeBufferSize` appropriately and then manually balance the relationship between speed and memory.\n:::\n\n",
          "type": "number"
        },
        "header": {
          "name": "header",
          "description": "\nConfiguration for packet header obfuscation.\n\n",
          "markdownDescription": "\nConfiguration for packet header obfuscation.\n\n",
          "$ref": "#/definitions/HeaderObject"
        },
        "seed": {
          "name": "seed",
          "description": "\nAn optional obfuscation seed is used to obfuscate traffic data using the `AES-128-GCM` algorithm. The client and server need to use the same seed.\n\nThis obfuscation mechanism cannot ensure the security of the content, but it may be able to resist some blocking.\n\n::: tip NOTE\nCurrently, in the testing environment, enabling this setting has not resulted in the original unobfuscated version being blocked by ports.\n:::\n\n",
          "markdownDescription": "\nAn optional obfuscation seed is used to obfuscate traffic data using the `AES-128-GCM` algorithm. The client and server need to use the same seed.\n\nThis obfuscation mechanism cannot ensure the security of the content, but it may be able to resist some blocking.\n\n::: tip NOTE\nCurrently, in the testing environment, enabling this setting has not resulted in the original unobfuscated version being blocked by ports.\n:::\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "HeaderObject": {
      "title": "HeaderObject",
      "description": "\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"type\": \"none\"\n}\n```\n\n",
      "properties": {
        "type": {
          "name": "type",
          "description": "\nType of obfuscation. Corresponding inbound and outbound must have the same value. Choices are:\n\n- `\"none\"`\uff1aDefault value. No obfuscation is used.\n- `\"srtp\"`\uff1aObfuscated as SRTP traffic. It may be recognized as video calls such as Facetime.\n- `\"utp\"`\uff1aObfuscated as uTP traffic. It may be recognized as Bittorrent traffic.\n- `\"wechat-video\"`\uff1aObfuscated to WeChat traffic.\n- `\"dtls\"`\uff1aObfuscated as DTLS 1.2 packets.\n- `\"wireguard\"`\uff1aObfuscated as WireGuard packets. (NOT true WireGuard protocol)\n\n",
          "markdownDescription": "\nType of obfuscation. Corresponding inbound and outbound must have the same value. Choices are:\n\n- `\"none\"`\uff1aDefault value. No obfuscation is used.\n- `\"srtp\"`\uff1aObfuscated as SRTP traffic. It may be recognized as video calls such as Facetime.\n- `\"utp\"`\uff1aObfuscated as uTP traffic. It may be recognized as Bittorrent traffic.\n- `\"wechat-video\"`\uff1aObfuscated to WeChat traffic.\n- `\"dtls\"`\uff1aObfuscated as DTLS 1.2 packets.\n- `\"wireguard\"`\uff1aObfuscated as WireGuard packets. (NOT true WireGuard protocol)\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Special Thanks": {
      "title": "Special Thanks",
      "description": "\n- [@skywind3000](https://github.com/skywind3000) Credit for inventing and implementing the original KCP protocol in C.\n- [@xtaci](https://github.com/xtaci) Credit for re-implementing KCP protocol in Go.\n- [@xiaokangwang](https://github.com/xiaokangwang) Credit for testing the integration of KCP with Xray and submitting the initial PR.\n\n",
      "markdownDescription": "\n- [@skywind3000](https://github.com/skywind3000) Credit for inventing and implementing the original KCP protocol in C.\n- [@xtaci](https://github.com/xtaci) Credit for re-implementing KCP protocol in Go.\n- [@xiaokangwang](https://github.com/xiaokangwang) Credit for testing the integration of KCP with Xray and submitting the initial PR.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Improvements to the KCP protocol": {
      "title": "Improvements to the KCP protocol",
      "description": "\n",
      "markdownDescription": "\n",
      "properties": {},
      "additionalProperties": true
    },
    "smaller protocol header": {
      "title": "smaller protocol header",
      "description": "\nThe original KCP protocol uses a fixed header of 24 bytes, while mKCP modifies it to 18 bytes for data packets and 16 bytes for acknowledgement (ACK) packets. A smaller header helps evade feature detection and speeds up transmission.\n\nIn addition, the original KCP can only confirm that one packet has been received with a single ACK packet. This means that when KCP needs to confirm that 100 packets have been received, it will send out 2400 bytes of data (24 x 100), including a large amount of repeated header information that wastes bandwidth. mKCP compresses multiple ACK packets, so 100 ACK packets only require 418 bytes (16 + 2 + 100 x 4), which is equivalent to one-sixth of the original KCP.\n\n",
      "markdownDescription": "\nThe original KCP protocol uses a fixed header of 24 bytes, while mKCP modifies it to 18 bytes for data packets and 16 bytes for acknowledgement (ACK) packets. A smaller header helps evade feature detection and speeds up transmission.\n\nIn addition, the original KCP can only confirm that one packet has been received with a single ACK packet. This means that when KCP needs to confirm that 100 packets have been received, it will send out 2400 bytes of data (24 x 100), including a large amount of repeated header information that wastes bandwidth. mKCP compresses multiple ACK packets, so 100 ACK packets only require 418 bytes (16 + 2 + 100 x 4), which is equivalent to one-sixth of the original KCP.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "ACK packet retransmission": {
      "title": "ACK packet retransmission",
      "description": "\nIn the original KCP protocol, an ACK packet is only sent once. If an ACK packet is lost, it will cause unnecessary bandwidth waste due to data retransmission. In contrast, mKCP retransmits ACK packets at a certain frequency until they are confirmed by the sender. The size of a single ACK packet is 22 bytes, much smaller than the data packets which are over 1000 bytes. Therefore, the cost of retransmitting ACK packets is much lower.\n\n",
      "markdownDescription": "\nIn the original KCP protocol, an ACK packet is only sent once. If an ACK packet is lost, it will cause unnecessary bandwidth waste due to data retransmission. In contrast, mKCP retransmits ACK packets at a certain frequency until they are confirmed by the sender. The size of a single ACK packet is 22 bytes, much smaller than the data packets which are over 1000 bytes. Therefore, the cost of retransmitting ACK packets is much lower.\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "Connection state control": {
      "title": "Connection state control",
      "description": "\nmKCP can effectively initiate and close connections. When the remote host initiates disconnection, the connection will be released within two seconds. When the remote host lost connection, the connection will be released within a maximum of 30 seconds.\n\nThe original KCP does not support this scenario.\n# gRPC\n\nAn modified transport protocol based on gRPC.\n\ngRPC is based on the HTTP/2 protocol and can theoretically be relayed by other servers that support HTTP/2, such as Nginx.\n\ngRPC and HTTP/2 has built-in multiplexing, so it is not recommended to enable `mux.cool` when using gRPC or HTTP/2.\n\n::: warning \u26a0\u26a0\u26a0\n\n- gRPC doesn't support specifying the Host. Please enter the **correct domain name** in the outbound proxy address, or fill in `ServerName` in `(x)tlsSettings`, otherwise connection cannot be established.\n- gRPC doesn't support fallback to other services.\n- gRPC services are at risk of being actively probed. It is recommended to use reverse proxy tools such as Caddy or Nginx to perform path-based routing.\n  :::\n\n::: tip\nIf you are using a reverse proxy such as Caddy or Nginx, please note the following:\n\n- Make sure that the reverse proxy server has enabled HTTP/2.\n- Use HTTP/2 or h2c (Caddy), grpc_pass (Nginx) to connect to Xray.\n- The path for regular mode is `/${serviceName}/Tun`, and for Multi mode it is `/${serviceName}/TunMulti`.\n- If you need to receive the client IP address, you can use the `X-Real-IP` header sent by Caddy / Nginx to pass the client IP.\n  :::\n\n::: tip\nIf you are using fallback, please note the following:\n\n- Fallback to gRPC is not recommended, as there is a risk of being actively probed.\n- Please make sure that `h2` is the first priority in `(x)tlsSettings.alpn`, otherwise gRPC (HTTP/2) may not be able to complete TLS handshake.\n- gRPC cannot perform path-based routing by Xray.\n  :::\n\n",
      "markdownDescription": "\nmKCP can effectively initiate and close connections. When the remote host initiates disconnection, the connection will be released within two seconds. When the remote host lost connection, the connection will be released within a maximum of 30 seconds.\n\nThe original KCP does not support this scenario.\n# gRPC\n\nAn modified transport protocol based on gRPC.\n\ngRPC is based on the HTTP/2 protocol and can theoretically be relayed by other servers that support HTTP/2, such as Nginx.\n\ngRPC and HTTP/2 has built-in multiplexing, so it is not recommended to enable `mux.cool` when using gRPC or HTTP/2.\n\n::: warning \u26a0\u26a0\u26a0\n\n- gRPC doesn't support specifying the Host. Please enter the **correct domain name** in the outbound proxy address, or fill in `ServerName` in `(x)tlsSettings`, otherwise connection cannot be established.\n- gRPC doesn't support fallback to other services.\n- gRPC services are at risk of being actively probed. It is recommended to use reverse proxy tools such as Caddy or Nginx to perform path-based routing.\n  :::\n\n::: tip\nIf you are using a reverse proxy such as Caddy or Nginx, please note the following:\n\n- Make sure that the reverse proxy server has enabled HTTP/2.\n- Use HTTP/2 or h2c (Caddy), grpc_pass (Nginx) to connect to Xray.\n- The path for regular mode is `/${serviceName}/Tun`, and for Multi mode it is `/${serviceName}/TunMulti`.\n- If you need to receive the client IP address, you can use the `X-Real-IP` header sent by Caddy / Nginx to pass the client IP.\n  :::\n\n::: tip\nIf you are using fallback, please note the following:\n\n- Fallback to gRPC is not recommended, as there is a risk of being actively probed.\n- Please make sure that `h2` is the first priority in `(x)tlsSettings.alpn`, otherwise gRPC (HTTP/2) may not be able to complete TLS handshake.\n- gRPC cannot perform path-based routing by Xray.\n  :::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "GRPCObject": {
      "title": "GRPCObject",
      "description": "\n`GRPCObject` corresponds to the `grpcSettings` item.\n\n```json\n{\n  \"serviceName\": \"name\",\n  \"multiMode\": false,\n  \"idle_timeout\": 60,\n  \"health_check_timeout\": 20,\n  \"permit_without_stream\": false,\n  \"initial_windows_size\": 0\n}\n```\n\n",
      "markdownDescription": "\n`GRPCObject` corresponds to the `grpcSettings` item.\n\n```json\n{\n  \"serviceName\": \"name\",\n  \"multiMode\": false,\n  \"idle_timeout\": 60,\n  \"health_check_timeout\": 20,\n  \"permit_without_stream\": false,\n  \"initial_windows_size\": 0\n}\n```\n\n",
      "properties": {
        "serviceName": {
          "name": "serviceName",
          "description": "\nA string that specifies the service name, similar to the `path` in HTTP/2.\n\nThe client will use this name for communication, and the server will verify whether the service name matches.\n\n",
          "markdownDescription": "\nA string that specifies the service name, similar to the `path` in HTTP/2.\n\nThe client will use this name for communication, and the server will verify whether the service name matches.\n\n",
          "type": "string"
        },
        "multiMode": {
          "name": "multiMode",
          "description": "\n`true` enables `multiMode`, with a default value of `false`.\n\nThis is an **experimental** option that may not be retained for the long term, and cross-version compatibility is not guaranteed. This mode can bring about a performance improvement of around 20% in **test environments**, but actual effects may vary depending on the transmission rate.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "markdownDescription": "\n`true` enables `multiMode`, with a default value of `false`.\n\nThis is an **experimental** option that may not be retained for the long term, and cross-version compatibility is not guaranteed. This mode can bring about a performance improvement of around 20% in **test environments**, but actual effects may vary depending on the transmission rate.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "type": "boolean"
        },
        "idle_timeout": {
          "name": "idle_timeout",
          "description": "\nThe health check is performed when no data transmission occurs for a certain period of time, measured in seconds. If this value is set to less than `10`, `10` will be used as the minimum value.\n\n::: tip\nIf you are not using reverse proxy tools such as Caddy or Nginx (**which is usually the case**), if this value is set to less than `60`, the server may send \"unexpected h2 GOAWAY\" frames to close existing connections.\n:::\n\nBy default, the health check is **not enabled**.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n::: tip\nEnabling health checks may help solve some \"connection drop\" issues.\n:::\n\n",
          "markdownDescription": "\nThe health check is performed when no data transmission occurs for a certain period of time, measured in seconds. If this value is set to less than `10`, `10` will be used as the minimum value.\n\n::: tip\nIf you are not using reverse proxy tools such as Caddy or Nginx (**which is usually the case**), if this value is set to less than `60`, the server may send \"unexpected h2 GOAWAY\" frames to close existing connections.\n:::\n\nBy default, the health check is **not enabled**.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n::: tip\nEnabling health checks may help solve some \"connection drop\" issues.\n:::\n\n",
          "type": "number"
        },
        "health_check_timeout": {
          "name": "health_check_timeout",
          "description": "\nThe timeout for the health check, measured in seconds. If the health check is not completed within this time period, it is considered to have failed.\nThe default value is `20`\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "markdownDescription": "\nThe timeout for the health check, measured in seconds. If the health check is not completed within this time period, it is considered to have failed.\nThe default value is `20`\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "type": "number"
        },
        "permit_without_stream": {
          "name": "permit_without_stream",
          "description": "\n`true` allows health checks to be performed when there are no sub-connections. The default value is `false`.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "markdownDescription": "\n`true` allows health checks to be performed when there are no sub-connections. The default value is `false`.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "type": "boolean"
        },
        "initial_windows_size": {
          "name": "initial_windows_size",
          "description": "\nThe initial window size of the h2 stream. When the value is less than or equal to `0`, this feature does not take effect. When the value is greater than `65535`, the Dynamic Window mechanism will be disabled. The default value is `0`, which means it is not effective.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n::: tip\nWhen using Cloudflare CDN, set the value to `35536` or higher to disable the Dynamic Window mechanism and prevent Cloudflare CDN from sending \"unexpected h2 GOAWAY\" frames to close existing connections.\n:::\n# HTTP/2\n\nThe transmission mode based on HTTP/2 fully implements the HTTP/2 standard and can be relayed by other HTTP servers (such as Nginx).\n\nBased on the recommendations of HTTP/2, both the client and server must enable TLS to use this transmission mode normally.\n\nHTTP/2 has built-in multiplexing, so it is not recommended to enable mux.cool when using HTTP/2.\n\n::: tip\nThe current version of the transmission mode based on HTTP/2 does not require TLS configuration for inbound (server-side).\n\nThis makes it possible to use a plaintext HTTP/2 protocol called h2c for communication between the gateway and Xray, with external gateway components handling the TLS layer conversation in special-purpose load-balancing deployment environments.\n:::\n\n::: warning\n\u26a0\ufe0f If you are using fallback, please note the following:\n\n- Please make sure that `h2` is included in `(x)tlsSettings.alpn`, otherwise HTTP/2 cannot complete TLS handshake.\n- HTTP/2 cannot perform path-based routing, so it is recommended to use SNI-based routing.\n  :::\n\n",
          "markdownDescription": "\nThe initial window size of the h2 stream. When the value is less than or equal to `0`, this feature does not take effect. When the value is greater than `65535`, the Dynamic Window mechanism will be disabled. The default value is `0`, which means it is not effective.\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n::: tip\nWhen using Cloudflare CDN, set the value to `35536` or higher to disable the Dynamic Window mechanism and prevent Cloudflare CDN from sending \"unexpected h2 GOAWAY\" frames to close existing connections.\n:::\n# HTTP/2\n\nThe transmission mode based on HTTP/2 fully implements the HTTP/2 standard and can be relayed by other HTTP servers (such as Nginx).\n\nBased on the recommendations of HTTP/2, both the client and server must enable TLS to use this transmission mode normally.\n\nHTTP/2 has built-in multiplexing, so it is not recommended to enable mux.cool when using HTTP/2.\n\n::: tip\nThe current version of the transmission mode based on HTTP/2 does not require TLS configuration for inbound (server-side).\n\nThis makes it possible to use a plaintext HTTP/2 protocol called h2c for communication between the gateway and Xray, with external gateway components handling the TLS layer conversation in special-purpose load-balancing deployment environments.\n:::\n\n::: warning\n\u26a0\ufe0f If you are using fallback, please note the following:\n\n- Please make sure that `h2` is included in `(x)tlsSettings.alpn`, otherwise HTTP/2 cannot complete TLS handshake.\n- HTTP/2 cannot perform path-based routing, so it is recommended to use SNI-based routing.\n  :::\n\n",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "HttpObject": {
      "title": "HttpObject",
      "description": "\n`HttpObject` corresponds to the `httpSettings` in the [Transport Protocol](../transport.md),\n\n```json\n{\n  \"host\": [\"xray.com\"],\n  \"path\": \"/random/path\",\n  \"read_idle_timeout\": 10,\n  \"health_check_timeout\": 15,\n  \"method\": \"PUT\",\n  \"headers\": {\n    \"Header\": [\"value\"]\n  }\n}\n```\n\n",
      "markdownDescription": "\n`HttpObject` corresponds to the `httpSettings` in the [Transport Protocol](../transport.md),\n\n```json\n{\n  \"host\": [\"xray.com\"],\n  \"path\": \"/random/path\",\n  \"read_idle_timeout\": 10,\n  \"health_check_timeout\": 15,\n  \"method\": \"PUT\",\n  \"headers\": {\n    \"Header\": [\"value\"]\n  }\n}\n```\n\n",
      "properties": {
        "host": {
          "name": "host",
          "description": "\nA string array, where each element is a domain name.\n\nThe client will randomly select a domain name from the list for communication, and the server will verify whether the domain name is in the list.\n\n",
          "markdownDescription": "\nA string array, where each element is a domain name.\n\nThe client will randomly select a domain name from the list for communication, and the server will verify whether the domain name is in the list.\n\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "name": "path",
          "description": "\nThe HTTP path starts with `/` and must be the same value between the client and server.\n\nThe default value is `/`\n\n",
          "markdownDescription": "\nThe HTTP path starts with `/` and must be the same value between the client and server.\n\nThe default value is `/`\n\n",
          "type": "string"
        },
        "read_idle_timeout": {
          "name": "read_idle_timeout",
          "description": "\nThe connection health check is performed when no data has been received for a certain period of time, measured in seconds.\n\nBy default, the health check is **disabled**.\n\n::: tip\n**Only need to be configured** in **`outbound`** (**client**).\n:::\n\n::: tip\nEnabling health checks may help solve some \"connection drop\" issues.\n:::\n\n",
          "markdownDescription": "\nThe connection health check is performed when no data has been received for a certain period of time, measured in seconds.\n\nBy default, the health check is **disabled**.\n\n::: tip\n**Only need to be configured** in **`outbound`** (**client**).\n:::\n\n::: tip\nEnabling health checks may help solve some \"connection drop\" issues.\n:::\n\n",
          "type": "number"
        },
        "health_check_timeout": {
          "name": "health_check_timeout",
          "description": "\nThe timeout for the health check, measured in seconds. If the health check is not completed within this time period, it is considered to have failed.\nThe default value is `15`\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "markdownDescription": "\nThe timeout for the health check, measured in seconds. If the health check is not completed within this time period, it is considered to have failed.\nThe default value is `15`\n\n::: tip\n**Only need to be configured** in `outbound` **(client)**.\n:::\n\n",
          "type": "number"
        },
        "method": {
          "name": "method",
          "description": "\nHTTP request method. The default value is `PUT`\n\nPlease refer this [this](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) when configure.\n\n",
          "markdownDescription": "\nHTTP request method. The default value is `PUT`\n\nPlease refer this [this](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) when configure.\n\n",
          "type": "string"
        },
        "headers": {
          "name": "headers",
          "description": "\nCustom HTTP headers, defined as key-value pairs. Each key represents an HTTP header name and its corresponding value is an array.\n# SOCKS\n\nThe standard SOCKS protocol implementation is compatible with [SOCKS 4](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol), SOCKS 4a, and [SOCKS 5](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol).\n\n::: danger\nThe SOCKS protocol does not provide encryption for transport and is not suitable for transmitting data over public networks.\n:::\n\nThe use of `SOCKS` inbound is more meaningful in a local area network or local environment, where it can be used to listen for incoming connections and provide local services to other programs.\n\n",
          "markdownDescription": "\nCustom HTTP headers, defined as key-value pairs. Each key represents an HTTP header name and its corresponding value is an array.\n# SOCKS\n\nThe standard SOCKS protocol implementation is compatible with [SOCKS 4](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol), SOCKS 4a, and [SOCKS 5](http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol).\n\n::: danger\nThe SOCKS protocol does not provide encryption for transport and is not suitable for transmitting data over public networks.\n:::\n\nThe use of `SOCKS` inbound is more meaningful in a local area network or local environment, where it can be used to listen for incoming connections and provide local services to other programs.\n\n",
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    "InboundConfigurationObject": {
      "anyOf": [
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"auth\": \"noauth\",\n  \"accounts\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ],\n  \"udp\": false,\n  \"ip\": \"127.0.0.1\",\n  \"userLevel\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"auth\": \"noauth\",\n  \"accounts\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ],\n  \"udp\": false,\n  \"ip\": \"127.0.0.1\",\n  \"userLevel\": 0\n}\n```\n\n",
          "properties": {
            "auth": {
              "name": "auth",
              "description": "\nThe authentication method for the SOCKS protocol, supporting `\"noauth\"` for anonymous mode and `\"password\"` for username/password authentication.\n\nThe default value is `\"noauth\"`.\n\n",
              "markdownDescription": "\nThe authentication method for the SOCKS protocol, supporting `\"noauth\"` for anonymous mode and `\"password\"` for username/password authentication.\n\nThe default value is `\"noauth\"`.\n\n",
              "anyOf": [
                {
                  "const": "noauth"
                },
                {
                  "const": "password"
                }
              ]
            },
            "accounts": {
              "name": "accounts",
              "description": "\nAn array where each element represents a user account.\n\nThis option is only valid when `auth` is set to `\"password\"`.\n\nThe default value is an empty array.\n\n",
              "markdownDescription": "\nAn array where each element represents a user account.\n\nThis option is only valid when `auth` is set to `\"password\"`.\n\nThe default value is an empty array.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/AccountObject"
              }
            },
            "udp": {
              "name": "udp",
              "description": "\nWhether to enable UDP protocol support.\n\nThe default value is `false`.\n\n",
              "markdownDescription": "\nWhether to enable UDP protocol support.\n\nThe default value is `false`.\n\n",
              "type": "boolean"
            },
            "ip": {
              "name": "ip",
              "description": "\nWhen UDP is enabled, Xray needs to know the local IP address.\n\nThe default value is `\"127.0.0.1\"`.\n\n",
              "markdownDescription": "\nWhen UDP is enabled, Xray needs to know the local IP address.\n\nThe default value is `\"127.0.0.1\"`.\n\n",
              "type": "string"
            },
            "userLevel": {
              "name": "userLevel",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"secretKey\": \"PRIVATE_KEY\",\n  \"peers\": [\n    {\n      \"publicKey\": \"PUBLIC_KEY\",\n      \"allowedIPs\":[\"\"]\n    }\n  ],\n  \"kernelMode\": true, // optional, default true if it's supported and permission is sufficient\n  \"mtu\": 1420, // optional, default 1420\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"secretKey\": \"PRIVATE_KEY\",\n  \"peers\": [\n    {\n      \"publicKey\": \"PUBLIC_KEY\",\n      \"allowedIPs\":[\"\"]\n    }\n  ],\n  \"kernelMode\": true, // optional, default true if it's supported and permission is sufficient\n  \"mtu\": 1420, // optional, default 1420\n}\n```\n\n",
          "properties": {
            "secretKey": {
              "name": "secretKey",
              "description": "\nPrivate key. Required.\n\n",
              "markdownDescription": "\nPrivate key. Required.\n\n",
              "type": "string"
            },
            "mtu": {
              "name": "mtu",
              "description": "\nFragmentation size of the underlying Wireguard tun.\n\n<details>\n<summary>MTU Calculation Method</summary>\n\nThe structure of a Wireguard packet is as follows:\n\n```\n- 20-byte IPv4 header or 40 byte IPv6 header\n- 8-byte UDP header\n- 4-byte type\n- 4-byte key index\n- 8-byte nonce\n- N-byte encrypted data\n- 16-byte authentication tag\n```\n\n`N-byte encrypted data` is the MTU value we need. Depending on whether the endpoint is IPv4 or IPv6, the specific values can be 1440 (IPv4) or 1420 (IPv6). If in a special environment, subtract additional bytes accordingly (e.g., subtract 8 more bytes for PPPoE over home broadband).\n\n</details>\n\n",
              "markdownDescription": "\nFragmentation size of the underlying Wireguard tun.\n\n<details>\n<summary>MTU Calculation Method</summary>\n\nThe structure of a Wireguard packet is as follows:\n\n```\n- 20-byte IPv4 header or 40 byte IPv6 header\n- 8-byte UDP header\n- 4-byte type\n- 4-byte key index\n- 8-byte nonce\n- N-byte encrypted data\n- 16-byte authentication tag\n```\n\n`N-byte encrypted data` is the MTU value we need. Depending on whether the endpoint is IPv4 or IPv6, the specific values can be 1440 (IPv4) or 1420 (IPv6). If in a special environment, subtract additional bytes accordingly (e.g., subtract 8 more bytes for PPPoE over home broadband).\n\n</details>\n\n",
              "type": "integer"
            },
            "peers": {
              "name": "peers",
              "description": "\nList of peer servers, where each entry is a server configuration.\n\n",
              "markdownDescription": "\nList of peer servers, where each entry is a server configuration.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Peers"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"clients\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"level\": 0,\n      \"email\": \"love@xray.com\",\n      \"flow\": \"xtls-rprx-vision\"\n    }\n  ],\n  \"decryption\": \"none\",\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"clients\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"level\": 0,\n      \"email\": \"love@xray.com\",\n      \"flow\": \"xtls-rprx-vision\"\n    }\n  ],\n  \"decryption\": \"none\",\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "clients": {
              "name": "clients",
              "description": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\n",
              "markdownDescription": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ClientObject"
              }
            },
            "decryption": {
              "name": "decryption",
              "description": "\nCurrently, you need to specify `\"none\"`. It cannot be left empty. If the `decryption` value is not set correctly, you will receive an error message when using Xray or `-test`.\n\nNote that `decryption` is at the same level as `clients`. The placement of `decryption` is different from the `encryption` in the vmess protocol because if there is a layer of agreed encryption, the server needs to decrypt it first to know which user it belongs to.\n\n",
              "markdownDescription": "\nCurrently, you need to specify `\"none\"`. It cannot be left empty. If the `decryption` value is not set correctly, you will receive an error message when using Xray or `-test`.\n\nNote that `decryption` is at the same level as `clients`. The placement of `decryption` is different from the `encryption` in the vmess protocol because if there is a layer of agreed encryption, the server needs to decrypt it first to know which user it belongs to.\n\n",
              "const": "none"
            },
            "fallbacks": {
              "name": "fallbacks",
              "description": "\nAn array that contains a series of powerful fallback configurations (optional). The specific configuration for `fallbacks` can be found in the [FallbackObject](../features/fallback.md#fallbacks-configuration) documentation.\n\n",
              "markdownDescription": "\nAn array that contains a series of powerful fallback configurations (optional). The specific configuration for `fallbacks` can be found in the [FallbackObject](../features/fallback.md#fallbacks-configuration) documentation.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/FallbackObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"clients\": [\n    {\n      \"password\": \"password\",\n      \"email\": \"love@xray.com\",\n      \"level\": 0\n    }\n  ],\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"clients\": [\n    {\n      \"password\": \"password\",\n      \"email\": \"love@xray.com\",\n      \"level\": 0\n    }\n  ],\n  \"fallbacks\": [\n    {\n      \"dest\": 80\n    }\n  ]\n}\n```\n\n",
          "properties": {
            "clients": {
              "name": "clients",
              "description": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\n",
              "markdownDescription": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ClientObject"
              }
            },
            "fallbacks": {
              "name": "fallbacks",
              "description": "\nAn array that contains a series of powerful fallback configurations (optional). The specific configuration for `fallbacks` can be found in the [FallbackObject](../features/fallback.md#fallbacks-configuration) documentation.\n\n::: tip\nXray's Trojan has full support for fallbacks, and the configuration is identical. The conditions triggering fallback are similar to VLESS: first packet length < 58 or the 57th byte is not `\\r` (because Trojan does not have a protocol version) or authentication failure.\n:::\n\n",
              "markdownDescription": "\nAn array that contains a series of powerful fallback configurations (optional). The specific configuration for `fallbacks` can be found in the [FallbackObject](../features/fallback.md#fallbacks-configuration) documentation.\n\n::: tip\nXray's Trojan has full support for fallbacks, and the configuration is identical. The conditions triggering fallback are similar to VLESS: first packet length < 58 or the 57th byte is not `\\r` (because Trojan does not have a protocol version) or authentication failure.\n:::\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/FallbackObject"
              }
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"settings\": {\n    \"clients\": [],\n    \"password\": \"password\",\n    \"method\": \"aes-256-gcm\",\n    \"level\": 0,\n    \"email\": \"love@xray.com\",\n    \"network\": \"tcp,udp\"\n  }\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"settings\": {\n    \"clients\": [],\n    \"password\": \"password\",\n    \"method\": \"aes-256-gcm\",\n    \"level\": 0,\n    \"email\": \"love@xray.com\",\n    \"network\": \"tcp,udp\"\n  }\n}\n```\n\n",
          "properties": {
            "clients": {
              "name": "clients",
              "description": "\nThe `password` parameter can be specified for the server at all, but also in the [`ClientObject`](#clientobject) being dedicated to the given user. Server-level `password` is not guaranteed to override the client-specific one.\n\n",
              "markdownDescription": "\nThe `password` parameter can be specified for the server at all, but also in the [`ClientObject`](#clientobject) being dedicated to the given user. Server-level `password` is not guaranteed to override the client-specific one.\n\n"
            },
            "network": {
              "name": "network",
              "description": "\nThe supported network protocol type. For example, when specified as `\"tcp\"`, it will only handle TCP traffic. The default value is `\"tcp\"`.\n\n",
              "markdownDescription": "\nThe supported network protocol type. For example, when specified as `\"tcp\"`, it will only handle TCP traffic. The default value is `\"tcp\"`.\n\n",
              "anyOf": [
                {
                  "const": "tcp"
                },
                {
                  "const": "udp"
                },
                {
                  "const": "tcp,udp"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"clients\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"level\": 0,\n      \"email\": \"love@xray.com\"\n    }\n  ],\n  \"default\": {\n    \"level\": 0\n  },\n  \"detour\": {\n    \"to\": \"tag_to_detour\"\n  }\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"clients\": [\n    {\n      \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n      \"level\": 0,\n      \"email\": \"love@xray.com\"\n    }\n  ],\n  \"default\": {\n    \"level\": 0\n  },\n  \"detour\": {\n    \"to\": \"tag_to_detour\"\n  }\n}\n```\n\n",
          "properties": {
            "clients": {
              "name": "clients",
              "description": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\nWhen this configuration is used for dynamic ports, Xray will automatically create users.\n\n",
              "markdownDescription": "\nAn array representing a group of users approved by the server.\n\nEach item in the array is a user [ClientObject](#clientobject).\n\nWhen this configuration is used for dynamic ports, Xray will automatically create users.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ClientObject"
              }
            },
            "detour": {
              "name": "detour",
              "description": "\nIndicates that another server should be used for the corresponding outbound protocol.\n\n",
              "markdownDescription": "\nIndicates that another server should be used for the corresponding outbound protocol.\n\n",
              "$ref": "#/definitions/DetourObject"
            },
            "default": {
              "name": "default",
              "description": "\nOptional. The default configuration for clients. Only effective when used with `detour`.\n\n",
              "markdownDescription": "\nOptional. The default configuration for clients. Only effective when used with `detour`.\n\n",
              "$ref": "#/definitions/DefaultObject"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"address\": \"8.8.8.8\",\n  \"port\": 53,\n  \"network\": \"tcp\",\n  \"followRedirect\": false,\n  \"userLevel\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"address\": \"8.8.8.8\",\n  \"port\": 53,\n  \"network\": \"tcp\",\n  \"followRedirect\": false,\n  \"userLevel\": 0\n}\n```\n\n",
          "properties": {
            "address": {
              "name": "address",
              "description": "\nThe address to forward the traffic to. It can be an IP address like `\"1.2.3.4\"` or a domain name like `\"xray.com\"`. It is a string type.\n\nWhen `followRedirect` (see below) is set to `true`, `address` can be empty.\n\n",
              "markdownDescription": "\nThe address to forward the traffic to. It can be an IP address like `\"1.2.3.4\"` or a domain name like `\"xray.com\"`. It is a string type.\n\nWhen `followRedirect` (see below) is set to `true`, `address` can be empty.\n\n",
              "type": "string"
            },
            "port": {
              "name": "port",
              "description": "\nThe specified port on the destination address to forward the traffic to. It should be in the range 1,655351,65535. It is a numeric value and is a required parameter.\n\n",
              "markdownDescription": "\nThe specified port on the destination address to forward the traffic to. It should be in the range 1,655351,65535. It is a numeric value and is a required parameter.\n\n",
              "type": "number"
            },
            "network": {
              "name": "network",
              "description": "\nThe supported network protocol type. For example, when specified as `\"tcp\"`, it will only receive TCP traffic. The default value is `\"tcp\"`.\n\n",
              "markdownDescription": "\nThe supported network protocol type. For example, when specified as `\"tcp\"`, it will only receive TCP traffic. The default value is `\"tcp\"`.\n\n",
              "anyOf": [
                {
                  "const": "tcp"
                },
                {
                  "const": "udp"
                },
                {
                  "const": "tcp,udp"
                }
              ]
            },
            "followRedirect": {
              "name": "followRedirect",
              "description": "\nWhen set to `true`, dokodemo-door will recognize data forwarded by iptables and forward it to the corresponding destination address.\n\nRefer to the `tproxy` setting in the [Transport Configuration](../transport.md#sockoptobject) for more information.\n\n",
              "markdownDescription": "\nWhen set to `true`, dokodemo-door will recognize data forwarded by iptables and forward it to the corresponding destination address.\n\nRefer to the `tproxy` setting in the [Transport Configuration](../transport.md#sockoptobject) for more information.\n\n",
              "type": "boolean"
            },
            "userLevel": {
              "name": "userLevel",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "InboundConfigurationObject",
          "description": "\n```json\n{\n  \"accounts\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ],\n  \"allowTransparent\": false,\n  \"userLevel\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"accounts\": [\n    {\n      \"user\": \"my-username\",\n      \"pass\": \"my-password\"\n    }\n  ],\n  \"allowTransparent\": false,\n  \"userLevel\": 0\n}\n```\n\n",
          "properties": {
            "accounts": {
              "name": "accounts",
              "description": "\nAn array where each element represents a user account. The default value is an empty array.\n\nWhen `accounts` is not empty, the HTTP proxy will perform Basic Authentication verification for inbound connections.\n\n",
              "markdownDescription": "\nAn array where each element represents a user account. The default value is an empty array.\n\nWhen `accounts` is not empty, the HTTP proxy will perform Basic Authentication verification for inbound connections.\n\n",
              "type": "array",
              "items": {
                "$ref": "#/definitions/AccountObject"
              }
            },
            "allowTransparent": {
              "name": "allowTransparent",
              "description": "\nWhen set to `true`, it will forward all HTTP requests instead of just proxy requests.\n\n::: tip\nEnabling this option without proper configuration may cause an infinite loop.\n:::\n\n",
              "markdownDescription": "\nWhen set to `true`, it will forward all HTTP requests instead of just proxy requests.\n\n::: tip\nEnabling this option without proper configuration may cause an infinite loop.\n:::\n\n",
              "type": "boolean"
            },
            "userLevel": {
              "name": "userLevel",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `userLevel` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ClientObject": {
      "anyOf": [
        {
          "title": "ClientObject",
          "description": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\",\n  \"flow\": \"xtls-rprx-vision\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\",\n  \"flow\": \"xtls-rprx-vision\"\n}\n```\n\n",
          "properties": {
            "id": {
              "name": "id",
              "description": "\nThe user ID for VLESS. It can be any string less than 30 bytes or a valid UUID. Custom strings and their corresponding UUIDs are equivalent, which means you can use either of the following in the configuration file to identify the same user:\n\n- `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`\n- `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (This UUID is the mapping of the string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string.\n\n> You can also use the command `xray uuid` to generate a random UUID.\n\n",
              "markdownDescription": "\nThe user ID for VLESS. It can be any string less than 30 bytes or a valid UUID. Custom strings and their corresponding UUIDs are equivalent, which means you can use either of the following in the configuration file to identify the same user:\n\n- `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`\n- `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (This UUID is the mapping of the string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string.\n\n> You can also use the command `xray uuid` to generate a random UUID.\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            },
            "email": {
              "name": "email",
              "description": "\nUser email address used to differentiate traffic from different users (reflected in logs and statistics).\n\n",
              "markdownDescription": "\nUser email address used to differentiate traffic from different users (reflected in logs and statistics).\n\n",
              "type": "string"
            },
            "flow": {
              "name": "flow",
              "description": "\nFlow control mode used to select the XTLS algorithm.\n\nCurrently, the following flow control modes are available for inbound protocols:\n\n- No `flow` or empty string: Use regular TLS proxy.\n- `xtls-rprx-vision`: Use the new XTLS mode, including inner-handshake random padding.\n\n\n\nAdditionally, XTLS currently only supports TCP+TLS/Reality. \n# Trojan\n\nThe [Trojan](https://trojan-gfw.github.io/trojan/protocol) protocol.\n\n::: danger\nTrojan is designed to work with correctly configured encrypted TLS tunnels.\n:::\n\n",
              "markdownDescription": "\nFlow control mode used to select the XTLS algorithm.\n\nCurrently, the following flow control modes are available for inbound protocols:\n\n- No `flow` or empty string: Use regular TLS proxy.\n- `xtls-rprx-vision`: Use the new XTLS mode, including inner-handshake random padding.\n\n\n\nAdditionally, XTLS currently only supports TCP+TLS/Reality. \n# Trojan\n\nThe [Trojan](https://trojan-gfw.github.io/trojan/protocol) protocol.\n\n::: danger\nTrojan is designed to work with correctly configured encrypted TLS tunnels.\n:::\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ClientObject",
          "description": "\n```json\n{\n  \"password\": \"password\",\n  \"email\": \"love@xray.com\",\n  \"level\": 0\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"password\": \"password\",\n  \"email\": \"love@xray.com\",\n  \"level\": 0\n}\n```\n\n",
          "properties": {
            "password": {
              "name": "password",
              "description": "\nRequired. Any string.\n\n",
              "markdownDescription": "\nRequired. Any string.\n\n",
              "type": "string"
            },
            "email": {
              "name": "email",
              "description": "\nEmail address. Optional. Used to identify the user.\n\n::: danger\nIf there are multiple `ClientObject`s, please make sure that the email addresses are not duplicated.\n:::\n\n",
              "markdownDescription": "\nEmail address. Optional. Used to identify the user.\n\n::: danger\nIf there are multiple `ClientObject`s, please make sure that the email addresses are not duplicated.\n:::\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Shadowsocks\n\nThe [Shadowsocks](https://en.wikipedia.org/wiki/Shadowsocks) protocol is compatible with most other implementations of Shadowsocks. The server supports TCP and UDP packet forwarding, with an option to selectively disable UDP.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Shadowsocks\n\nThe [Shadowsocks](https://en.wikipedia.org/wiki/Shadowsocks) protocol is compatible with most other implementations of Shadowsocks. The server supports TCP and UDP packet forwarding, with an option to selectively disable UDP.\n\n",
              "type": "number"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ClientObject",
          "description": "\n```json\n{\n  \"password\": \"\u5bc6\u7801\",\n  \"method\": \"aes-256-gcm\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"password\": \"\u5bc6\u7801\",\n  \"method\": \"aes-256-gcm\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\"\n}\n```\n\n",
          "properties": {
            "method": {
              "name": "method",
              "description": "\nRequired, any of the [supported methods](#supportedencryptionmethods)\n\n",
              "markdownDescription": "\nRequired, any of the [supported methods](#supportedencryptionmethods)\n\n",
              "type": "string"
            },
            "password": {
              "name": "password",
              "description": "\nRequired. For **Shadowsocks 2022** a pre-shared `base64` random key similar to WireGuard's keys should be used as the password. The command \n```sh\nopenssl rand -base64 <length>\n```\ncould used to generate a key. The length of the required key for `shadowsocks-rust` implementation depends on the encryption method:\n\n| Encryption Method               | Key Length |\n| -----------------------------   | ---------: |\n| `2022-blake3-aes-128-gcm`       |         16 |\n| `2022-blake3-aes-256-gcm`       |         32 |\n| `2022-blake3-chacha20-poly1305` |         32 |\n\nIn the `go-shadowsocks` implementation written in Golang, a 32-byte key always works. \n\nFor **any other encryption method** _any string_ could be used. There is no limitation on the password length, but shorter passwords are more susceptible to cracking. It is recommended to use a random-generated password of 16 characters or longer. The following example generates 40-characters length password:\n```sh\nsudo strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 40 | tr -d '\\n'; echo\n```\n\n",
              "markdownDescription": "\nRequired. For **Shadowsocks 2022** a pre-shared `base64` random key similar to WireGuard's keys should be used as the password. The command \n```sh\nopenssl rand -base64 <length>\n```\ncould used to generate a key. The length of the required key for `shadowsocks-rust` implementation depends on the encryption method:\n\n| Encryption Method               | Key Length |\n| -----------------------------   | ---------: |\n| `2022-blake3-aes-128-gcm`       |         16 |\n| `2022-blake3-aes-256-gcm`       |         32 |\n| `2022-blake3-chacha20-poly1305` |         32 |\n\nIn the `go-shadowsocks` implementation written in Golang, a 32-byte key always works. \n\nFor **any other encryption method** _any string_ could be used. There is no limitation on the password length, but shorter passwords are more susceptible to cracking. It is recommended to use a random-generated password of 16 characters or longer. The following example generates 40-characters length password:\n```sh\nsudo strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 40 | tr -d '\\n'; echo\n```\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            },
            "email": {
              "name": "email",
              "description": "\nThe user's email, used to differentiate traffic from different users for logs or statistics.\n# VMess\n\n[VMess](../../development/protocols/vmess.md) is an encrypted transport protocol that is commonly used as a bridge between Xray clients and servers.\n\n::: danger\nVMess relies on system time. Please ensure that the system UTC time used by Xray is within 120 seconds of the actual time, regardless of time zone. On Linux systems, you can install the `ntp` service to automatically synchronize the system time.\n:::\n\n",
              "markdownDescription": "\nThe user's email, used to differentiate traffic from different users for logs or statistics.\n# VMess\n\n[VMess](../../development/protocols/vmess.md) is an encrypted transport protocol that is commonly used as a bridge between Xray clients and servers.\n\n::: danger\nVMess relies on system time. Please ensure that the system UTC time used by Xray is within 120 seconds of the actual time, regardless of time zone. On Linux systems, you can install the `ntp` service to automatically synchronize the system time.\n:::\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "title": "ClientObject",
          "description": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\"\n}\n```\n\n",
          "markdownDescription": "\n```json\n{\n  \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\",\n  \"level\": 0,\n  \"email\": \"love@xray.com\"\n}\n```\n\n",
          "properties": {
            "id": {
              "name": "id",
              "description": "\nThe user ID for VMess. It can be any string less than 30 bytes or a valid UUID.\n\n::: tip\nCustom strings and their corresponding UUIDs are equivalent, which means you can use either of the following in the configuration file to identify the same user:\n\n- `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`\n- `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (This UUID is the mapping of the string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string.\n\nYou can also use the command `xray uuid` to generate a random UUID. :::\n\n",
              "markdownDescription": "\nThe user ID for VMess. It can be any string less than 30 bytes or a valid UUID.\n\n::: tip\nCustom strings and their corresponding UUIDs are equivalent, which means you can use either of the following in the configuration file to identify the same user:\n\n- `\"id\": \"\u6211\u7231\ud83c\udf49\u8001\u5e081314\"`\n- `\"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"` (This UUID is the mapping of the string \"\u6211\u7231 \ud83c\udf49 \u8001\u5e08 1314\")\n\nThe mapping standard is described in the [VLESS UUID Mapping Standard: Mapping a Custom String to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).\n\nYou can use the command `xray uuid -i \"custom string\"` to generate the UUID corresponding to a custom string.\n\nYou can also use the command `xray uuid` to generate a random UUID. :::\n\n",
              "type": "string"
            },
            "level": {
              "name": "level",
              "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n\n",
              "type": "number"
            },
            "email": {
              "name": "email",
              "description": "\nThe user's email address, used to differentiate traffic from different users.\n\n",
              "markdownDescription": "\nThe user's email address, used to differentiate traffic from different users.\n\n",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Supported Encryption Methods": {
      "title": "Supported Encryption Methods",
      "description": "The currently supported methods are following:\n\n- Recommended encryption methods:\n  - `2022-blake3-aes-128-gcm`\n  - `2022-blake3-aes-256-gcm`\n  - `2022-blake3-chacha20-poly1305`\n- Other encryption methods:\n  - `aes-256-gcm`\n  - `aes-128-gcm`\n  - `chacha20-poly1305`/`chacha20-ietf-poly1305`\n  - `xchacha20-poly1305`/`xchacha20-ietf-poly1305`\n  - `none`/`plain`\n\nThe Shadowsocks 2022 new protocol format improves performance and includes complete replay protection, addressing the following security issues in the old protocol:\n\n- [Serious vulnerabilities in Shadowsocks AEAD encryption, which cannot guarantee the integrity of the communication content](https://github.com/shadowsocks/shadowsocks-org/issues/183)\n- Increasing false positive rate of the original TCP replay filter over time\n- Lack of UDP replay protection\n- TCP behaviors that can be used for active probing\n\n::: danger\nTraffic transmitted without encryption using the \"none\" method will be in plain text. **Do not use it on public networks** for security reasons.\n:::\n\n",
      "markdownDescription": "The currently supported methods are following:\n\n- Recommended encryption methods:\n  - `2022-blake3-aes-128-gcm`\n  - `2022-blake3-aes-256-gcm`\n  - `2022-blake3-chacha20-poly1305`\n- Other encryption methods:\n  - `aes-256-gcm`\n  - `aes-128-gcm`\n  - `chacha20-poly1305`/`chacha20-ietf-poly1305`\n  - `xchacha20-poly1305`/`xchacha20-ietf-poly1305`\n  - `none`/`plain`\n\nThe Shadowsocks 2022 new protocol format improves performance and includes complete replay protection, addressing the following security issues in the old protocol:\n\n- [Serious vulnerabilities in Shadowsocks AEAD encryption, which cannot guarantee the integrity of the communication content](https://github.com/shadowsocks/shadowsocks-org/issues/183)\n- Increasing false positive rate of the original TCP replay filter over time\n- Lack of UDP replay protection\n- TCP behaviors that can be used for active probing\n\n::: danger\nTraffic transmitted without encryption using the \"none\" method will be in plain text. **Do not use it on public networks** for security reasons.\n:::\n\n",
      "properties": {},
      "additionalProperties": true
    },
    "DetourObject": {
      "title": "DetourObject",
      "description": "\n```json\n{\n  \"to\": \"tag_to_detour\"\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"to\": \"tag_to_detour\"\n}\n```\n\n",
      "properties": {
        "to": {
          "name": "to",
          "description": "\nThe `tag` of an inbound that specifies the inbound using the VMess protocol.\n\n",
          "markdownDescription": "\nThe `tag` of an inbound that specifies the inbound using the VMess protocol.\n\n",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "DefaultObject": {
      "title": "DefaultObject",
      "description": "\n```json\n{\n  \"level\": 0\n}\n```\n\n",
      "markdownDescription": "\n```json\n{\n  \"level\": 0\n}\n```\n\n",
      "properties": {
        "level": {
          "name": "level",
          "description": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Dokodemo-Door\n\nDokodemo door (Anywhere Door) can listen to a local port and forward all incoming data on this port to a specified server's port, achieving the effect of port mapping.\n\n",
          "markdownDescription": "\nThe user level that the connection will use to determine the corresponding [Local Policy](../policy.md#levelpolicyobject).\n\nThe value of `level` corresponds to the value of `level` in the [policy](../policy.md#policyobject). If not specified, the default value is 0.\n# Dokodemo-Door\n\nDokodemo door (Anywhere Door) can listen to a local port and forward all incoming data on this port to a specified server's port, achieving the effect of port mapping.\n\n",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "Transparent Proxy Configuration Example": {
      "title": "Transparent Proxy Configuration Example",
      "description": "\nPlease refer to the [Transparent Proxy (TProxy) Configuration Tutorial](../../document/level-2/tproxy) for this section.\n# HTTP\n\nHTTP protocol.\n\n::: warning\n**The HTTP protocol does not provide encryption for transmission and is not suitable for transmission over public networks, as it can easily be used as a target for attacks.**\n:::\n\nThe more meaningful use of `http` inbound is to listen in a local network or on the local machine to provide local services for other programs.\n\n::: tip TIP 1\n`http proxy` can only proxy the TCP protocol and cannot handle protocols based on UDP.\n:::\n\n::: tip TIP 2\nIn Linux, you can use the following environment variables to enable global HTTP proxy for the current session (many software support this setting, but some may not).\n\n- `export http_proxy=http://127.0.0.1:8080/` (Change the address to the configured inbound HTTP proxy address)\n- `export https_proxy=$http_proxy`\n- :::\n\n",
      "markdownDescription": "\nPlease refer to the [Transparent Proxy (TProxy) Configuration Tutorial](../../document/level-2/tproxy) for this section.\n# HTTP\n\nHTTP protocol.\n\n::: warning\n**The HTTP protocol does not provide encryption for transmission and is not suitable for transmission over public networks, as it can easily be used as a target for attacks.**\n:::\n\nThe more meaningful use of `http` inbound is to listen in a local network or on the local machine to provide local services for other programs.\n\n::: tip TIP 1\n`http proxy` can only proxy the TCP protocol and cannot handle protocols based on UDP.\n:::\n\n::: tip TIP 2\nIn Linux, you can use the following environment variables to enable global HTTP proxy for the current session (many software support this setting, but some may not).\n\n- `export http_proxy=http://127.0.0.1:8080/` (Change the address to the configured inbound HTTP proxy address)\n- `export https_proxy=$http_proxy`\n- :::\n\n",
      "properties": {},
      "additionalProperties": true
    }
  }
}
